diff -uNr a/ChangeLog b/ChangeLog
--- a/ChangeLog	Sun Apr  1 23:02:03 2001
+++ b/ChangeLog	Mon May 27 17:48:50 2002
@@ -1,3 +1,75 @@
+Sun Aug  5 10:29:42 2001  Owen Taylor  <otaylor@redhat.com>
+
+	* gtk/gtklist.c: ref/unref, not ref/ref.
+
+Sun Aug  5 09:48:08 2001  Owen Taylor  <otaylor@redhat.com>
+
+	* gtk/gtklist.c (gtk_list_clear_items): Fix
+	problem with selecting a new focus child.
+
+	* gtk/gtklist.c (gtk_list_clear_items): Clear 
+	list->undo/list_focus_child after unparenting
+	child, since unparenting the child can result
+	in list->last_focus_child being set. (#58024)
+
+Tue Jul 24 16:41:12 2001  Owen Taylor  <otaylor@redhat.com>
+
+	* configure.in po/ta.po (ALL_LINGUAS): Remove dummy ta po - Tamil
+	translation doesn't really make sense for GTK+-1.2 anyways,
+	so lets not worry about the fact that it is missing
+	in this branch.
+
+2001-07-24  Darin Adler  <darin@bentspoon.com>
+
+	* acinclude.m4: Add BUILD_INCLUDED_LIBINTL for
+	compatibility with newer gettext.
+
+	* examples/helloworld/.cvsignore: Ignore the
+	generated executable.
+
+2001-07-10  jacob berkman  <jacob@ximian.com>
+
+	* gtk/gtkrc.c: #include <config.h> as the previous patch requires
+	it
+
+2001-06-26  Fatih Demir <kabalak@gtranslator.org>
+
+	* configure.in: Added ta to the languages list.
+
+2001-06-06  Pablo Saratxaga  <pablo@mandrakesoft.com>
+
+	* configure.in: Check for nl_langinfo (CODESET).  Code taken from
+        glib 1.3 branch.
+	* gtk/gtkrc.c,gtk/gtkrc.*,gtk/Makefile.am: changed the algorithm
+	ussed to look for locale dependent rc files so it does a better job
+	finding them based on charset.
+
+2001-06-01  Alex Larsson  <alexl@redhat.com>
+
+	* gdk/gdkevents.c (expose_predicate):
+	Allow expose event compression past configure notify events for
+	other toplevel window. This fixes performance when dragging a
+	window of an application over another window of the same
+	application. In this case there will be interleaved exposure
+	and configure events.
+
+Thu May 31 12:43:57 2001  Owen Taylor  <otaylor@redhat.com>
+
+	* gtk/gtkoptionmenu.c: Account for the fact that the border
+	width is _outside_ the window. (Fixes #54585)
+
+2001-04-19  Federico Mena Quintero  <federico@ximian.com>
+
+	* gtk/gtkwindow.c (gtk_window_focus_filter): Only consider
+	crossing events if the parent of the window is the root window.
+	This is so that GtkPlugs will not do funny things when they think
+	they should get the focus.
+
+Wed Apr 11 16:20:00 2001  Owen Taylor  <otaylor@redhat.com>
+
+	* gtk/gtklabel.c (gtk_label_parse_uline): Fix check
+	of wrong variable.
+
 Sun Apr  1 23:01:31 2001  Owen Taylor  <otaylor@redhat.com>
 
 	* Released 1.2.10.
diff -uNr a/acinclude.m4 b/acinclude.m4
--- a/acinclude.m4	Wed Feb  2 20:07:42 2000
+++ b/acinclude.m4	Mon May 27 17:48:50 2002
@@ -452,6 +452,7 @@
     AC_MSG_RESULT($USE_NLS)
     AC_SUBST(USE_NLS)
 
+    BUILD_INCLUDED_LIBINTL=no
     USE_INCLUDED_LIBINTL=no
 
     dnl If we use NLS figure out what method
@@ -632,6 +633,7 @@
     done
 
     dnl Make all variables we use known to autoconf.
+    AC_SUBST(BUILD_INCLUDED_LIBINTL)
     AC_SUBST(USE_INCLUDED_LIBINTL)
     AC_SUBST(CATALOGS)
     AC_SUBST(CATOBJEXT)
diff -uNr a/configure.in b/configure.in
--- a/configure.in	Thu Mar 15 15:31:58 2001
+++ b/configure.in	Mon May 27 17:48:50 2002
@@ -183,7 +183,7 @@
 AC_SUBST(STRIP_END)
 
 # i18n stuff
-ALL_LINGUAS="az ca cs da de el es et eu fi fr ga gl hr hu it ja ko lt nl no nn pl pt pt_BR ro ru sk sl sp sr sv tr uk vi wa zh_CN.GB2312 zh_TW.Big5"
+ALL_LINGUAS="az ca cs da de el es et eu fi fr ga gl hr hu it ja ko lt lv nl no nn pl pt pt_BR ro ru sk sl sp sr sv tr uk vi wa zh_CN.GB2312 zh_TW.Big5"
 AM_GTK_GNU_GETTEXT
 LIBS="$LIBS $INTLLIBS"
 
@@ -192,6 +192,15 @@
 gtklocaledir='${prefix}/${DATADIRNAME}/locale'
 AC_SUBST(gtklocaledir)
 
+dnl Check for nl_langinfo and CODESET
+AC_MSG_CHECKING([for nl_langinfo (CODESET)])
+AC_TRY_COMPILE([#include <langinfo.h>],
+        [char *codeset = nl_langinfo (CODESET);],
+   AC_DEFINE(HAVE_CODESET,1,[Have nl_langinfo (CODESET)])
+   have_codeset=yes,
+   have_codeset=no)
+AC_MSG_RESULT($have_codeset)
+
 dnl The DU4 header files don't provide library prototypes unless 
 dnl -std1 is given to the native cc.
 AC_MSG_CHECKING([for extra flags to get ANSI library prototypes])
diff -uNr a/gdk/gdk.c b/gdk/gdk.c
--- a/gdk/gdk.c	Fri Mar  9 22:32:30 2001
+++ b/gdk/gdk.c	Mon May 27 17:47:20 2002
@@ -704,16 +704,18 @@
   
   if (return_val == Success)
     {
-      if (!window_private->destroyed)
-	return_val = XGrabPointer (window_private->xdisplay,
-				   xwindow,
-				   owner_events,
-				   xevent_mask,
-				   GrabModeAsync, GrabModeAsync,
-				   xconfine_to,
-				   xcursor,
-				   time);
-      else
+      if (!window_private->destroyed) {
+	if (getenv ("GTK_NO_GRAB") == NULL) {
+	  return_val = XGrabPointer (window_private->xdisplay,
+				     xwindow,
+				     owner_events,
+				     xevent_mask,
+				     GrabModeAsync, GrabModeAsync,
+				     xconfine_to,
+				     xcursor,
+				     time);
+	}
+      } else
 	return_val = AlreadyGrabbed;
     }
   
@@ -802,13 +804,16 @@
   window_private = (GdkWindowPrivate*) window;
   xwindow = window_private->xwindow;
   
-  if (!window_private->destroyed)
-    return XGrabKeyboard (window_private->xdisplay,
-			  xwindow,
-			  owner_events,
-			  GrabModeAsync, GrabModeAsync,
-			  time);
-  else
+  if (!window_private->destroyed) {
+    if (getenv ("GTK_NO_GRAB") == NULL) {
+      return XGrabKeyboard (window_private->xdisplay,
+			    xwindow,
+			    owner_events,
+			    GrabModeAsync, GrabModeAsync,
+			    time);
+    } else
+      return Success;
+  } else
     return AlreadyGrabbed;
 }
 
diff -uNr a/gdk/gdkevents.c b/gdk/gdkevents.c
--- a/gdk/gdkevents.c	Sun Dec  3 11:02:49 2000
+++ b/gdk/gdkevents.c	Mon May 27 17:48:50 2002
@@ -383,6 +383,7 @@
 struct _GdkExposeInfo
 {
   Window window;
+  Window toplevel_window;
   gboolean seen_nonmatching;
 };
 
@@ -401,7 +402,9 @@
    * expose events.
    */
   if (xevent->xany.type != Expose && 
-      xevent->xany.type != GravityNotify)
+      xevent->xany.type != GravityNotify &&
+      (xevent->xany.type != ConfigureNotify ||
+       xevent->xany.window == info->toplevel_window))
     {
       info->seen_nonmatching = TRUE;
     }
@@ -429,6 +432,7 @@
   GdkEvent event;
 
   info.window = xevent->xany.window;
+  info.toplevel_window = GDK_WINDOW_XWINDOW (gdk_window_get_toplevel (window));
   info.seen_nonmatching = FALSE;
   
   rect1.x = xevent->xexpose.x;
diff -uNr a/gtk/Makefile.am b/gtk/Makefile.am
--- a/gtk/Makefile.am	Fri Feb  2 12:09:02 2001
+++ b/gtk/Makefile.am	Mon May 27 17:48:50 2002
@@ -374,9 +374,11 @@
 
 
 gtkconfdir = $(sysconfdir)/gtk
-gtkconf_DATA = gtkrc.az gtkrc.el gtkrc.eo gtkrc.he gtkrc.hy gtkrc.ja \
-	gtkrc.ko gtkrc.ru gtkrc.tr gtkrc.th gtkrc.uk gtkrc.iso-8859-2 \
-	gtkrc.iso-8859-5 gtkrc.iso-8859-13 gtkrc.iso-8859-14 \
+gtkconf_DATA = gtkrc.az gtkrc.he gtkrc.hy gtkrc.ja \
+	gtkrc.ko gtkrc.ru gtkrc.th gtkrc.uk \
+	gtkrc.utf-8 gtkrc.iso-8859-2 \
+	gtkrc.iso-8859-3 gtkrc.iso-8859-5 gtkrc.iso-8859-7 \
+	gtkrc.iso-8859-9 gtkrc.iso-8859-13 gtkrc.iso-8859-14 \
 	gtkrc.iso-8859-15 gtkrc.zh_CN gtkrc.zh_TW.big5 \
 	gtkrc.ka_GE.georgianacademy gtkrc.ka_GE.georgianps \
 	gtkrc.vi_VN.tcvn gtkrc.vi_VN.viscii gtkrc.cp1251 gtkrc.cp1255
diff -uNr a/gtk/gtkctree.c b/gtk/gtkctree.c
--- a/gtk/gtkctree.c	Mon Feb 19 16:08:18 2001
+++ b/gtk/gtkctree.c	Mon May 27 17:47:20 2002
@@ -630,8 +630,8 @@
   ctree->tree_indent    = 20;
   ctree->tree_spacing   = 5;
   ctree->tree_column    = 0;
-  ctree->line_style     = GTK_CTREE_LINES_SOLID;
-  ctree->expander_style = GTK_CTREE_EXPANDER_SQUARE;
+  ctree->line_style     = GTK_CTREE_LINES_NONE;
+  ctree->expander_style = GTK_CTREE_EXPANDER_TRIANGLE;
   ctree->drag_compare   = NULL;
   ctree->show_stub      = TRUE;
 
diff -uNr a/gtk/gtkctree.c~ b/gtk/gtkctree.c~
--- a/gtk/gtkctree.c~	Wed Dec 31 19:00:00 1969
+++ b/gtk/gtkctree.c~	Mon Feb 19 16:08:18 2001
@@ -0,0 +1,6171 @@
+/* GTK - The GIMP Toolkit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball, Josh MacDonald, 
+ * Copyright (C) 1997-1998 Jay Painter <jpaint@serv.net><jpaint@gimp.org>  
+ *
+ * GtkCTree widget for GTK+
+ * Copyright (C) 1998 Lars Hamann and Stefan Jeske
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include <stdlib.h>
+#include "gtkctree.h"
+#include "gtkbindings.h"
+#include "gtkmain.h"
+#include "gtkdnd.h"
+#include <gdk/gdkx.h>
+#include <gdk/gdkkeysyms.h>
+
+#define PM_SIZE                    8
+#define TAB_SIZE                   (PM_SIZE + 6)
+#define CELL_SPACING               1
+#define CLIST_OPTIMUM_SIZE         64
+#define COLUMN_INSET               3
+#define DRAG_WIDTH                 6
+
+#define ROW_TOP_YPIXEL(clist, row) (((clist)->row_height * (row)) + \
+				    (((row) + 1) * CELL_SPACING) + \
+				    (clist)->voffset)
+#define ROW_FROM_YPIXEL(clist, y)  (((y) - (clist)->voffset) / \
+                                    ((clist)->row_height + CELL_SPACING))
+#define COLUMN_LEFT_XPIXEL(clist, col)  ((clist)->column[(col)].area.x \
+                                    + (clist)->hoffset)
+#define COLUMN_LEFT(clist, column) ((clist)->column[(column)].area.x)
+
+static inline gint
+COLUMN_FROM_XPIXEL (GtkCList * clist,
+		    gint x)
+{
+  gint i, cx;
+
+  for (i = 0; i < clist->columns; i++)
+    if (clist->column[i].visible)
+      {
+	cx = clist->column[i].area.x + clist->hoffset;
+
+	if (x >= (cx - (COLUMN_INSET + CELL_SPACING)) &&
+	    x <= (cx + clist->column[i].area.width + COLUMN_INSET))
+	  return i;
+      }
+
+  /* no match */
+  return -1;
+}
+
+#define GTK_CLIST_CLASS_FW(_widget_) GTK_CLIST_CLASS (((GtkObject*) (_widget_))->klass)
+#define CLIST_UNFROZEN(clist)     (((GtkCList*) (clist))->freeze_count == 0)
+#define CLIST_REFRESH(clist)    G_STMT_START { \
+  if (CLIST_UNFROZEN (clist)) \
+    GTK_CLIST_CLASS_FW (clist)->refresh ((GtkCList*) (clist)); \
+} G_STMT_END
+
+
+enum {
+  ARG_0,
+  ARG_N_COLUMNS,
+  ARG_TREE_COLUMN,
+  ARG_INDENT,
+  ARG_SPACING,
+  ARG_SHOW_STUB,
+  ARG_LINE_STYLE,
+  ARG_EXPANDER_STYLE
+};
+
+
+static void gtk_ctree_class_init        (GtkCTreeClass  *klass);
+static void gtk_ctree_init              (GtkCTree       *ctree);
+static void gtk_ctree_set_arg		(GtkObject      *object,
+					 GtkArg         *arg,
+					 guint           arg_id);
+static void gtk_ctree_get_arg      	(GtkObject      *object,
+					 GtkArg         *arg,
+					 guint           arg_id);
+static void gtk_ctree_realize           (GtkWidget      *widget);
+static void gtk_ctree_unrealize         (GtkWidget      *widget);
+static gint gtk_ctree_button_press      (GtkWidget      *widget,
+					 GdkEventButton *event);
+static void ctree_attach_styles         (GtkCTree       *ctree,
+					 GtkCTreeNode   *node,
+					 gpointer        data);
+static void ctree_detach_styles         (GtkCTree       *ctree,
+					 GtkCTreeNode   *node, 
+					 gpointer        data);
+static gint draw_cell_pixmap            (GdkWindow      *window,
+					 GdkRectangle   *clip_rectangle,
+					 GdkGC          *fg_gc,
+					 GdkPixmap      *pixmap,
+					 GdkBitmap      *mask,
+					 gint            x,
+					 gint            y,
+					 gint            width,
+					 gint            height);
+static void get_cell_style              (GtkCList       *clist,
+					 GtkCListRow    *clist_row,
+					 gint            state,
+					 gint            column,
+					 GtkStyle      **style,
+					 GdkGC         **fg_gc,
+					 GdkGC         **bg_gc);
+static gint gtk_ctree_draw_expander     (GtkCTree       *ctree,
+					 GtkCTreeRow    *ctree_row,
+					 GtkStyle       *style,
+					 GdkRectangle   *clip_rectangle,
+					 gint            x);
+static gint gtk_ctree_draw_lines        (GtkCTree       *ctree,
+					 GtkCTreeRow    *ctree_row,
+					 gint            row,
+					 gint            column,
+					 gint            state,
+					 GdkRectangle   *clip_rectangle,
+					 GdkRectangle   *cell_rectangle,
+					 GdkRectangle   *crect,
+					 GdkRectangle   *area,
+					 GtkStyle       *style);
+static void draw_row                    (GtkCList       *clist,
+					 GdkRectangle   *area,
+					 gint            row,
+					 GtkCListRow    *clist_row);
+static void draw_drag_highlight         (GtkCList        *clist,
+					 GtkCListRow     *dest_row,
+					 gint             dest_row_number,
+					 GtkCListDragPos  drag_pos);
+static void tree_draw_node              (GtkCTree      *ctree,
+					 GtkCTreeNode  *node);
+static void set_cell_contents           (GtkCList      *clist,
+					 GtkCListRow   *clist_row,
+					 gint           column,
+					 GtkCellType    type,
+					 const gchar   *text,
+					 guint8         spacing,
+					 GdkPixmap     *pixmap,
+					 GdkBitmap     *mask);
+static void set_node_info               (GtkCTree      *ctree,
+					 GtkCTreeNode  *node,
+					 const gchar   *text,
+					 guint8         spacing,
+					 GdkPixmap     *pixmap_closed,
+					 GdkBitmap     *mask_closed,
+					 GdkPixmap     *pixmap_opened,
+					 GdkBitmap     *mask_opened,
+					 gboolean       is_leaf,
+					 gboolean       expanded);
+static GtkCTreeRow *row_new             (GtkCTree      *ctree);
+static void row_delete                  (GtkCTree      *ctree,
+				 	 GtkCTreeRow   *ctree_row);
+static void tree_delete                 (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node, 
+					 gpointer       data);
+static void tree_delete_row             (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node, 
+					 gpointer       data);
+static void real_clear                  (GtkCList      *clist);
+static void tree_update_level           (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node, 
+					 gpointer       data);
+static void tree_select                 (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node, 
+					 gpointer       data);
+static void tree_unselect               (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node, 
+				         gpointer       data);
+static void real_select_all             (GtkCList      *clist);
+static void real_unselect_all           (GtkCList      *clist);
+static void tree_expand                 (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node,
+					 gpointer       data);
+static void tree_collapse               (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node,
+					 gpointer       data);
+static void tree_collapse_to_depth      (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node, 
+					 gint           depth);
+static void tree_toggle_expansion       (GtkCTree      *ctree,
+					 GtkCTreeNode  *node,
+					 gpointer       data);
+static void change_focus_row_expansion  (GtkCTree      *ctree,
+				         GtkCTreeExpansionType expansion);
+static void real_select_row             (GtkCList      *clist,
+					 gint           row,
+					 gint           column,
+					 GdkEvent      *event);
+static void real_unselect_row           (GtkCList      *clist,
+					 gint           row,
+					 gint           column,
+					 GdkEvent      *event);
+static void real_tree_select            (GtkCTree      *ctree,
+					 GtkCTreeNode  *node,
+					 gint           column);
+static void real_tree_unselect          (GtkCTree      *ctree,
+					 GtkCTreeNode  *node,
+					 gint           column);
+static void real_tree_expand            (GtkCTree      *ctree,
+					 GtkCTreeNode  *node);
+static void real_tree_collapse          (GtkCTree      *ctree,
+					 GtkCTreeNode  *node);
+static void real_tree_move              (GtkCTree      *ctree,
+					 GtkCTreeNode  *node,
+					 GtkCTreeNode  *new_parent, 
+					 GtkCTreeNode  *new_sibling);
+static void real_row_move               (GtkCList      *clist,
+					 gint           source_row,
+					 gint           dest_row);
+static void gtk_ctree_link              (GtkCTree      *ctree,
+					 GtkCTreeNode  *node,
+					 GtkCTreeNode  *parent,
+					 GtkCTreeNode  *sibling,
+					 gboolean       update_focus_row);
+static void gtk_ctree_unlink            (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node,
+					 gboolean       update_focus_row);
+static GtkCTreeNode * gtk_ctree_last_visible (GtkCTree     *ctree,
+					      GtkCTreeNode *node);
+static gboolean ctree_is_hot_spot       (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node,
+					 gint           row, 
+					 gint           x, 
+					 gint           y);
+static void tree_sort                   (GtkCTree      *ctree,
+					 GtkCTreeNode  *node,
+					 gpointer       data);
+static void fake_unselect_all           (GtkCList      *clist,
+					 gint           row);
+static GList * selection_find           (GtkCList      *clist,
+					 gint           row_number,
+					 GList         *row_list_element);
+static void resync_selection            (GtkCList      *clist,
+					 GdkEvent      *event);
+static void real_undo_selection         (GtkCList      *clist);
+static void select_row_recursive        (GtkCTree      *ctree, 
+					 GtkCTreeNode  *node, 
+					 gpointer       data);
+static gint real_insert_row             (GtkCList      *clist,
+					 gint           row,
+					 gchar         *text[]);
+static void real_remove_row             (GtkCList      *clist,
+					 gint           row);
+static void real_sort_list              (GtkCList      *clist);
+static void cell_size_request           (GtkCList       *clist,
+					 GtkCListRow    *clist_row,
+					 gint            column,
+					 GtkRequisition *requisition);
+static void column_auto_resize          (GtkCList       *clist,
+					 GtkCListRow    *clist_row,
+					 gint            column,
+					 gint            old_width);
+static void auto_resize_columns         (GtkCList       *clist);
+
+
+static gboolean check_drag               (GtkCTree         *ctree,
+			                  GtkCTreeNode     *drag_source,
+					  GtkCTreeNode     *drag_target,
+					  GtkCListDragPos   insert_pos);
+static void gtk_ctree_drag_begin         (GtkWidget        *widget,
+					  GdkDragContext   *context);
+static gint gtk_ctree_drag_motion        (GtkWidget        *widget,
+					  GdkDragContext   *context,
+					  gint              x,
+					  gint              y,
+					  guint             time);
+static void gtk_ctree_drag_data_received (GtkWidget        *widget,
+					  GdkDragContext   *context,
+					  gint              x,
+					  gint              y,
+					  GtkSelectionData *selection_data,
+					  guint             info,
+					  guint32           time);
+static void remove_grab                  (GtkCList         *clist);
+static void drag_dest_cell               (GtkCList         *clist,
+					  gint              x,
+					  gint              y,
+					  GtkCListDestInfo *dest_info);
+
+
+enum
+{
+  TREE_SELECT_ROW,
+  TREE_UNSELECT_ROW,
+  TREE_EXPAND,
+  TREE_COLLAPSE,
+  TREE_MOVE,
+  CHANGE_FOCUS_ROW_EXPANSION,
+  LAST_SIGNAL
+};
+
+static GtkCListClass *parent_class = NULL;
+static GtkContainerClass *container_class = NULL;
+static guint ctree_signals[LAST_SIGNAL] = {0};
+
+
+GtkType
+gtk_ctree_get_type (void)
+{
+  static GtkType ctree_type = 0;
+
+  if (!ctree_type)
+    {
+      static const GtkTypeInfo ctree_info =
+      {
+	"GtkCTree",
+	sizeof (GtkCTree),
+	sizeof (GtkCTreeClass),
+	(GtkClassInitFunc) gtk_ctree_class_init,
+	(GtkObjectInitFunc) gtk_ctree_init,
+	/* reserved_1 */ NULL,
+        /* reserved_2 */ NULL,
+        (GtkClassInitFunc) NULL,
+      };
+
+      ctree_type = gtk_type_unique (GTK_TYPE_CLIST, &ctree_info);
+    }
+
+  return ctree_type;
+}
+
+static void
+gtk_ctree_class_init (GtkCTreeClass *klass)
+{
+  GtkObjectClass *object_class;
+  GtkWidgetClass *widget_class;
+  GtkCListClass *clist_class;
+  GtkBindingSet *binding_set;
+
+  object_class = (GtkObjectClass *) klass;
+  widget_class = (GtkWidgetClass *) klass;
+  container_class = (GtkContainerClass *) klass;
+  clist_class = (GtkCListClass *) klass;
+
+  parent_class = gtk_type_class (GTK_TYPE_CLIST);
+  container_class = gtk_type_class (GTK_TYPE_CONTAINER);
+
+  gtk_object_add_arg_type ("GtkCTree::n_columns",
+			   GTK_TYPE_UINT,
+			   GTK_ARG_READWRITE | GTK_ARG_CONSTRUCT_ONLY,
+			   ARG_N_COLUMNS);
+  gtk_object_add_arg_type ("GtkCTree::tree_column",
+			   GTK_TYPE_UINT,
+			   GTK_ARG_READWRITE | GTK_ARG_CONSTRUCT_ONLY,
+			   ARG_TREE_COLUMN);
+  gtk_object_add_arg_type ("GtkCTree::indent",
+			   GTK_TYPE_UINT,
+			   GTK_ARG_READWRITE,
+			   ARG_INDENT);
+  gtk_object_add_arg_type ("GtkCTree::spacing",
+			   GTK_TYPE_UINT,
+			   GTK_ARG_READWRITE,
+			   ARG_SPACING);
+  gtk_object_add_arg_type ("GtkCTree::show_stub",
+			   GTK_TYPE_BOOL,
+			   GTK_ARG_READWRITE,
+			   ARG_SHOW_STUB);
+  gtk_object_add_arg_type ("GtkCTree::line_style",
+			   GTK_TYPE_CTREE_LINE_STYLE,
+			   GTK_ARG_READWRITE,
+			   ARG_LINE_STYLE);
+  gtk_object_add_arg_type ("GtkCTree::expander_style",
+			   GTK_TYPE_CTREE_EXPANDER_STYLE,
+			   GTK_ARG_READWRITE,
+			   ARG_EXPANDER_STYLE);
+  object_class->set_arg = gtk_ctree_set_arg;
+  object_class->get_arg = gtk_ctree_get_arg;
+
+  ctree_signals[TREE_SELECT_ROW] =
+    gtk_signal_new ("tree_select_row",
+		    GTK_RUN_FIRST,
+		    object_class->type,
+		    GTK_SIGNAL_OFFSET (GtkCTreeClass, tree_select_row),
+		    gtk_marshal_NONE__POINTER_INT,
+		    GTK_TYPE_NONE, 2, GTK_TYPE_CTREE_NODE, GTK_TYPE_INT);
+  ctree_signals[TREE_UNSELECT_ROW] =
+    gtk_signal_new ("tree_unselect_row",
+		    GTK_RUN_FIRST,
+		    object_class->type,
+		    GTK_SIGNAL_OFFSET (GtkCTreeClass, tree_unselect_row),
+		    gtk_marshal_NONE__POINTER_INT,
+		    GTK_TYPE_NONE, 2, GTK_TYPE_CTREE_NODE, GTK_TYPE_INT);
+  ctree_signals[TREE_EXPAND] =
+    gtk_signal_new ("tree_expand",
+		    GTK_RUN_LAST,
+		    object_class->type,
+		    GTK_SIGNAL_OFFSET (GtkCTreeClass, tree_expand),
+		    gtk_marshal_NONE__POINTER,
+		    GTK_TYPE_NONE, 1, GTK_TYPE_CTREE_NODE);
+  ctree_signals[TREE_COLLAPSE] =
+    gtk_signal_new ("tree_collapse",
+		    GTK_RUN_LAST,
+		    object_class->type,
+		    GTK_SIGNAL_OFFSET (GtkCTreeClass, tree_collapse),
+		    gtk_marshal_NONE__POINTER,
+		    GTK_TYPE_NONE, 1, GTK_TYPE_CTREE_NODE);
+  ctree_signals[TREE_MOVE] =
+    gtk_signal_new ("tree_move",
+		    GTK_RUN_LAST,
+		    object_class->type,
+		    GTK_SIGNAL_OFFSET (GtkCTreeClass, tree_move),
+		    gtk_marshal_NONE__POINTER_POINTER_POINTER,
+		    GTK_TYPE_NONE, 3, GTK_TYPE_CTREE_NODE,
+		    GTK_TYPE_CTREE_NODE, GTK_TYPE_CTREE_NODE);
+  ctree_signals[CHANGE_FOCUS_ROW_EXPANSION] =
+    gtk_signal_new ("change_focus_row_expansion",
+		    GTK_RUN_LAST | GTK_RUN_ACTION,
+		    object_class->type,
+		    GTK_SIGNAL_OFFSET (GtkCTreeClass,
+				       change_focus_row_expansion),
+		    gtk_marshal_NONE__ENUM,
+		    GTK_TYPE_NONE, 1, GTK_TYPE_CTREE_EXPANSION_TYPE);
+  gtk_object_class_add_signals (object_class, ctree_signals, LAST_SIGNAL);
+
+  widget_class->realize = gtk_ctree_realize;
+  widget_class->unrealize = gtk_ctree_unrealize;
+  widget_class->button_press_event = gtk_ctree_button_press;
+
+  widget_class->drag_begin = gtk_ctree_drag_begin;
+  widget_class->drag_motion = gtk_ctree_drag_motion;
+  widget_class->drag_data_received = gtk_ctree_drag_data_received;
+
+  clist_class->select_row = real_select_row;
+  clist_class->unselect_row = real_unselect_row;
+  clist_class->row_move = real_row_move;
+  clist_class->undo_selection = real_undo_selection;
+  clist_class->resync_selection = resync_selection;
+  clist_class->selection_find = selection_find;
+  clist_class->click_column = NULL;
+  clist_class->draw_row = draw_row;
+  clist_class->draw_drag_highlight = draw_drag_highlight;
+  clist_class->clear = real_clear;
+  clist_class->select_all = real_select_all;
+  clist_class->unselect_all = real_unselect_all;
+  clist_class->fake_unselect_all = fake_unselect_all;
+  clist_class->insert_row = real_insert_row;
+  clist_class->remove_row = real_remove_row;
+  clist_class->sort_list = real_sort_list;
+  clist_class->set_cell_contents = set_cell_contents;
+  clist_class->cell_size_request = cell_size_request;
+
+  klass->tree_select_row = real_tree_select;
+  klass->tree_unselect_row = real_tree_unselect;
+  klass->tree_expand = real_tree_expand;
+  klass->tree_collapse = real_tree_collapse;
+  klass->tree_move = real_tree_move;
+  klass->change_focus_row_expansion = change_focus_row_expansion;
+
+  binding_set = gtk_binding_set_by_class (klass);
+  gtk_binding_entry_add_signal (binding_set,
+				'+', GDK_SHIFT_MASK,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_EXPAND);
+  gtk_binding_entry_add_signal (binding_set,
+				'+', 0,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_EXPAND);
+  gtk_binding_entry_add_signal (binding_set,
+				'+', GDK_CONTROL_MASK | GDK_SHIFT_MASK,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_EXPAND_RECURSIVE);
+  gtk_binding_entry_add_signal (binding_set,
+				'+', GDK_CONTROL_MASK,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_EXPAND_RECURSIVE);
+  gtk_binding_entry_add_signal (binding_set,
+				GDK_KP_Add, 0,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_EXPAND);
+  gtk_binding_entry_add_signal (binding_set,
+				GDK_KP_Add, GDK_CONTROL_MASK,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM,
+				GTK_CTREE_EXPANSION_EXPAND_RECURSIVE);
+  gtk_binding_entry_add_signal (binding_set,
+				'-', 0,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_COLLAPSE);
+  gtk_binding_entry_add_signal (binding_set,
+				'-', GDK_CONTROL_MASK,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM,
+				GTK_CTREE_EXPANSION_COLLAPSE_RECURSIVE);
+  gtk_binding_entry_add_signal (binding_set,
+				GDK_KP_Subtract, 0,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_COLLAPSE);
+  gtk_binding_entry_add_signal (binding_set,
+				GDK_KP_Subtract, GDK_CONTROL_MASK,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM,
+				GTK_CTREE_EXPANSION_COLLAPSE_RECURSIVE);
+  gtk_binding_entry_add_signal (binding_set,
+				'=', 0,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_TOGGLE);
+  gtk_binding_entry_add_signal (binding_set,
+				'=', GDK_SHIFT_MASK,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_TOGGLE);
+  gtk_binding_entry_add_signal (binding_set,
+				GDK_KP_Multiply, 0,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM, GTK_CTREE_EXPANSION_TOGGLE);
+  gtk_binding_entry_add_signal (binding_set,
+				GDK_KP_Multiply, GDK_CONTROL_MASK,
+				"change_focus_row_expansion", 1,
+				GTK_TYPE_ENUM,
+				GTK_CTREE_EXPANSION_TOGGLE_RECURSIVE);
+}
+
+static void
+gtk_ctree_set_arg (GtkObject      *object,
+		   GtkArg         *arg,
+		   guint           arg_id)
+{
+  GtkCTree *ctree;
+
+  ctree = GTK_CTREE (object);
+
+  switch (arg_id)
+    {
+    case ARG_N_COLUMNS: /* construct-only arg, only set when !GTK_CONSTRUCTED */
+      if (ctree->tree_column)
+	gtk_ctree_construct (ctree,
+			     MAX (1, GTK_VALUE_UINT (*arg)),
+			     ctree->tree_column, NULL);
+      else
+	GTK_CLIST (ctree)->columns = MAX (1, GTK_VALUE_UINT (*arg));
+      break;
+    case ARG_TREE_COLUMN: /* construct-only arg, only set when !GTK_CONSTRUCTED */
+      if (GTK_CLIST (ctree)->columns)
+	gtk_ctree_construct (ctree,
+			     GTK_CLIST (ctree)->columns,
+			     MAX (1, GTK_VALUE_UINT (*arg)),
+			     NULL);
+      else
+	ctree->tree_column = MAX (1, GTK_VALUE_UINT (*arg));
+      break;
+    case ARG_INDENT:
+      gtk_ctree_set_indent (ctree, GTK_VALUE_UINT (*arg));
+      break;
+    case ARG_SPACING:
+      gtk_ctree_set_spacing (ctree, GTK_VALUE_UINT (*arg));
+      break;
+    case ARG_SHOW_STUB:
+      gtk_ctree_set_show_stub (ctree, GTK_VALUE_BOOL (*arg));
+      break;
+    case ARG_LINE_STYLE:
+      gtk_ctree_set_line_style (ctree, GTK_VALUE_ENUM (*arg));
+      break;
+    case ARG_EXPANDER_STYLE:
+      gtk_ctree_set_expander_style (ctree, GTK_VALUE_ENUM (*arg));
+      break;
+    default:
+      break;
+    }
+}
+
+static void
+gtk_ctree_get_arg (GtkObject      *object,
+		   GtkArg         *arg,
+		   guint           arg_id)
+{
+  GtkCTree *ctree;
+
+  ctree = GTK_CTREE (object);
+
+  switch (arg_id)
+    {
+    case ARG_N_COLUMNS:
+      GTK_VALUE_UINT (*arg) = GTK_CLIST (ctree)->columns;
+      break;
+    case ARG_TREE_COLUMN:
+      GTK_VALUE_UINT (*arg) = ctree->tree_column;
+      break;
+    case ARG_INDENT:
+      GTK_VALUE_UINT (*arg) = ctree->tree_indent;
+      break;
+    case ARG_SPACING:
+      GTK_VALUE_UINT (*arg) = ctree->tree_spacing;
+      break;
+    case ARG_SHOW_STUB:
+      GTK_VALUE_BOOL (*arg) = ctree->show_stub;
+      break;
+    case ARG_LINE_STYLE:
+      GTK_VALUE_ENUM (*arg) = ctree->line_style;
+      break;
+    case ARG_EXPANDER_STYLE:
+      GTK_VALUE_ENUM (*arg) = ctree->expander_style;
+      break;
+    default:
+      arg->type = GTK_TYPE_INVALID;
+      break;
+    }
+}
+
+static void
+gtk_ctree_init (GtkCTree *ctree)
+{
+  GtkCList *clist;
+
+  GTK_CLIST_SET_FLAG (ctree, CLIST_DRAW_DRAG_RECT);
+  GTK_CLIST_SET_FLAG (ctree, CLIST_DRAW_DRAG_LINE);
+
+  clist = GTK_CLIST (ctree);
+
+  ctree->tree_indent    = 20;
+  ctree->tree_spacing   = 5;
+  ctree->tree_column    = 0;
+  ctree->line_style     = GTK_CTREE_LINES_SOLID;
+  ctree->expander_style = GTK_CTREE_EXPANDER_SQUARE;
+  ctree->drag_compare   = NULL;
+  ctree->show_stub      = TRUE;
+
+  clist->button_actions[0] |= GTK_BUTTON_EXPANDS;
+}
+
+static void
+ctree_attach_styles (GtkCTree     *ctree,
+		     GtkCTreeNode *node,
+		     gpointer      data)
+{
+  GtkCList *clist;
+  gint i;
+
+  clist = GTK_CLIST (ctree);
+
+  if (GTK_CTREE_ROW (node)->row.style)
+    GTK_CTREE_ROW (node)->row.style =
+      gtk_style_attach (GTK_CTREE_ROW (node)->row.style, clist->clist_window);
+
+  if (GTK_CTREE_ROW (node)->row.fg_set || GTK_CTREE_ROW (node)->row.bg_set)
+    {
+      GdkColormap *colormap;
+
+      colormap = gtk_widget_get_colormap (GTK_WIDGET (ctree));
+      if (GTK_CTREE_ROW (node)->row.fg_set)
+	gdk_color_alloc (colormap, &(GTK_CTREE_ROW (node)->row.foreground));
+      if (GTK_CTREE_ROW (node)->row.bg_set)
+	gdk_color_alloc (colormap, &(GTK_CTREE_ROW (node)->row.background));
+    }
+
+  for (i = 0; i < clist->columns; i++)
+    if  (GTK_CTREE_ROW (node)->row.cell[i].style)
+      GTK_CTREE_ROW (node)->row.cell[i].style =
+	gtk_style_attach (GTK_CTREE_ROW (node)->row.cell[i].style,
+			  clist->clist_window);
+}
+
+static void
+ctree_detach_styles (GtkCTree     *ctree,
+		     GtkCTreeNode *node,
+		     gpointer      data)
+{
+  GtkCList *clist;
+  gint i;
+
+  clist = GTK_CLIST (ctree);
+
+  if (GTK_CTREE_ROW (node)->row.style)
+    gtk_style_detach (GTK_CTREE_ROW (node)->row.style);
+  for (i = 0; i < clist->columns; i++)
+    if  (GTK_CTREE_ROW (node)->row.cell[i].style)
+      gtk_style_detach (GTK_CTREE_ROW (node)->row.cell[i].style);
+}
+
+static void
+gtk_ctree_realize (GtkWidget *widget)
+{
+  GtkCTree *ctree;
+  GtkCList *clist;
+  GdkGCValues values;
+  GtkCTreeNode *node;
+  GtkCTreeNode *child;
+  gint i;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_CTREE (widget));
+
+  GTK_WIDGET_CLASS (parent_class)->realize (widget);
+
+  ctree = GTK_CTREE (widget);
+  clist = GTK_CLIST (widget);
+
+  node = GTK_CTREE_NODE (clist->row_list);
+  for (i = 0; i < clist->rows; i++)
+    {
+      if (GTK_CTREE_ROW (node)->children && !GTK_CTREE_ROW (node)->expanded)
+	for (child = GTK_CTREE_ROW (node)->children; child;
+	     child = GTK_CTREE_ROW (child)->sibling)
+	  gtk_ctree_pre_recursive (ctree, child, ctree_attach_styles, NULL);
+      node = GTK_CTREE_NODE_NEXT (node);
+    }
+
+  values.foreground = widget->style->fg[GTK_STATE_NORMAL];
+  values.background = widget->style->base[GTK_STATE_NORMAL];
+  values.subwindow_mode = GDK_INCLUDE_INFERIORS;
+  values.line_style = GDK_LINE_SOLID;
+  ctree->lines_gc = gdk_gc_new_with_values (GTK_CLIST(widget)->clist_window, 
+					    &values,
+					    GDK_GC_FOREGROUND |
+					    GDK_GC_BACKGROUND |
+					    GDK_GC_SUBWINDOW |
+					    GDK_GC_LINE_STYLE);
+
+  if (ctree->line_style == GTK_CTREE_LINES_DOTTED)
+    {
+      gdk_gc_set_line_attributes (ctree->lines_gc, 1, 
+				  GDK_LINE_ON_OFF_DASH, None, None);
+      gdk_gc_set_dashes (ctree->lines_gc, 0, "\1\1", 2);
+    }
+}
+
+static void
+gtk_ctree_unrealize (GtkWidget *widget)
+{
+  GtkCTree *ctree;
+  GtkCList *clist;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_CTREE (widget));
+
+  GTK_WIDGET_CLASS (parent_class)->unrealize (widget);
+
+  ctree = GTK_CTREE (widget);
+  clist = GTK_CLIST (widget);
+
+  if (GTK_WIDGET_REALIZED (widget))
+    {
+      GtkCTreeNode *node;
+      GtkCTreeNode *child;
+      gint i;
+
+      node = GTK_CTREE_NODE (clist->row_list);
+      for (i = 0; i < clist->rows; i++)
+	{
+	  if (GTK_CTREE_ROW (node)->children &&
+	      !GTK_CTREE_ROW (node)->expanded)
+	    for (child = GTK_CTREE_ROW (node)->children; child;
+		 child = GTK_CTREE_ROW (child)->sibling)
+	      gtk_ctree_pre_recursive(ctree, child, ctree_detach_styles, NULL);
+	  node = GTK_CTREE_NODE_NEXT (node);
+	}
+    }
+
+  gdk_gc_destroy (ctree->lines_gc);
+}
+
+static gint
+gtk_ctree_button_press (GtkWidget      *widget,
+			GdkEventButton *event)
+{
+  GtkCTree *ctree;
+  GtkCList *clist;
+  gint button_actions;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_CTREE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  ctree = GTK_CTREE (widget);
+  clist = GTK_CLIST (widget);
+
+  button_actions = clist->button_actions[event->button - 1];
+
+  if (button_actions == GTK_BUTTON_IGNORED)
+    return FALSE;
+
+  if (event->window == clist->clist_window)
+    {
+      GtkCTreeNode *work;
+      gint x;
+      gint y;
+      gint row;
+      gint column;
+
+      x = event->x;
+      y = event->y;
+
+      if (!gtk_clist_get_selection_info (clist, x, y, &row, &column))
+	return FALSE;
+
+      work = GTK_CTREE_NODE (g_list_nth (clist->row_list, row));
+	  
+      if (button_actions & GTK_BUTTON_EXPANDS &&
+	  (GTK_CTREE_ROW (work)->children && !GTK_CTREE_ROW (work)->is_leaf  &&
+	   (event->type == GDK_2BUTTON_PRESS ||
+	    ctree_is_hot_spot (ctree, work, row, x, y))))
+	{
+	  if (GTK_CTREE_ROW (work)->expanded)
+	    gtk_ctree_collapse (ctree, work);
+	  else
+	    gtk_ctree_expand (ctree, work);
+
+	  return FALSE;
+	}
+    }
+  return GTK_WIDGET_CLASS (parent_class)->button_press_event (widget, event);
+}
+
+static void
+draw_drag_highlight (GtkCList        *clist,
+		     GtkCListRow     *dest_row,
+		     gint             dest_row_number,
+		     GtkCListDragPos  drag_pos)
+{
+  GtkCTree *ctree;
+  GdkPoint points[4];
+  gint level;
+  gint i;
+  gint y = 0;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+
+  ctree = GTK_CTREE (clist);
+
+  level = ((GtkCTreeRow *)(dest_row))->level;
+
+  y = ROW_TOP_YPIXEL (clist, dest_row_number) - 1;
+
+  switch (drag_pos)
+    {
+    case GTK_CLIST_DRAG_NONE:
+      break;
+    case GTK_CLIST_DRAG_AFTER:
+      y += clist->row_height + 1;
+    case GTK_CLIST_DRAG_BEFORE:
+      
+      if (clist->column[ctree->tree_column].visible)
+	switch (clist->column[ctree->tree_column].justification)
+	  {
+	  case GTK_JUSTIFY_CENTER:
+	  case GTK_JUSTIFY_FILL:
+	  case GTK_JUSTIFY_LEFT:
+	    if (ctree->tree_column > 0)
+	      gdk_draw_line (clist->clist_window, clist->xor_gc, 
+			     COLUMN_LEFT_XPIXEL(clist, 0), y,
+			     COLUMN_LEFT_XPIXEL(clist, ctree->tree_column - 1)+
+			     clist->column[ctree->tree_column - 1].area.width,
+			     y);
+
+	    gdk_draw_line (clist->clist_window, clist->xor_gc, 
+			   COLUMN_LEFT_XPIXEL(clist, ctree->tree_column) + 
+			   ctree->tree_indent * level -
+			   (ctree->tree_indent - PM_SIZE) / 2, y,
+			   GTK_WIDGET (ctree)->allocation.width, y);
+	    break;
+	  case GTK_JUSTIFY_RIGHT:
+	    if (ctree->tree_column < clist->columns - 1)
+	      gdk_draw_line (clist->clist_window, clist->xor_gc, 
+			     COLUMN_LEFT_XPIXEL(clist, ctree->tree_column + 1),
+			     y,
+			     COLUMN_LEFT_XPIXEL(clist, clist->columns - 1) +
+			     clist->column[clist->columns - 1].area.width, y);
+      
+	    gdk_draw_line (clist->clist_window, clist->xor_gc, 
+			   0, y, COLUMN_LEFT_XPIXEL(clist, ctree->tree_column)
+			   + clist->column[ctree->tree_column].area.width -
+			   ctree->tree_indent * level +
+			   (ctree->tree_indent - PM_SIZE) / 2, y);
+	    break;
+	  }
+      else
+	gdk_draw_line (clist->clist_window, clist->xor_gc, 
+		       0, y, clist->clist_window_width, y);
+      break;
+    case GTK_CLIST_DRAG_INTO:
+      y = ROW_TOP_YPIXEL (clist, dest_row_number) + clist->row_height;
+
+      if (clist->column[ctree->tree_column].visible)
+	switch (clist->column[ctree->tree_column].justification)
+	  {
+	  case GTK_JUSTIFY_CENTER:
+	  case GTK_JUSTIFY_FILL:
+	  case GTK_JUSTIFY_LEFT:
+	    points[0].x =  COLUMN_LEFT_XPIXEL(clist, ctree->tree_column) + 
+	      ctree->tree_indent * level - (ctree->tree_indent - PM_SIZE) / 2;
+	    points[0].y = y;
+	    points[3].x = points[0].x;
+	    points[3].y = y - clist->row_height - 1;
+	    points[1].x = clist->clist_window_width - 1;
+	    points[1].y = points[0].y;
+	    points[2].x = points[1].x;
+	    points[2].y = points[3].y;
+
+	    for (i = 0; i < 3; i++)
+	      gdk_draw_line (clist->clist_window, clist->xor_gc,
+			     points[i].x, points[i].y,
+			     points[i+1].x, points[i+1].y);
+
+	    if (ctree->tree_column > 0)
+	      {
+		points[0].x = COLUMN_LEFT_XPIXEL(clist,
+						 ctree->tree_column - 1) +
+		  clist->column[ctree->tree_column - 1].area.width ;
+		points[0].y = y;
+		points[3].x = points[0].x;
+		points[3].y = y - clist->row_height - 1;
+		points[1].x = 0;
+		points[1].y = points[0].y;
+		points[2].x = 0;
+		points[2].y = points[3].y;
+
+		for (i = 0; i < 3; i++)
+		  gdk_draw_line (clist->clist_window, clist->xor_gc,
+				 points[i].x, points[i].y, points[i+1].x, 
+				 points[i+1].y);
+	      }
+	    break;
+	  case GTK_JUSTIFY_RIGHT:
+	    points[0].x =  COLUMN_LEFT_XPIXEL(clist, ctree->tree_column) - 
+	      ctree->tree_indent * level + (ctree->tree_indent - PM_SIZE) / 2 +
+	      clist->column[ctree->tree_column].area.width;
+	    points[0].y = y;
+	    points[3].x = points[0].x;
+	    points[3].y = y - clist->row_height - 1;
+	    points[1].x = 0;
+	    points[1].y = points[0].y;
+	    points[2].x = 0;
+	    points[2].y = points[3].y;
+
+	    for (i = 0; i < 3; i++)
+	      gdk_draw_line (clist->clist_window, clist->xor_gc,
+			     points[i].x, points[i].y,
+			     points[i+1].x, points[i+1].y);
+
+	    if (ctree->tree_column < clist->columns - 1)
+	      {
+		points[0].x = COLUMN_LEFT_XPIXEL(clist, ctree->tree_column +1);
+		points[0].y = y;
+		points[3].x = points[0].x;
+		points[3].y = y - clist->row_height - 1;
+		points[1].x = clist->clist_window_width - 1;
+		points[1].y = points[0].y;
+		points[2].x = points[1].x;
+		points[2].y = points[3].y;
+
+		for (i = 0; i < 3; i++)
+		  gdk_draw_line (clist->clist_window, clist->xor_gc,
+				 points[i].x, points[i].y,
+				 points[i+1].x, points[i+1].y);
+	      }
+	    break;
+	  }
+      else
+	gdk_draw_rectangle (clist->clist_window, clist->xor_gc, FALSE,
+			    0, y - clist->row_height,
+			    clist->clist_window_width - 1, clist->row_height);
+      break;
+    }
+}
+
+static gint
+draw_cell_pixmap (GdkWindow    *window,
+		  GdkRectangle *clip_rectangle,
+		  GdkGC        *fg_gc,
+		  GdkPixmap    *pixmap,
+		  GdkBitmap    *mask,
+		  gint          x,
+		  gint          y,
+		  gint          width,
+		  gint          height)
+{
+  gint xsrc = 0;
+  gint ysrc = 0;
+
+  if (mask)
+    {
+      gdk_gc_set_clip_mask (fg_gc, mask);
+      gdk_gc_set_clip_origin (fg_gc, x, y);
+    }
+  if (x < clip_rectangle->x)
+    {
+      xsrc = clip_rectangle->x - x;
+      width -= xsrc;
+      x = clip_rectangle->x;
+    }
+  if (x + width > clip_rectangle->x + clip_rectangle->width)
+    width = clip_rectangle->x + clip_rectangle->width - x;
+
+  if (y < clip_rectangle->y)
+    {
+      ysrc = clip_rectangle->y - y;
+      height -= ysrc;
+      y = clip_rectangle->y;
+    }
+  if (y + height > clip_rectangle->y + clip_rectangle->height)
+    height = clip_rectangle->y + clip_rectangle->height - y;
+
+  if (width > 0 && height > 0)
+    gdk_draw_pixmap (window, fg_gc, pixmap, xsrc, ysrc, x, y, width, height);
+
+  if (mask)
+    {
+      gdk_gc_set_clip_rectangle (fg_gc, NULL);
+      gdk_gc_set_clip_origin (fg_gc, 0, 0);
+    }
+
+  return x + MAX (width, 0);
+}
+
+static void
+get_cell_style (GtkCList     *clist,
+		GtkCListRow  *clist_row,
+		gint          state,
+		gint          column,
+		GtkStyle    **style,
+		GdkGC       **fg_gc,
+		GdkGC       **bg_gc)
+{
+  gint fg_state;
+
+  if ((state == GTK_STATE_NORMAL) &&
+      (GTK_WIDGET (clist)->state == GTK_STATE_INSENSITIVE))
+    fg_state = GTK_STATE_INSENSITIVE;
+  else
+    fg_state = state;
+
+  if (clist_row->cell[column].style)
+    {
+      if (style)
+	*style = clist_row->cell[column].style;
+      if (fg_gc)
+	*fg_gc = clist_row->cell[column].style->fg_gc[fg_state];
+      if (bg_gc) {
+	if (state == GTK_STATE_SELECTED)
+	  *bg_gc = clist_row->cell[column].style->bg_gc[state];
+	else
+	  *bg_gc = clist_row->cell[column].style->base_gc[state];
+      }
+    }
+  else if (clist_row->style)
+    {
+      if (style)
+	*style = clist_row->style;
+      if (fg_gc)
+	*fg_gc = clist_row->style->fg_gc[fg_state];
+      if (bg_gc) {
+	if (state == GTK_STATE_SELECTED)
+	  *bg_gc = clist_row->style->bg_gc[state];
+	else
+	  *bg_gc = clist_row->style->base_gc[state];
+      }
+    }
+  else
+    {
+      if (style)
+	*style = GTK_WIDGET (clist)->style;
+      if (fg_gc)
+	*fg_gc = GTK_WIDGET (clist)->style->fg_gc[fg_state];
+      if (bg_gc) {
+	if (state == GTK_STATE_SELECTED)
+	  *bg_gc = GTK_WIDGET (clist)->style->bg_gc[state];
+	else
+	  *bg_gc = GTK_WIDGET (clist)->style->base_gc[state];
+      }
+
+      if (state != GTK_STATE_SELECTED)
+	{
+	  if (fg_gc && clist_row->fg_set)
+	    *fg_gc = clist->fg_gc;
+	  if (bg_gc && clist_row->bg_set)
+	    *bg_gc = clist->bg_gc;
+	}
+    }
+}
+
+static gint
+gtk_ctree_draw_expander (GtkCTree     *ctree,
+			 GtkCTreeRow  *ctree_row,
+			 GtkStyle     *style,
+			 GdkRectangle *clip_rectangle,
+			 gint          x)
+{
+  GtkCList *clist;
+  GdkPoint points[3];
+  gint justification_factor;
+  gint y;
+
+ if (ctree->expander_style == GTK_CTREE_EXPANDER_NONE)
+   return x;
+
+  clist = GTK_CLIST (ctree);
+  if (clist->column[ctree->tree_column].justification == GTK_JUSTIFY_RIGHT)
+    justification_factor = -1;
+  else
+    justification_factor = 1;
+  y = (clip_rectangle->y + (clip_rectangle->height - PM_SIZE) / 2 -
+       (clip_rectangle->height + 1) % 2);
+
+  if (!ctree_row->children)
+    {
+      switch (ctree->expander_style)
+	{
+	case GTK_CTREE_EXPANDER_NONE:
+	  return x;
+	case GTK_CTREE_EXPANDER_TRIANGLE:
+	  return x + justification_factor * (PM_SIZE + 3);
+	case GTK_CTREE_EXPANDER_SQUARE:
+	case GTK_CTREE_EXPANDER_CIRCULAR:
+	  return x + justification_factor * (PM_SIZE + 1);
+	}
+    }
+
+  gdk_gc_set_clip_rectangle (style->fg_gc[GTK_STATE_NORMAL], clip_rectangle);
+  gdk_gc_set_clip_rectangle (style->base_gc[GTK_STATE_NORMAL], clip_rectangle);
+
+  switch (ctree->expander_style)
+    {
+    case GTK_CTREE_EXPANDER_NONE:
+      break;
+    case GTK_CTREE_EXPANDER_TRIANGLE:
+      if (ctree_row->expanded)
+	{
+	  points[0].x = x;
+	  points[0].y = y + (PM_SIZE + 2) / 6;
+	  points[1].x = points[0].x + justification_factor * (PM_SIZE + 2);
+	  points[1].y = points[0].y;
+	  points[2].x = (points[0].x +
+			 justification_factor * (PM_SIZE + 2) / 2);
+	  points[2].y = y + 2 * (PM_SIZE + 2) / 3;
+	}
+      else
+	{
+	  points[0].x = x + justification_factor * ((PM_SIZE + 2) / 6 + 2);
+	  points[0].y = y - 1;
+	  points[1].x = points[0].x;
+	  points[1].y = points[0].y + (PM_SIZE + 2);
+	  points[2].x = (points[0].x +
+			 justification_factor * (2 * (PM_SIZE + 2) / 3 - 1));
+	  points[2].y = points[0].y + (PM_SIZE + 2) / 2;
+	}
+
+      gdk_draw_polygon (clist->clist_window, style->base_gc[GTK_STATE_NORMAL],
+			TRUE, points, 3);
+      gdk_draw_polygon (clist->clist_window, style->fg_gc[GTK_STATE_NORMAL],
+			FALSE, points, 3);
+
+      x += justification_factor * (PM_SIZE + 3);
+      break;
+    case GTK_CTREE_EXPANDER_SQUARE:
+    case GTK_CTREE_EXPANDER_CIRCULAR:
+      if (justification_factor == -1)
+	x += justification_factor * (PM_SIZE + 1);
+
+      if (ctree->expander_style == GTK_CTREE_EXPANDER_CIRCULAR)
+	{
+	  gdk_draw_arc (clist->clist_window, style->base_gc[GTK_STATE_NORMAL],
+			TRUE, x, y, PM_SIZE, PM_SIZE, 0, 360 * 64);
+	  gdk_draw_arc (clist->clist_window, style->fg_gc[GTK_STATE_NORMAL],
+			FALSE, x, y, PM_SIZE, PM_SIZE, 0, 360 * 64);
+	}
+      else
+	{
+	  gdk_draw_rectangle (clist->clist_window,
+			      style->base_gc[GTK_STATE_NORMAL], TRUE,
+			      x, y, PM_SIZE, PM_SIZE);
+	  gdk_draw_rectangle (clist->clist_window,
+			      style->fg_gc[GTK_STATE_NORMAL], FALSE,
+			      x, y, PM_SIZE, PM_SIZE);
+	}
+
+      gdk_draw_line (clist->clist_window, style->fg_gc[GTK_STATE_NORMAL], 
+		     x + 2, y + PM_SIZE / 2, x + PM_SIZE - 2, y + PM_SIZE / 2);
+
+      if (!ctree_row->expanded)
+	gdk_draw_line (clist->clist_window, style->fg_gc[GTK_STATE_NORMAL],
+		       x + PM_SIZE / 2, y + 2,
+		       x + PM_SIZE / 2, y + PM_SIZE - 2);
+
+      if (justification_factor == 1)
+	x += justification_factor * (PM_SIZE + 1);
+      break;
+    }
+
+  gdk_gc_set_clip_rectangle (style->fg_gc[GTK_STATE_NORMAL], NULL);
+  gdk_gc_set_clip_rectangle (style->base_gc[GTK_STATE_NORMAL], NULL);
+
+  return x;
+}
+
+
+static gint
+gtk_ctree_draw_lines (GtkCTree     *ctree,
+		      GtkCTreeRow  *ctree_row,
+		      gint          row,
+		      gint          column,
+		      gint          state,
+		      GdkRectangle *clip_rectangle,
+		      GdkRectangle *cell_rectangle,
+		      GdkRectangle *crect,
+		      GdkRectangle *area,
+		      GtkStyle     *style)
+{
+  GtkCList *clist;
+  GtkCTreeNode *node;
+  GtkCTreeNode *parent;
+  GdkRectangle tree_rectangle;
+  GdkRectangle tc_rectangle;
+  GdkGC *bg_gc;
+  gint offset;
+  gint offset_x;
+  gint offset_y;
+  gint xcenter;
+  gint ycenter;
+  gint next_level;
+  gint column_right;
+  gint column_left;
+  gint justify_right;
+  gint justification_factor;
+  
+  clist = GTK_CLIST (ctree);
+  ycenter = clip_rectangle->y + (clip_rectangle->height / 2);
+  justify_right = (clist->column[column].justification == GTK_JUSTIFY_RIGHT);
+
+  if (justify_right)
+    {
+      offset = (clip_rectangle->x + clip_rectangle->width - 1 -
+		ctree->tree_indent * (ctree_row->level - 1));
+      justification_factor = -1;
+    }
+  else
+    {
+      offset = clip_rectangle->x + ctree->tree_indent * (ctree_row->level - 1);
+      justification_factor = 1;
+    }
+
+  switch (ctree->line_style)
+    {
+    case GTK_CTREE_LINES_NONE:
+      break;
+    case GTK_CTREE_LINES_TABBED:
+      xcenter = offset + justification_factor * TAB_SIZE;
+
+      column_right = (COLUMN_LEFT_XPIXEL (clist, ctree->tree_column) +
+		      clist->column[ctree->tree_column].area.width +
+		      COLUMN_INSET);
+      column_left = (COLUMN_LEFT_XPIXEL (clist, ctree->tree_column) -
+		     COLUMN_INSET - CELL_SPACING);
+
+      if (area)
+	{
+	  tree_rectangle.y = crect->y;
+	  tree_rectangle.height = crect->height;
+
+	  if (justify_right)
+	    {
+	      tree_rectangle.x = xcenter;
+	      tree_rectangle.width = column_right - xcenter;
+	    }
+	  else
+	    {
+	      tree_rectangle.x = column_left;
+	      tree_rectangle.width = xcenter - column_left;
+	    }
+
+	  if (!gdk_rectangle_intersect (area, &tree_rectangle, &tc_rectangle))
+	    {
+	      offset += justification_factor * 3;
+	      break;
+	    }
+	}
+
+      gdk_gc_set_clip_rectangle (ctree->lines_gc, crect);
+
+      next_level = ctree_row->level;
+
+      if (!ctree_row->sibling || (ctree_row->children && ctree_row->expanded))
+	{
+	  node = gtk_ctree_find_node_ptr (ctree, ctree_row);
+	  if (GTK_CTREE_NODE_NEXT (node))
+	    next_level = GTK_CTREE_ROW (GTK_CTREE_NODE_NEXT (node))->level;
+	  else
+	    next_level = 0;
+	}
+
+      if (ctree->tree_indent > 0)
+	{
+	  node = ctree_row->parent;
+	  while (node)
+	    {
+	      xcenter -= (justification_factor * ctree->tree_indent);
+
+	      if ((justify_right && xcenter < column_left) ||
+		  (!justify_right && xcenter > column_right))
+		{
+		  node = GTK_CTREE_ROW (node)->parent;
+		  continue;
+		}
+
+	      tree_rectangle.y = cell_rectangle->y;
+	      tree_rectangle.height = cell_rectangle->height;
+	      if (justify_right)
+		{
+		  tree_rectangle.x = MAX (xcenter - ctree->tree_indent + 1,
+					  column_left);
+		  tree_rectangle.width = MIN (xcenter - column_left,
+					      ctree->tree_indent);
+		}
+	      else
+		{
+		  tree_rectangle.x = xcenter;
+		  tree_rectangle.width = MIN (column_right - xcenter,
+					      ctree->tree_indent);
+		}
+
+	      if (!area || gdk_rectangle_intersect (area, &tree_rectangle,
+						    &tc_rectangle))
+		{
+		  get_cell_style (clist, &GTK_CTREE_ROW (node)->row,
+				  state, column, NULL, NULL, &bg_gc);
+
+		  if (bg_gc == clist->bg_gc)
+		    gdk_gc_set_foreground
+		      (clist->bg_gc, &GTK_CTREE_ROW (node)->row.background);
+
+		  if (!area)
+		    gdk_draw_rectangle (clist->clist_window, bg_gc, TRUE,
+					tree_rectangle.x,
+					tree_rectangle.y,
+					tree_rectangle.width,
+					tree_rectangle.height);
+		  else 
+		    gdk_draw_rectangle (clist->clist_window, bg_gc, TRUE,
+					tc_rectangle.x,
+					tc_rectangle.y,
+					tc_rectangle.width,
+					tc_rectangle.height);
+		}
+	      if (next_level > GTK_CTREE_ROW (node)->level)
+		gdk_draw_line (clist->clist_window, ctree->lines_gc,
+			       xcenter, crect->y,
+			       xcenter, crect->y + crect->height);
+	      else
+		{
+		  gint width;
+
+		  offset_x = MIN (ctree->tree_indent, 2 * TAB_SIZE);
+		  width = offset_x / 2 + offset_x % 2;
+
+		  parent = GTK_CTREE_ROW (node)->parent;
+
+		  tree_rectangle.y = ycenter;
+		  tree_rectangle.height = (cell_rectangle->y - ycenter +
+					   cell_rectangle->height);
+
+		  if (justify_right)
+		    {
+		      tree_rectangle.x = MAX(xcenter + 1 - width, column_left);
+		      tree_rectangle.width = MIN (xcenter + 1 - column_left,
+						  width);
+		    }
+		  else
+		    {
+		      tree_rectangle.x = xcenter;
+		      tree_rectangle.width = MIN (column_right - xcenter,
+						  width);
+		    }
+
+		  if (!area ||
+		      gdk_rectangle_intersect (area, &tree_rectangle,
+					       &tc_rectangle))
+		    {
+		      if (parent)
+			{
+			  get_cell_style (clist, &GTK_CTREE_ROW (parent)->row,
+					  state, column, NULL, NULL, &bg_gc);
+			  if (bg_gc == clist->bg_gc)
+			    gdk_gc_set_foreground
+			      (clist->bg_gc,
+			       &GTK_CTREE_ROW (parent)->row.background);
+			}
+		      else if (state == GTK_STATE_SELECTED)
+			bg_gc = style->base_gc[state];
+		      else
+			bg_gc = GTK_WIDGET (clist)->style->base_gc[state];
+
+		      if (!area)
+			gdk_draw_rectangle (clist->clist_window, bg_gc, TRUE,
+					    tree_rectangle.x,
+					    tree_rectangle.y,
+					    tree_rectangle.width,
+					    tree_rectangle.height);
+		      else
+			gdk_draw_rectangle (clist->clist_window,
+					    bg_gc, TRUE,
+					    tc_rectangle.x,
+					    tc_rectangle.y,
+					    tc_rectangle.width,
+					    tc_rectangle.height);
+		    }
+
+		  get_cell_style (clist, &GTK_CTREE_ROW (node)->row,
+				  state, column, NULL, NULL, &bg_gc);
+		  if (bg_gc == clist->bg_gc)
+		    gdk_gc_set_foreground
+		      (clist->bg_gc, &GTK_CTREE_ROW (node)->row.background);
+
+		  gdk_gc_set_clip_rectangle (bg_gc, crect);
+		  gdk_draw_arc (clist->clist_window, bg_gc, TRUE,
+				xcenter - (justify_right * offset_x),
+				cell_rectangle->y,
+				offset_x, clist->row_height,
+				(180 + (justify_right * 90)) * 64, 90 * 64);
+		  gdk_gc_set_clip_rectangle (bg_gc, NULL);
+
+		  gdk_draw_line (clist->clist_window, ctree->lines_gc, 
+				 xcenter, cell_rectangle->y, xcenter, ycenter);
+
+		  if (justify_right)
+		    gdk_draw_arc (clist->clist_window, ctree->lines_gc, FALSE,
+				  xcenter - offset_x, cell_rectangle->y,
+				  offset_x, clist->row_height,
+				  270 * 64, 90 * 64);
+		  else
+		    gdk_draw_arc (clist->clist_window, ctree->lines_gc, FALSE,
+				  xcenter, cell_rectangle->y,
+				  offset_x, clist->row_height,
+				  180 * 64, 90 * 64);
+		}
+	      node = GTK_CTREE_ROW (node)->parent;
+	    }
+	}
+
+      if (state != GTK_STATE_SELECTED)
+	{
+	  tree_rectangle.y = clip_rectangle->y;
+	  tree_rectangle.height = clip_rectangle->height;
+	  tree_rectangle.width = COLUMN_INSET + CELL_SPACING +
+	    MIN (clist->column[ctree->tree_column].area.width + COLUMN_INSET,
+		 TAB_SIZE);
+
+	  if (justify_right)
+	    tree_rectangle.x = MAX (xcenter + 1, column_left);
+	  else
+	    tree_rectangle.x = column_left;
+
+	  if (!area)
+	    gdk_draw_rectangle (clist->clist_window,
+				GTK_WIDGET
+				(ctree)->style->base_gc[GTK_STATE_NORMAL],
+				TRUE,
+				tree_rectangle.x,
+				tree_rectangle.y,
+				tree_rectangle.width,
+				tree_rectangle.height);
+	  else if (gdk_rectangle_intersect (area, &tree_rectangle,
+					    &tc_rectangle))
+	    gdk_draw_rectangle (clist->clist_window,
+				GTK_WIDGET
+				(ctree)->style->base_gc[GTK_STATE_NORMAL],
+				TRUE,
+				tc_rectangle.x,
+				tc_rectangle.y,
+				tc_rectangle.width,
+				tc_rectangle.height);
+	}
+
+      xcenter = offset + (justification_factor * ctree->tree_indent / 2);
+
+      get_cell_style (clist, &ctree_row->row, state, column, NULL, NULL,
+		      &bg_gc);
+      if (bg_gc == clist->bg_gc)
+	gdk_gc_set_foreground (clist->bg_gc, &ctree_row->row.background);
+
+      gdk_gc_set_clip_rectangle (bg_gc, crect);
+      if (ctree_row->is_leaf)
+	{
+	  GdkPoint points[6];
+
+	  points[0].x = offset + justification_factor * TAB_SIZE;
+	  points[0].y = cell_rectangle->y;
+
+	  points[1].x = points[0].x - justification_factor * 4;
+	  points[1].y = points[0].y;
+
+	  points[2].x = points[1].x - justification_factor * 2;
+	  points[2].y = points[1].y + 3;
+
+	  points[3].x = points[2].x;
+	  points[3].y = points[2].y + clist->row_height - 5;
+
+	  points[4].x = points[3].x + justification_factor * 2;
+	  points[4].y = points[3].y + 3;
+
+	  points[5].x = points[4].x + justification_factor * 4;
+	  points[5].y = points[4].y;
+
+	  gdk_draw_polygon (clist->clist_window, bg_gc, TRUE, points, 6);
+	  gdk_draw_lines (clist->clist_window, ctree->lines_gc, points, 6);
+	}
+      else 
+	{
+	  gdk_draw_arc (clist->clist_window, bg_gc, TRUE,
+			offset - (justify_right * 2 * TAB_SIZE),
+			cell_rectangle->y,
+			2 * TAB_SIZE, clist->row_height,
+			(90 + (180 * justify_right)) * 64, 180 * 64);
+	  gdk_draw_arc (clist->clist_window, ctree->lines_gc, FALSE,
+			offset - (justify_right * 2 * TAB_SIZE),
+			cell_rectangle->y,
+			2 * TAB_SIZE, clist->row_height,
+			(90 + (180 * justify_right)) * 64, 180 * 64);
+	}
+      gdk_gc_set_clip_rectangle (bg_gc, NULL);
+      gdk_gc_set_clip_rectangle (ctree->lines_gc, NULL);
+
+      offset += justification_factor * 3;
+      break;
+    default:
+      xcenter = offset + justification_factor * PM_SIZE / 2;
+
+      if (area)
+	{
+	  tree_rectangle.y = crect->y;
+	  tree_rectangle.height = crect->height;
+
+	  if (justify_right)
+	    {
+	      tree_rectangle.x = xcenter - PM_SIZE / 2 - 2;
+	      tree_rectangle.width = (clip_rectangle->x +
+				      clip_rectangle->width -tree_rectangle.x);
+	    }
+	  else
+	    {
+	      tree_rectangle.x = clip_rectangle->x + PM_SIZE / 2;
+	      tree_rectangle.width = (xcenter + PM_SIZE / 2 + 2 -
+				      clip_rectangle->x);
+	    }
+
+	  if (!gdk_rectangle_intersect (area, &tree_rectangle, &tc_rectangle))
+	    break;
+	}
+
+      offset_x = 1;
+      offset_y = 0;
+      if (ctree->line_style == GTK_CTREE_LINES_DOTTED)
+	{
+	  offset_x += abs((clip_rectangle->x + clist->hoffset) % 2);
+	  offset_y  = abs((cell_rectangle->y + clist->voffset) % 2);
+	}
+
+      clip_rectangle->y--;
+      clip_rectangle->height++;
+      gdk_gc_set_clip_rectangle (ctree->lines_gc, clip_rectangle);
+      gdk_draw_line (clist->clist_window, ctree->lines_gc,
+		     xcenter,
+		     (ctree->show_stub || clist->row_list->data != ctree_row) ?
+		     cell_rectangle->y + offset_y : ycenter,
+		     xcenter,
+		     (ctree_row->sibling) ? crect->y +crect->height : ycenter);
+
+      gdk_draw_line (clist->clist_window, ctree->lines_gc,
+		     xcenter + (justification_factor * offset_x), ycenter,
+		     xcenter + (justification_factor * (PM_SIZE / 2 + 2)),
+		     ycenter);
+
+      node = ctree_row->parent;
+      while (node)
+	{
+	  xcenter -= (justification_factor * ctree->tree_indent);
+
+	  if (GTK_CTREE_ROW (node)->sibling)
+	    gdk_draw_line (clist->clist_window, ctree->lines_gc, 
+			   xcenter, cell_rectangle->y + offset_y,
+			   xcenter, crect->y + crect->height);
+	  node = GTK_CTREE_ROW (node)->parent;
+	}
+      gdk_gc_set_clip_rectangle (ctree->lines_gc, NULL);
+      clip_rectangle->y++;
+      clip_rectangle->height--;
+      break;
+    }
+  return offset;
+}
+
+static void
+draw_row (GtkCList     *clist,
+	  GdkRectangle *area,
+	  gint          row,
+	  GtkCListRow  *clist_row)
+{
+  GtkWidget *widget;
+  GtkCTree  *ctree;
+  GdkRectangle *rect;
+  GdkRectangle *crect;
+  GdkRectangle row_rectangle;
+  GdkRectangle cell_rectangle; 
+  GdkRectangle clip_rectangle;
+  GdkRectangle intersect_rectangle;
+  gint last_column;
+  gint column_left = 0;
+  gint column_right = 0;
+  gint offset = 0;
+  gint state;
+  gint i;
+
+  g_return_if_fail (clist != NULL);
+
+  /* bail now if we arn't drawable yet */
+  if (!GTK_WIDGET_DRAWABLE (clist) || row < 0 || row >= clist->rows)
+    return;
+
+  widget = GTK_WIDGET (clist);
+  ctree  = GTK_CTREE  (clist);
+
+  /* if the function is passed the pointer to the row instead of null,
+   * it avoids this expensive lookup */
+  if (!clist_row)
+    clist_row = (g_list_nth (clist->row_list, row))->data;
+
+  /* rectangle of the entire row */
+  row_rectangle.x = 0;
+  row_rectangle.y = ROW_TOP_YPIXEL (clist, row);
+  row_rectangle.width = clist->clist_window_width;
+  row_rectangle.height = clist->row_height;
+
+  /* rectangle of the cell spacing above the row */
+  cell_rectangle.x = 0;
+  cell_rectangle.y = row_rectangle.y - CELL_SPACING;
+  cell_rectangle.width = row_rectangle.width;
+  cell_rectangle.height = CELL_SPACING;
+
+  /* rectangle used to clip drawing operations, its y and height
+   * positions only need to be set once, so we set them once here. 
+   * the x and width are set withing the drawing loop below once per
+   * column */
+  clip_rectangle.y = row_rectangle.y;
+  clip_rectangle.height = row_rectangle.height;
+
+  if (clist_row->state == GTK_STATE_NORMAL)
+    {
+      if (clist_row->fg_set)
+	gdk_gc_set_foreground (clist->fg_gc, &clist_row->foreground);
+      if (clist_row->bg_set)
+	gdk_gc_set_foreground (clist->bg_gc, &clist_row->background);
+    }
+  
+  state = clist_row->state;
+
+  gdk_gc_set_foreground (ctree->lines_gc,
+			 &widget->style->fg[clist_row->state]);
+
+  /* draw the cell borders */
+  if (area)
+    {
+      rect = &intersect_rectangle;
+      crect = &intersect_rectangle;
+
+      if (gdk_rectangle_intersect (area, &cell_rectangle, crect))
+	gdk_draw_rectangle (clist->clist_window,
+			    widget->style->base_gc[GTK_STATE_ACTIVE], TRUE,
+			    crect->x, crect->y, crect->width, crect->height);
+    }
+  else
+    {
+      rect = &clip_rectangle;
+      crect = &cell_rectangle;
+
+      gdk_draw_rectangle (clist->clist_window,
+			  widget->style->base_gc[GTK_STATE_ACTIVE], TRUE,
+			  crect->x, crect->y, crect->width, crect->height);
+    }
+
+  /* horizontal black lines */
+  if (ctree->line_style == GTK_CTREE_LINES_TABBED)
+    { 
+
+      column_right = (COLUMN_LEFT_XPIXEL (clist, ctree->tree_column) +
+		      clist->column[ctree->tree_column].area.width +
+		      COLUMN_INSET);
+      column_left = (COLUMN_LEFT_XPIXEL (clist, ctree->tree_column) -
+		     COLUMN_INSET - (ctree->tree_column != 0) * CELL_SPACING);
+
+      switch (clist->column[ctree->tree_column].justification)
+	{
+	case GTK_JUSTIFY_CENTER:
+	case GTK_JUSTIFY_FILL:
+	case GTK_JUSTIFY_LEFT:
+	  offset = (column_left + ctree->tree_indent *
+		    (((GtkCTreeRow *)clist_row)->level - 1));
+
+	  gdk_draw_line (clist->clist_window, ctree->lines_gc, 
+			 MIN (offset + TAB_SIZE, column_right),
+			 cell_rectangle.y,
+			 clist->clist_window_width, cell_rectangle.y);
+	  break;
+	case GTK_JUSTIFY_RIGHT:
+	  offset = (column_right - 1 - ctree->tree_indent *
+		    (((GtkCTreeRow *)clist_row)->level - 1));
+
+	  gdk_draw_line (clist->clist_window, ctree->lines_gc,
+			 -1, cell_rectangle.y,
+			 MAX (offset - TAB_SIZE, column_left),
+			 cell_rectangle.y);
+	  break;
+	}
+    }
+
+  /* the last row has to clear its bottom cell spacing too */
+  if (clist_row == clist->row_list_end->data)
+    {
+      cell_rectangle.y += clist->row_height + CELL_SPACING;
+
+      if (!area || gdk_rectangle_intersect (area, &cell_rectangle, crect))
+	{
+	  gdk_draw_rectangle (clist->clist_window,
+			      widget->style->base_gc[GTK_STATE_ACTIVE], TRUE,
+			      crect->x, crect->y, crect->width, crect->height);
+
+	  /* horizontal black lines */
+	  if (ctree->line_style == GTK_CTREE_LINES_TABBED)
+	    { 
+	      switch (clist->column[ctree->tree_column].justification)
+		{
+		case GTK_JUSTIFY_CENTER:
+		case GTK_JUSTIFY_FILL:
+		case GTK_JUSTIFY_LEFT:
+		  gdk_draw_line (clist->clist_window, ctree->lines_gc, 
+				 MIN (column_left + TAB_SIZE + COLUMN_INSET +
+				      (((GtkCTreeRow *)clist_row)->level > 1) *
+				      MIN (ctree->tree_indent / 2, TAB_SIZE),
+				      column_right),
+				 cell_rectangle.y,
+				 clist->clist_window_width, cell_rectangle.y);
+		  break;
+		case GTK_JUSTIFY_RIGHT:
+		  gdk_draw_line (clist->clist_window, ctree->lines_gc, 
+				 -1, cell_rectangle.y,
+				 MAX (column_right - TAB_SIZE - 1 -
+				      COLUMN_INSET -
+				      (((GtkCTreeRow *)clist_row)->level > 1) *
+				      MIN (ctree->tree_indent / 2, TAB_SIZE),
+				      column_left - 1), cell_rectangle.y);
+		  break;
+		}
+	    }
+	}
+    }	  
+
+  for (last_column = clist->columns - 1;
+       last_column >= 0 && !clist->column[last_column].visible; last_column--)
+    ;
+
+  /* iterate and draw all the columns (row cells) and draw their contents */
+  for (i = 0; i < clist->columns; i++)
+    {
+      GtkStyle *style;
+      GdkGC *fg_gc; 
+      GdkGC *bg_gc;
+
+      gint width;
+      gint height;
+      gint pixmap_width;
+      gint string_width;
+      gint old_offset;
+      gint row_center_offset;
+
+      if (!clist->column[i].visible)
+	continue;
+
+      get_cell_style (clist, clist_row, state, i, &style, &fg_gc, &bg_gc);
+
+      /* calculate clipping region */
+      clip_rectangle.x = clist->column[i].area.x + clist->hoffset;
+      clip_rectangle.width = clist->column[i].area.width;
+
+      cell_rectangle.x = clip_rectangle.x - COLUMN_INSET - CELL_SPACING;
+      cell_rectangle.width = (clip_rectangle.width + 2 * COLUMN_INSET +
+			      (1 + (i == last_column)) * CELL_SPACING);
+      cell_rectangle.y = clip_rectangle.y;
+      cell_rectangle.height = clip_rectangle.height;
+
+      string_width = 0;
+      pixmap_width = 0;
+
+      if (area && !gdk_rectangle_intersect (area, &cell_rectangle,
+					    &intersect_rectangle))
+	{
+	  if (i != ctree->tree_column)
+	    continue;
+	}
+      else
+	{
+	  gdk_draw_rectangle (clist->clist_window, bg_gc, TRUE,
+			      crect->x, crect->y, crect->width, crect->height);
+
+	  /* calculate real width for column justification */
+	  switch (clist_row->cell[i].type)
+	    {
+	    case GTK_CELL_TEXT:
+	      width = gdk_string_width
+		(style->font, GTK_CELL_TEXT (clist_row->cell[i])->text);
+	      break;
+	    case GTK_CELL_PIXMAP:
+	      gdk_window_get_size
+		(GTK_CELL_PIXMAP (clist_row->cell[i])->pixmap, &pixmap_width,
+		 &height);
+	      width = pixmap_width;
+	      break;
+	    case GTK_CELL_PIXTEXT:
+	      if (GTK_CELL_PIXTEXT (clist_row->cell[i])->pixmap)
+		gdk_window_get_size
+		  (GTK_CELL_PIXTEXT (clist_row->cell[i])->pixmap,
+		   &pixmap_width, &height);
+
+	      width = pixmap_width;
+
+	      if (GTK_CELL_PIXTEXT (clist_row->cell[i])->text)
+		{
+		  string_width = gdk_string_width
+		    (style->font, GTK_CELL_PIXTEXT (clist_row->cell[i])->text);
+		  width += string_width;
+		}
+
+	      if (GTK_CELL_PIXTEXT (clist_row->cell[i])->text &&
+		  GTK_CELL_PIXTEXT (clist_row->cell[i])->pixmap)
+		width +=  GTK_CELL_PIXTEXT (clist_row->cell[i])->spacing;
+
+	      if (i == ctree->tree_column)
+		width += (ctree->tree_indent *
+			  ((GtkCTreeRow *)clist_row)->level);
+	      break;
+	    default:
+	      continue;
+	      break;
+	    }
+
+	  switch (clist->column[i].justification)
+	    {
+	    case GTK_JUSTIFY_LEFT:
+	      offset = clip_rectangle.x + clist_row->cell[i].horizontal;
+	      break;
+	    case GTK_JUSTIFY_RIGHT:
+	      offset = (clip_rectangle.x + clist_row->cell[i].horizontal +
+			clip_rectangle.width - width);
+	      break;
+	    case GTK_JUSTIFY_CENTER:
+	    case GTK_JUSTIFY_FILL:
+	      offset = (clip_rectangle.x + clist_row->cell[i].horizontal +
+			(clip_rectangle.width / 2) - (width / 2));
+	      break;
+	    };
+
+	  if (i != ctree->tree_column)
+	    {
+	      offset += clist_row->cell[i].horizontal;
+	      switch (clist_row->cell[i].type)
+		{
+		case GTK_CELL_PIXMAP:
+		  draw_cell_pixmap
+		    (clist->clist_window, &clip_rectangle, fg_gc,
+		     GTK_CELL_PIXMAP (clist_row->cell[i])->pixmap,
+		     GTK_CELL_PIXMAP (clist_row->cell[i])->mask,
+		     offset,
+		     clip_rectangle.y + clist_row->cell[i].vertical +
+		     (clip_rectangle.height - height) / 2,
+		     pixmap_width, height);
+		  break;
+		case GTK_CELL_PIXTEXT:
+		  offset = draw_cell_pixmap
+		    (clist->clist_window, &clip_rectangle, fg_gc,
+		     GTK_CELL_PIXTEXT (clist_row->cell[i])->pixmap,
+		     GTK_CELL_PIXTEXT (clist_row->cell[i])->mask,
+		     offset,
+		     clip_rectangle.y + clist_row->cell[i].vertical +
+		     (clip_rectangle.height - height) / 2,
+		     pixmap_width, height);
+		  offset += GTK_CELL_PIXTEXT (clist_row->cell[i])->spacing;
+		case GTK_CELL_TEXT:
+		  if (style != GTK_WIDGET (clist)->style)
+		    row_center_offset = (((clist->row_height -
+					   style->font->ascent -
+					   style->font->descent - 1) / 2) +
+					 1.5 + style->font->ascent);
+		  else
+		    row_center_offset = clist->row_center_offset;
+
+		  gdk_gc_set_clip_rectangle (fg_gc, &clip_rectangle);
+		  gdk_draw_string
+		    (clist->clist_window, style->font, fg_gc,
+		     offset,
+		     row_rectangle.y + row_center_offset +
+		     clist_row->cell[i].vertical,
+		     (clist_row->cell[i].type == GTK_CELL_PIXTEXT) ?
+		     GTK_CELL_PIXTEXT (clist_row->cell[i])->text :
+		     GTK_CELL_TEXT (clist_row->cell[i])->text);
+		  gdk_gc_set_clip_rectangle (fg_gc, NULL);
+		  break;
+		default:
+		  break;
+		}
+	      continue;
+	    }
+	}
+
+      if (bg_gc == clist->bg_gc)
+	gdk_gc_set_background (ctree->lines_gc, &clist_row->background);
+
+      /* draw ctree->tree_column */
+      cell_rectangle.y -= CELL_SPACING;
+      cell_rectangle.height += CELL_SPACING;
+
+      if (area && !gdk_rectangle_intersect (area, &cell_rectangle,
+					    &intersect_rectangle))
+	continue;
+
+      /* draw lines */
+      offset = gtk_ctree_draw_lines (ctree, (GtkCTreeRow *)clist_row, row, i,
+				     state, &clip_rectangle, &cell_rectangle,
+				     crect, area, style);
+
+      /* draw expander */
+      offset = gtk_ctree_draw_expander (ctree, (GtkCTreeRow *)clist_row,
+					style, &clip_rectangle, offset);
+
+      if (clist->column[i].justification == GTK_JUSTIFY_RIGHT)
+	offset -= ctree->tree_spacing;
+      else
+	offset += ctree->tree_spacing;
+
+      if (clist->column[i].justification == GTK_JUSTIFY_RIGHT)
+	offset -= (pixmap_width + clist_row->cell[i].horizontal);
+      else
+	offset += clist_row->cell[i].horizontal;
+
+      old_offset = offset;
+      offset = draw_cell_pixmap (clist->clist_window, &clip_rectangle, fg_gc,
+				 GTK_CELL_PIXTEXT (clist_row->cell[i])->pixmap,
+				 GTK_CELL_PIXTEXT (clist_row->cell[i])->mask,
+				 offset, 
+				 clip_rectangle.y + clist_row->cell[i].vertical
+				 + (clip_rectangle.height - height) / 2,
+				 pixmap_width, height);
+
+      if (string_width)
+	{ 
+	  if (clist->column[i].justification == GTK_JUSTIFY_RIGHT)
+	    {
+	      offset = (old_offset - string_width);
+	      if (GTK_CELL_PIXTEXT (clist_row->cell[i])->pixmap)
+		offset -= GTK_CELL_PIXTEXT (clist_row->cell[i])->spacing;
+	    }
+	  else
+	    {
+	      if (GTK_CELL_PIXTEXT (clist_row->cell[i])->pixmap)
+		offset += GTK_CELL_PIXTEXT (clist_row->cell[i])->spacing;
+	    }
+
+	  if (style != GTK_WIDGET (clist)->style)
+	    row_center_offset = (((clist->row_height - style->font->ascent -
+				   style->font->descent - 1) / 2) +
+				 1.5 + style->font->ascent);
+	  else
+	    row_center_offset = clist->row_center_offset;
+	  
+	  gdk_gc_set_clip_rectangle (fg_gc, &clip_rectangle);
+	  gdk_draw_string (clist->clist_window, style->font, fg_gc, offset,
+			   row_rectangle.y + row_center_offset +
+			   clist_row->cell[i].vertical,
+			   GTK_CELL_PIXTEXT (clist_row->cell[i])->text);
+	}
+      gdk_gc_set_clip_rectangle (fg_gc, NULL);
+    }
+
+  /* draw focus rectangle */
+  if (clist->focus_row == row &&
+      GTK_WIDGET_CAN_FOCUS (widget) && GTK_WIDGET_HAS_FOCUS (widget))
+    {
+      if (!area)
+	gdk_draw_rectangle (clist->clist_window, clist->xor_gc, FALSE,
+			    row_rectangle.x, row_rectangle.y,
+			    row_rectangle.width - 1, row_rectangle.height - 1);
+      else if (gdk_rectangle_intersect (area, &row_rectangle,
+					&intersect_rectangle))
+	{
+	  gdk_gc_set_clip_rectangle (clist->xor_gc, &intersect_rectangle);
+	  gdk_draw_rectangle (clist->clist_window, clist->xor_gc, FALSE,
+			      row_rectangle.x, row_rectangle.y,
+			      row_rectangle.width - 1,
+			      row_rectangle.height - 1);
+	  gdk_gc_set_clip_rectangle (clist->xor_gc, NULL);
+	}
+    }
+}
+
+static void
+tree_draw_node (GtkCTree     *ctree, 
+	        GtkCTreeNode *node)
+{
+  GtkCList *clist;
+  
+  clist = GTK_CLIST (ctree);
+
+  if (CLIST_UNFROZEN (clist) && gtk_ctree_is_viewable (ctree, node))
+    {
+      GtkCTreeNode *work;
+      gint num = 0;
+      
+      work = GTK_CTREE_NODE (clist->row_list);
+      while (work && work != node)
+	{
+	  work = GTK_CTREE_NODE_NEXT (work);
+	  num++;
+	}
+      if (work && gtk_clist_row_is_visible (clist, num) != GTK_VISIBILITY_NONE)
+	GTK_CLIST_CLASS_FW (clist)->draw_row
+	  (clist, NULL, num, GTK_CLIST_ROW ((GList *) node));
+    }
+}
+
+static GtkCTreeNode *
+gtk_ctree_last_visible (GtkCTree     *ctree,
+			GtkCTreeNode *node)
+{
+  GtkCTreeNode *work;
+  
+  if (!node)
+    return NULL;
+
+  work = GTK_CTREE_ROW (node)->children;
+
+  if (!work || !GTK_CTREE_ROW (node)->expanded)
+    return node;
+
+  while (GTK_CTREE_ROW (work)->sibling)
+    work = GTK_CTREE_ROW (work)->sibling;
+
+  return gtk_ctree_last_visible (ctree, work);
+}
+
+static void
+gtk_ctree_link (GtkCTree     *ctree,
+		GtkCTreeNode *node,
+		GtkCTreeNode *parent,
+		GtkCTreeNode *sibling,
+		gboolean      update_focus_row)
+{
+  GtkCList *clist;
+  GList *list_end;
+  GList *list;
+  GList *work;
+  gboolean visible = FALSE;
+  gint rows = 0;
+  
+  if (sibling)
+    g_return_if_fail (GTK_CTREE_ROW (sibling)->parent == parent);
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (node != sibling);
+  g_return_if_fail (node != parent);
+
+  clist = GTK_CLIST (ctree);
+
+  if (update_focus_row && clist->selection_mode == GTK_SELECTION_EXTENDED)
+    {
+      GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+      
+      g_list_free (clist->undo_selection);
+      g_list_free (clist->undo_unselection);
+      clist->undo_selection = NULL;
+      clist->undo_unselection = NULL;
+    }
+
+  for (rows = 1, list_end = (GList *)node; list_end->next;
+       list_end = list_end->next)
+    rows++;
+
+  GTK_CTREE_ROW (node)->parent = parent;
+  GTK_CTREE_ROW (node)->sibling = sibling;
+
+  if (!parent || (parent && (gtk_ctree_is_viewable (ctree, parent) &&
+			     GTK_CTREE_ROW (parent)->expanded)))
+    {
+      visible = TRUE;
+      clist->rows += rows;
+    }
+
+  if (parent)
+    work = (GList *)(GTK_CTREE_ROW (parent)->children);
+  else
+    work = clist->row_list;
+
+  if (sibling)
+    {
+      if (work != (GList *)sibling)
+	{
+	  while (GTK_CTREE_ROW (work)->sibling != sibling)
+	    work = (GList *)(GTK_CTREE_ROW (work)->sibling);
+	  GTK_CTREE_ROW (work)->sibling = node;
+	}
+
+      if (sibling == GTK_CTREE_NODE (clist->row_list))
+	clist->row_list = (GList *) node;
+      if (GTK_CTREE_NODE_PREV (sibling) &&
+	  GTK_CTREE_NODE_NEXT (GTK_CTREE_NODE_PREV (sibling)) == sibling)
+	{
+	  list = (GList *)GTK_CTREE_NODE_PREV (sibling);
+	  list->next = (GList *)node;
+	}
+      
+      list = (GList *)node;
+      list->prev = (GList *)GTK_CTREE_NODE_PREV (sibling);
+      list_end->next = (GList *)sibling;
+      list = (GList *)sibling;
+      list->prev = list_end;
+      if (parent && GTK_CTREE_ROW (parent)->children == sibling)
+	GTK_CTREE_ROW (parent)->children = node;
+    }
+  else
+    {
+      if (work)
+	{
+	  /* find sibling */
+	  while (GTK_CTREE_ROW (work)->sibling)
+	    work = (GList *)(GTK_CTREE_ROW (work)->sibling);
+	  GTK_CTREE_ROW (work)->sibling = node;
+	  
+	  /* find last visible child of sibling */
+	  work = (GList *) gtk_ctree_last_visible (ctree,
+						   GTK_CTREE_NODE (work));
+	  
+	  list_end->next = work->next;
+	  if (work->next)
+	    list = work->next->prev = list_end;
+	  work->next = (GList *)node;
+	  list = (GList *)node;
+	  list->prev = work;
+	}
+      else
+	{
+	  if (parent)
+	    {
+	      GTK_CTREE_ROW (parent)->children = node;
+	      list = (GList *)node;
+	      list->prev = (GList *)parent;
+	      if (GTK_CTREE_ROW (parent)->expanded)
+		{
+		  list_end->next = (GList *)GTK_CTREE_NODE_NEXT (parent);
+		  if (GTK_CTREE_NODE_NEXT(parent))
+		    {
+		      list = (GList *)GTK_CTREE_NODE_NEXT (parent);
+		      list->prev = list_end;
+		    }
+		  list = (GList *)parent;
+		  list->next = (GList *)node;
+		}
+	      else
+		list_end->next = NULL;
+	    }
+	  else
+	    {
+	      clist->row_list = (GList *)node;
+	      list = (GList *)node;
+	      list->prev = NULL;
+	      list_end->next = NULL;
+	    }
+	}
+    }
+
+  gtk_ctree_pre_recursive (ctree, node, tree_update_level, NULL); 
+
+  if (clist->row_list_end == NULL ||
+      clist->row_list_end->next == (GList *)node)
+    clist->row_list_end = list_end;
+
+  if (visible && update_focus_row)
+    {
+      gint pos;
+	  
+      pos = g_list_position (clist->row_list, (GList *)node);
+  
+      if (pos <= clist->focus_row)
+	{
+	  clist->focus_row += rows;
+	  clist->undo_anchor = clist->focus_row;
+	}
+    }
+}
+
+static void
+gtk_ctree_unlink (GtkCTree     *ctree, 
+		  GtkCTreeNode *node,
+                  gboolean      update_focus_row)
+{
+  GtkCList *clist;
+  gint rows;
+  gint level;
+  gint visible;
+  GtkCTreeNode *work;
+  GtkCTreeNode *parent;
+  GList *list;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  clist = GTK_CLIST (ctree);
+  
+  if (update_focus_row && clist->selection_mode == GTK_SELECTION_EXTENDED)
+    {
+      GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+      
+      g_list_free (clist->undo_selection);
+      g_list_free (clist->undo_unselection);
+      clist->undo_selection = NULL;
+      clist->undo_unselection = NULL;
+    }
+
+  visible = gtk_ctree_is_viewable (ctree, node);
+
+  /* clist->row_list_end unlinked ? */
+  if (visible &&
+      (GTK_CTREE_NODE_NEXT (node) == NULL ||
+       (GTK_CTREE_ROW (node)->children &&
+	gtk_ctree_is_ancestor (ctree, node,
+			       GTK_CTREE_NODE (clist->row_list_end)))))
+    clist->row_list_end = (GList *) (GTK_CTREE_NODE_PREV (node));
+
+  /* update list */
+  rows = 0;
+  level = GTK_CTREE_ROW (node)->level;
+  work = GTK_CTREE_NODE_NEXT (node);
+  while (work && GTK_CTREE_ROW (work)->level > level)
+    {
+      work = GTK_CTREE_NODE_NEXT (work);
+      rows++;
+    }
+
+  if (visible)
+    {
+      clist->rows -= (rows + 1);
+
+      if (update_focus_row)
+	{
+	  gint pos;
+	  
+	  pos = g_list_position (clist->row_list, (GList *)node);
+	  if (pos + rows < clist->focus_row)
+	    clist->focus_row -= (rows + 1);
+	  else if (pos <= clist->focus_row)
+	    {
+	      if (!GTK_CTREE_ROW (node)->sibling)
+		clist->focus_row = MAX (pos - 1, 0);
+	      else
+		clist->focus_row = pos;
+	      
+	      clist->focus_row = MIN (clist->focus_row, clist->rows - 1);
+	    }
+	  clist->undo_anchor = clist->focus_row;
+	}
+    }
+
+  if (work)
+    {
+      list = (GList *)GTK_CTREE_NODE_PREV (work);
+      list->next = NULL;
+      list = (GList *)work;
+      list->prev = (GList *)GTK_CTREE_NODE_PREV (node);
+    }
+
+  if (GTK_CTREE_NODE_PREV (node) &&
+      GTK_CTREE_NODE_NEXT (GTK_CTREE_NODE_PREV (node)) == node)
+    {
+      list = (GList *)GTK_CTREE_NODE_PREV (node);
+      list->next = (GList *)work;
+    }
+
+  /* update tree */
+  parent = GTK_CTREE_ROW (node)->parent;
+  if (parent)
+    {
+      if (GTK_CTREE_ROW (parent)->children == node)
+	{
+	  GTK_CTREE_ROW (parent)->children = GTK_CTREE_ROW (node)->sibling;
+	  if (!GTK_CTREE_ROW (parent)->children)
+	    gtk_ctree_collapse (ctree, parent);
+	}
+      else
+	{
+	  GtkCTreeNode *sibling;
+
+	  sibling = GTK_CTREE_ROW (parent)->children;
+	  while (GTK_CTREE_ROW (sibling)->sibling != node)
+	    sibling = GTK_CTREE_ROW (sibling)->sibling;
+	  GTK_CTREE_ROW (sibling)->sibling = GTK_CTREE_ROW (node)->sibling;
+	}
+    }
+  else
+    {
+      if (clist->row_list == (GList *)node)
+	clist->row_list = (GList *) (GTK_CTREE_ROW (node)->sibling);
+      else
+	{
+	  GtkCTreeNode *sibling;
+
+	  sibling = GTK_CTREE_NODE (clist->row_list);
+	  while (GTK_CTREE_ROW (sibling)->sibling != node)
+	    sibling = GTK_CTREE_ROW (sibling)->sibling;
+	  GTK_CTREE_ROW (sibling)->sibling = GTK_CTREE_ROW (node)->sibling;
+	}
+    }
+}
+
+static void
+real_row_move (GtkCList *clist,
+	       gint      source_row,
+	       gint      dest_row)
+{
+  GtkCTree *ctree;
+  GtkCTreeNode *node;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+
+  if (GTK_CLIST_AUTO_SORT (clist))
+    return;
+
+  if (source_row < 0 || source_row >= clist->rows ||
+      dest_row   < 0 || dest_row   >= clist->rows ||
+      source_row == dest_row)
+    return;
+
+  ctree = GTK_CTREE (clist);
+  node = GTK_CTREE_NODE (g_list_nth (clist->row_list, source_row));
+
+  if (source_row < dest_row)
+    {
+      GtkCTreeNode *work; 
+
+      dest_row++;
+      work = GTK_CTREE_ROW (node)->children;
+
+      while (work && GTK_CTREE_ROW (work)->level > GTK_CTREE_ROW (node)->level)
+	{
+	  work = GTK_CTREE_NODE_NEXT (work);
+	  dest_row++;
+	}
+
+      if (dest_row > clist->rows)
+	dest_row = clist->rows;
+    }
+
+  if (dest_row < clist->rows)
+    {
+      GtkCTreeNode *sibling;
+
+      sibling = GTK_CTREE_NODE (g_list_nth (clist->row_list, dest_row));
+      gtk_ctree_move (ctree, node, GTK_CTREE_ROW (sibling)->parent, sibling);
+    }
+  else
+    gtk_ctree_move (ctree, node, NULL, NULL);
+}
+
+static void
+real_tree_move (GtkCTree     *ctree,
+		GtkCTreeNode *node,
+		GtkCTreeNode *new_parent, 
+		GtkCTreeNode *new_sibling)
+{
+  GtkCList *clist;
+  GtkCTreeNode *work;
+  gboolean visible = FALSE;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (!new_sibling || 
+		    GTK_CTREE_ROW (new_sibling)->parent == new_parent);
+
+  if (new_parent && GTK_CTREE_ROW (new_parent)->is_leaf)
+    return;
+
+  /* new_parent != child of child */
+  for (work = new_parent; work; work = GTK_CTREE_ROW (work)->parent)
+    if (work == node)
+      return;
+
+  clist = GTK_CLIST (ctree);
+
+  visible = gtk_ctree_is_viewable (ctree, node);
+
+  if (clist->selection_mode == GTK_SELECTION_EXTENDED)
+    {
+      GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+      
+      g_list_free (clist->undo_selection);
+      g_list_free (clist->undo_unselection);
+      clist->undo_selection = NULL;
+      clist->undo_unselection = NULL;
+    }
+
+  if (GTK_CLIST_AUTO_SORT (clist))
+    {
+      if (new_parent == GTK_CTREE_ROW (node)->parent)
+	return;
+      
+      if (new_parent)
+	new_sibling = GTK_CTREE_ROW (new_parent)->children;
+      else
+	new_sibling = GTK_CTREE_NODE (clist->row_list);
+
+      while (new_sibling && clist->compare
+	     (clist, GTK_CTREE_ROW (node), GTK_CTREE_ROW (new_sibling)) > 0)
+	new_sibling = GTK_CTREE_ROW (new_sibling)->sibling;
+    }
+
+  if (new_parent == GTK_CTREE_ROW (node)->parent && 
+      new_sibling == GTK_CTREE_ROW (node)->sibling)
+    return;
+
+  gtk_clist_freeze (clist);
+
+  work = NULL;
+  if (gtk_ctree_is_viewable (ctree, node))
+    work = GTK_CTREE_NODE (g_list_nth (clist->row_list, clist->focus_row));
+      
+  gtk_ctree_unlink (ctree, node, FALSE);
+  gtk_ctree_link (ctree, node, new_parent, new_sibling, FALSE);
+  
+  if (work)
+    {
+      while (work &&  !gtk_ctree_is_viewable (ctree, work))
+	work = GTK_CTREE_ROW (work)->parent;
+      clist->focus_row = g_list_position (clist->row_list, (GList *)work);
+      clist->undo_anchor = clist->focus_row;
+    }
+
+  if (clist->column[ctree->tree_column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist) &&
+      (visible || gtk_ctree_is_viewable (ctree, node)))
+    gtk_clist_set_column_width
+      (clist, ctree->tree_column,
+       gtk_clist_optimal_column_width (clist, ctree->tree_column));
+
+  gtk_clist_thaw (clist);
+}
+
+static void
+change_focus_row_expansion (GtkCTree          *ctree,
+			    GtkCTreeExpansionType action)
+{
+  GtkCList *clist;
+  GtkCTreeNode *node;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  clist = GTK_CLIST (ctree);
+
+  if (gdk_pointer_is_grabbed () && GTK_WIDGET_HAS_GRAB (ctree))
+    return;
+  
+  if (!(node =
+	GTK_CTREE_NODE (g_list_nth (clist->row_list, clist->focus_row))) ||
+      GTK_CTREE_ROW (node)->is_leaf || !(GTK_CTREE_ROW (node)->children))
+    return;
+
+  switch (action)
+    {
+    case GTK_CTREE_EXPANSION_EXPAND:
+      gtk_ctree_expand (ctree, node);
+      break;
+    case GTK_CTREE_EXPANSION_EXPAND_RECURSIVE:
+      gtk_ctree_expand_recursive (ctree, node);
+      break;
+    case GTK_CTREE_EXPANSION_COLLAPSE:
+      gtk_ctree_collapse (ctree, node);
+      break;
+    case GTK_CTREE_EXPANSION_COLLAPSE_RECURSIVE:
+      gtk_ctree_collapse_recursive (ctree, node);
+      break;
+    case GTK_CTREE_EXPANSION_TOGGLE:
+      gtk_ctree_toggle_expansion (ctree, node);
+      break;
+    case GTK_CTREE_EXPANSION_TOGGLE_RECURSIVE:
+      gtk_ctree_toggle_expansion_recursive (ctree, node);
+      break;
+    }
+}
+
+static void 
+real_tree_expand (GtkCTree     *ctree,
+		  GtkCTreeNode *node)
+{
+  GtkCList *clist;
+  GtkCTreeNode *work;
+  GtkRequisition requisition;
+  gboolean visible;
+  gint level;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  if (!node || GTK_CTREE_ROW (node)->expanded || GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  clist = GTK_CLIST (ctree);
+  
+  GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+
+  GTK_CTREE_ROW (node)->expanded = TRUE;
+  level = GTK_CTREE_ROW (node)->level;
+
+  visible = gtk_ctree_is_viewable (ctree, node);
+  /* get cell width if tree_column is auto resized */
+  if (visible && clist->column[ctree->tree_column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    GTK_CLIST_CLASS_FW (clist)->cell_size_request
+      (clist, &GTK_CTREE_ROW (node)->row, ctree->tree_column, &requisition);
+
+  /* unref/unset closed pixmap */
+  if (GTK_CELL_PIXTEXT 
+      (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap)
+    {
+      gdk_pixmap_unref
+	(GTK_CELL_PIXTEXT
+	 (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap);
+      
+      GTK_CELL_PIXTEXT
+	(GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap = NULL;
+      
+      if (GTK_CELL_PIXTEXT 
+	  (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask)
+	{
+	  gdk_pixmap_unref
+	    (GTK_CELL_PIXTEXT 
+	     (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask);
+	  GTK_CELL_PIXTEXT 
+	    (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask = NULL;
+	}
+    }
+
+  /* set/ref opened pixmap */
+  if (GTK_CTREE_ROW (node)->pixmap_opened)
+    {
+      GTK_CELL_PIXTEXT 
+	(GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap = 
+	gdk_pixmap_ref (GTK_CTREE_ROW (node)->pixmap_opened);
+
+      if (GTK_CTREE_ROW (node)->mask_opened) 
+	GTK_CELL_PIXTEXT 
+	  (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask = 
+	  gdk_pixmap_ref (GTK_CTREE_ROW (node)->mask_opened);
+    }
+
+
+  work = GTK_CTREE_ROW (node)->children;
+  if (work)
+    {
+      GList *list = (GList *)work;
+      gint *cell_width = NULL;
+      gint tmp = 0;
+      gint row;
+      gint i;
+      
+      if (visible && !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+	{
+	  cell_width = g_new0 (gint, clist->columns);
+	  if (clist->column[ctree->tree_column].auto_resize)
+	      cell_width[ctree->tree_column] = requisition.width;
+
+	  while (work)
+	    {
+	      /* search maximum cell widths of auto_resize columns */
+	      for (i = 0; i < clist->columns; i++)
+		if (clist->column[i].auto_resize)
+		  {
+		    GTK_CLIST_CLASS_FW (clist)->cell_size_request
+		      (clist, &GTK_CTREE_ROW (work)->row, i, &requisition);
+		    cell_width[i] = MAX (requisition.width, cell_width[i]);
+		  }
+
+	      list = (GList *)work;
+	      work = GTK_CTREE_NODE_NEXT (work);
+	      tmp++;
+	    }
+	}
+      else
+	while (work)
+	  {
+	    list = (GList *)work;
+	    work = GTK_CTREE_NODE_NEXT (work);
+	    tmp++;
+	  }
+
+      list->next = (GList *)GTK_CTREE_NODE_NEXT (node);
+
+      if (GTK_CTREE_NODE_NEXT (node))
+	{
+	  GList *tmp_list;
+
+	  tmp_list = (GList *)GTK_CTREE_NODE_NEXT (node);
+	  tmp_list->prev = list;
+	}
+      else
+	clist->row_list_end = list;
+
+      list = (GList *)node;
+      list->next = (GList *)(GTK_CTREE_ROW (node)->children);
+
+      if (visible)
+	{
+	  /* resize auto_resize columns if needed */
+	  for (i = 0; i < clist->columns; i++)
+	    if (clist->column[i].auto_resize &&
+		cell_width[i] > clist->column[i].width)
+	      gtk_clist_set_column_width (clist, i, cell_width[i]);
+	  g_free (cell_width);
+
+	  /* update focus_row position */
+	  row = g_list_position (clist->row_list, (GList *)node);
+	  if (row < clist->focus_row)
+	    clist->focus_row += tmp;
+
+	  clist->rows += tmp;
+	  CLIST_REFRESH (clist);
+	}
+    }
+  else if (visible && clist->column[ctree->tree_column].auto_resize)
+    /* resize tree_column if needed */
+    column_auto_resize (clist, &GTK_CTREE_ROW (node)->row, ctree->tree_column,
+			requisition.width);
+}
+
+static void 
+real_tree_collapse (GtkCTree     *ctree,
+		    GtkCTreeNode *node)
+{
+  GtkCList *clist;
+  GtkCTreeNode *work;
+  GtkRequisition requisition;
+  gboolean visible;
+  gint level;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  if (!node || !GTK_CTREE_ROW (node)->expanded ||
+      GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+  
+  GTK_CTREE_ROW (node)->expanded = FALSE;
+  level = GTK_CTREE_ROW (node)->level;
+
+  visible = gtk_ctree_is_viewable (ctree, node);
+  /* get cell width if tree_column is auto resized */
+  if (visible && clist->column[ctree->tree_column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    GTK_CLIST_CLASS_FW (clist)->cell_size_request
+      (clist, &GTK_CTREE_ROW (node)->row, ctree->tree_column, &requisition);
+
+  /* unref/unset opened pixmap */
+  if (GTK_CELL_PIXTEXT 
+      (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap)
+    {
+      gdk_pixmap_unref
+	(GTK_CELL_PIXTEXT
+	 (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap);
+      
+      GTK_CELL_PIXTEXT
+	(GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap = NULL;
+      
+      if (GTK_CELL_PIXTEXT 
+	  (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask)
+	{
+	  gdk_pixmap_unref
+	    (GTK_CELL_PIXTEXT 
+	     (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask);
+	  GTK_CELL_PIXTEXT 
+	    (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask = NULL;
+	}
+    }
+
+  /* set/ref closed pixmap */
+  if (GTK_CTREE_ROW (node)->pixmap_closed)
+    {
+      GTK_CELL_PIXTEXT 
+	(GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap = 
+	gdk_pixmap_ref (GTK_CTREE_ROW (node)->pixmap_closed);
+
+      if (GTK_CTREE_ROW (node)->mask_closed) 
+	GTK_CELL_PIXTEXT 
+	  (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask = 
+	  gdk_pixmap_ref (GTK_CTREE_ROW (node)->mask_closed);
+    }
+
+  work = GTK_CTREE_ROW (node)->children;
+  if (work)
+    {
+      gint tmp = 0;
+      gint row;
+      GList *list;
+
+      while (work && GTK_CTREE_ROW (work)->level > level)
+	{
+	  work = GTK_CTREE_NODE_NEXT (work);
+	  tmp++;
+	}
+
+      if (work)
+	{
+	  list = (GList *)node;
+	  list->next = (GList *)work;
+	  list = (GList *)GTK_CTREE_NODE_PREV (work);
+	  list->next = NULL;
+	  list = (GList *)work;
+	  list->prev = (GList *)node;
+	}
+      else
+	{
+	  list = (GList *)node;
+	  list->next = NULL;
+	  clist->row_list_end = (GList *)node;
+	}
+
+      if (visible)
+	{
+	  /* resize auto_resize columns if needed */
+	  auto_resize_columns (clist);
+
+	  row = g_list_position (clist->row_list, (GList *)node);
+	  if (row < clist->focus_row)
+	    clist->focus_row -= tmp;
+	  clist->rows -= tmp;
+	  CLIST_REFRESH (clist);
+	}
+    }
+  else if (visible && clist->column[ctree->tree_column].auto_resize &&
+	   !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    /* resize tree_column if needed */
+    column_auto_resize (clist, &GTK_CTREE_ROW (node)->row, ctree->tree_column,
+			requisition.width);
+    
+}
+
+static void
+column_auto_resize (GtkCList    *clist,
+		    GtkCListRow *clist_row,
+		    gint         column,
+		    gint         old_width)
+{
+  /* resize column if needed for auto_resize */
+  GtkRequisition requisition;
+
+  if (!clist->column[column].auto_resize ||
+      GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    return;
+
+  if (clist_row)
+    GTK_CLIST_CLASS_FW (clist)->cell_size_request (clist, clist_row,
+						   column, &requisition);
+  else
+    requisition.width = 0;
+
+  if (requisition.width > clist->column[column].width)
+    gtk_clist_set_column_width (clist, column, requisition.width);
+  else if (requisition.width < old_width &&
+	   old_width == clist->column[column].width)
+    {
+      GList *list;
+      gint new_width;
+
+      /* run a "gtk_clist_optimal_column_width" but break, if
+       * the column doesn't shrink */
+      if (GTK_CLIST_SHOW_TITLES (clist) && clist->column[column].button)
+	new_width = (clist->column[column].button->requisition.width -
+		     (CELL_SPACING + (2 * COLUMN_INSET)));
+      else
+	new_width = 0;
+
+      for (list = clist->row_list; list; list = list->next)
+	{
+	  GTK_CLIST_CLASS_FW (clist)->cell_size_request
+	    (clist, GTK_CLIST_ROW (list), column, &requisition);
+	  new_width = MAX (new_width, requisition.width);
+	  if (new_width == clist->column[column].width)
+	    break;
+	}
+      if (new_width < clist->column[column].width)
+	gtk_clist_set_column_width (clist, column, new_width);
+    }
+}
+
+static void
+auto_resize_columns (GtkCList *clist)
+{
+  gint i;
+
+  if (GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    return;
+
+  for (i = 0; i < clist->columns; i++)
+    column_auto_resize (clist, NULL, i, clist->column[i].width);
+}
+
+static void
+cell_size_request (GtkCList       *clist,
+		   GtkCListRow    *clist_row,
+		   gint            column,
+		   GtkRequisition *requisition)
+{
+  GtkCTree *ctree;
+  GtkStyle *style;
+  gint width;
+  gint height;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+  g_return_if_fail (requisition != NULL);
+
+  ctree = GTK_CTREE (clist);
+
+  get_cell_style (clist, clist_row, GTK_STATE_NORMAL, column, &style,
+		  NULL, NULL);
+
+  switch (clist_row->cell[column].type)
+    {
+    case GTK_CELL_TEXT:
+      requisition->width =
+	gdk_string_width (style->font,
+			  GTK_CELL_TEXT (clist_row->cell[column])->text);
+      requisition->height = style->font->ascent + style->font->descent;
+      break;
+    case GTK_CELL_PIXTEXT:
+      if (GTK_CELL_PIXTEXT (clist_row->cell[column])->pixmap)
+	{
+	  gdk_window_get_size (GTK_CELL_PIXTEXT
+			       (clist_row->cell[column])->pixmap,
+			       &width, &height);
+	  width += GTK_CELL_PIXTEXT (clist_row->cell[column])->spacing;
+	}
+      else
+	width = height = 0;
+	  
+      requisition->width = width +
+	gdk_string_width (style->font,
+			  GTK_CELL_TEXT (clist_row->cell[column])->text);
+
+      requisition->height = MAX (style->font->ascent + style->font->descent,
+				 height);
+      if (column == ctree->tree_column)
+	{
+	  requisition->width += (ctree->tree_spacing + ctree->tree_indent *
+				 (((GtkCTreeRow *) clist_row)->level - 1));
+	  switch (ctree->expander_style)
+	    {
+	    case GTK_CTREE_EXPANDER_NONE:
+	      break;
+	    case GTK_CTREE_EXPANDER_TRIANGLE:
+	      requisition->width += PM_SIZE + 3;
+	      break;
+	    case GTK_CTREE_EXPANDER_SQUARE:
+	    case GTK_CTREE_EXPANDER_CIRCULAR:
+	      requisition->width += PM_SIZE + 1;
+	      break;
+	    }
+	  if (ctree->line_style == GTK_CTREE_LINES_TABBED)
+	    requisition->width += 3;
+	}
+      break;
+    case GTK_CELL_PIXMAP:
+      gdk_window_get_size (GTK_CELL_PIXMAP (clist_row->cell[column])->pixmap,
+			   &width, &height);
+      requisition->width = width;
+      requisition->height = height;
+      break;
+    default:
+      requisition->width  = 0;
+      requisition->height = 0;
+      break;
+    }
+
+  requisition->width  += clist_row->cell[column].horizontal;
+  requisition->height += clist_row->cell[column].vertical;
+}
+
+static void
+set_cell_contents (GtkCList    *clist,
+		   GtkCListRow *clist_row,
+		   gint         column,
+		   GtkCellType  type,
+		   const gchar *text,
+		   guint8       spacing,
+		   GdkPixmap   *pixmap,
+		   GdkBitmap   *mask)
+{
+  gboolean visible = FALSE;
+  GtkCTree *ctree;
+  GtkRequisition requisition;
+  gchar *old_text = NULL;
+  GdkPixmap *old_pixmap = NULL;
+  GdkBitmap *old_mask = NULL;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+  g_return_if_fail (clist_row != NULL);
+
+  ctree = GTK_CTREE (clist);
+
+  if (clist->column[column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    {
+      GtkCTreeNode *parent;
+
+      parent = ((GtkCTreeRow *)clist_row)->parent;
+      if (!parent || (parent && GTK_CTREE_ROW (parent)->expanded &&
+		      gtk_ctree_is_viewable (ctree, parent)))
+	{
+	  visible = TRUE;
+	  GTK_CLIST_CLASS_FW (clist)->cell_size_request (clist, clist_row,
+							 column, &requisition);
+	}
+    }
+
+  switch (clist_row->cell[column].type)
+    {
+    case GTK_CELL_EMPTY:
+      break;
+    case GTK_CELL_TEXT:
+      old_text = GTK_CELL_TEXT (clist_row->cell[column])->text;
+      break;
+    case GTK_CELL_PIXMAP:
+      old_pixmap = GTK_CELL_PIXMAP (clist_row->cell[column])->pixmap;
+      old_mask = GTK_CELL_PIXMAP (clist_row->cell[column])->mask;
+      break;
+    case GTK_CELL_PIXTEXT:
+      old_text = GTK_CELL_PIXTEXT (clist_row->cell[column])->text;
+      old_pixmap = GTK_CELL_PIXTEXT (clist_row->cell[column])->pixmap;
+      old_mask = GTK_CELL_PIXTEXT (clist_row->cell[column])->mask;
+      break;
+    case GTK_CELL_WIDGET:
+      /* unimplimented */
+      break;
+      
+    default:
+      break;
+    }
+
+  clist_row->cell[column].type = GTK_CELL_EMPTY;
+  if (column == ctree->tree_column && type != GTK_CELL_EMPTY)
+    type = GTK_CELL_PIXTEXT;
+
+  /* Note that pixmap and mask were already ref'ed by the caller
+   */
+  switch (type)
+    {
+    case GTK_CELL_TEXT:
+      if (text)
+	{
+	  clist_row->cell[column].type = GTK_CELL_TEXT;
+	  GTK_CELL_TEXT (clist_row->cell[column])->text = g_strdup (text);
+	}
+      break;
+    case GTK_CELL_PIXMAP:
+      if (pixmap)
+	{
+	  clist_row->cell[column].type = GTK_CELL_PIXMAP;
+	  GTK_CELL_PIXMAP (clist_row->cell[column])->pixmap = pixmap;
+	  /* We set the mask even if it is NULL */
+	  GTK_CELL_PIXMAP (clist_row->cell[column])->mask = mask;
+	}
+      break;
+    case GTK_CELL_PIXTEXT:
+      if (column == ctree->tree_column)
+	{
+	  clist_row->cell[column].type = GTK_CELL_PIXTEXT;
+	  GTK_CELL_PIXTEXT (clist_row->cell[column])->spacing = spacing;
+	  if (text)
+	    GTK_CELL_PIXTEXT (clist_row->cell[column])->text = g_strdup (text);
+	  else
+	    GTK_CELL_PIXTEXT (clist_row->cell[column])->text = NULL;
+	  if (pixmap)
+	    {
+	      GTK_CELL_PIXTEXT (clist_row->cell[column])->pixmap = pixmap;
+	      GTK_CELL_PIXTEXT (clist_row->cell[column])->mask = mask;
+	    }
+	  else
+	    {
+	      GTK_CELL_PIXTEXT (clist_row->cell[column])->pixmap = NULL;
+	      GTK_CELL_PIXTEXT (clist_row->cell[column])->mask = NULL;
+	    }
+	}
+      else if (text && pixmap)
+	{
+	  clist_row->cell[column].type = GTK_CELL_PIXTEXT;
+	  GTK_CELL_PIXTEXT (clist_row->cell[column])->text = g_strdup (text);
+	  GTK_CELL_PIXTEXT (clist_row->cell[column])->spacing = spacing;
+	  GTK_CELL_PIXTEXT (clist_row->cell[column])->pixmap = pixmap;
+	  GTK_CELL_PIXTEXT (clist_row->cell[column])->mask = mask;
+	}
+      break;
+    default:
+      break;
+    }
+  
+  if (visible && clist->column[column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    column_auto_resize (clist, clist_row, column, requisition.width);
+
+  if (old_text)
+    g_free (old_text);
+  if (old_pixmap)
+    gdk_pixmap_unref (old_pixmap);
+  if (old_mask)
+    gdk_pixmap_unref (old_mask);
+}
+
+static void 
+set_node_info (GtkCTree     *ctree,
+	       GtkCTreeNode *node,
+	       const gchar  *text,
+	       guint8        spacing,
+	       GdkPixmap    *pixmap_closed,
+	       GdkBitmap    *mask_closed,
+	       GdkPixmap    *pixmap_opened,
+	       GdkBitmap    *mask_opened,
+	       gboolean      is_leaf,
+	       gboolean      expanded)
+{
+  if (GTK_CTREE_ROW (node)->pixmap_opened)
+    {
+      gdk_pixmap_unref (GTK_CTREE_ROW (node)->pixmap_opened);
+      if (GTK_CTREE_ROW (node)->mask_opened) 
+	gdk_bitmap_unref (GTK_CTREE_ROW (node)->mask_opened);
+    }
+  if (GTK_CTREE_ROW (node)->pixmap_closed)
+    {
+      gdk_pixmap_unref (GTK_CTREE_ROW (node)->pixmap_closed);
+      if (GTK_CTREE_ROW (node)->mask_closed) 
+	gdk_bitmap_unref (GTK_CTREE_ROW (node)->mask_closed);
+    }
+
+  GTK_CTREE_ROW (node)->pixmap_opened = NULL;
+  GTK_CTREE_ROW (node)->mask_opened   = NULL;
+  GTK_CTREE_ROW (node)->pixmap_closed = NULL;
+  GTK_CTREE_ROW (node)->mask_closed   = NULL;
+
+  if (pixmap_closed)
+    {
+      GTK_CTREE_ROW (node)->pixmap_closed = gdk_pixmap_ref (pixmap_closed);
+      if (mask_closed) 
+	GTK_CTREE_ROW (node)->mask_closed = gdk_bitmap_ref (mask_closed);
+    }
+  if (pixmap_opened)
+    {
+      GTK_CTREE_ROW (node)->pixmap_opened = gdk_pixmap_ref (pixmap_opened);
+      if (mask_opened) 
+	GTK_CTREE_ROW (node)->mask_opened = gdk_bitmap_ref (mask_opened);
+    }
+
+  GTK_CTREE_ROW (node)->is_leaf  = is_leaf;
+  GTK_CTREE_ROW (node)->expanded = (is_leaf) ? FALSE : expanded;
+
+  if (GTK_CTREE_ROW (node)->expanded)
+    gtk_ctree_node_set_pixtext (ctree, node, ctree->tree_column,
+				text, spacing, pixmap_opened, mask_opened);
+  else 
+    gtk_ctree_node_set_pixtext (ctree, node, ctree->tree_column,
+				text, spacing, pixmap_closed, mask_closed);
+}
+
+static void
+tree_delete (GtkCTree     *ctree, 
+	     GtkCTreeNode *node, 
+	     gpointer      data)
+{
+  tree_unselect (ctree,  node, NULL);
+  row_delete (ctree, GTK_CTREE_ROW (node));
+  g_list_free_1 ((GList *)node);
+}
+
+static void
+tree_delete_row (GtkCTree     *ctree, 
+		 GtkCTreeNode *node, 
+		 gpointer      data)
+{
+  row_delete (ctree, GTK_CTREE_ROW (node));
+  g_list_free_1 ((GList *)node);
+}
+
+static void
+tree_update_level (GtkCTree     *ctree, 
+		   GtkCTreeNode *node, 
+		   gpointer      data)
+{
+  if (!node)
+    return;
+
+  if (GTK_CTREE_ROW (node)->parent)
+      GTK_CTREE_ROW (node)->level = 
+	GTK_CTREE_ROW (GTK_CTREE_ROW (node)->parent)->level + 1;
+  else
+      GTK_CTREE_ROW (node)->level = 1;
+}
+
+static void
+tree_select (GtkCTree     *ctree, 
+	     GtkCTreeNode *node, 
+	     gpointer      data)
+{
+  if (node && GTK_CTREE_ROW (node)->row.state != GTK_STATE_SELECTED &&
+      GTK_CTREE_ROW (node)->row.selectable)
+    gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_SELECT_ROW],
+		     node, -1);
+}
+
+static void
+tree_unselect (GtkCTree     *ctree, 
+	       GtkCTreeNode *node, 
+	       gpointer      data)
+{
+  if (node && GTK_CTREE_ROW (node)->row.state == GTK_STATE_SELECTED)
+    gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_UNSELECT_ROW], 
+		     node, -1);
+}
+
+static void
+tree_expand (GtkCTree     *ctree, 
+	     GtkCTreeNode *node, 
+	     gpointer      data)
+{
+  if (node && !GTK_CTREE_ROW (node)->expanded)
+    gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_EXPAND], node);
+}
+
+static void
+tree_collapse (GtkCTree     *ctree, 
+	       GtkCTreeNode *node, 
+	       gpointer      data)
+{
+  if (node && GTK_CTREE_ROW (node)->expanded)
+    gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_COLLAPSE], node);
+}
+
+static void
+tree_collapse_to_depth (GtkCTree     *ctree, 
+			GtkCTreeNode *node, 
+			gint          depth)
+{
+  if (node && GTK_CTREE_ROW (node)->level == depth)
+    gtk_ctree_collapse_recursive (ctree, node);
+}
+
+static void
+tree_toggle_expansion (GtkCTree     *ctree,
+		       GtkCTreeNode *node,
+		       gpointer      data)
+{
+  if (!node)
+    return;
+
+  if (GTK_CTREE_ROW (node)->expanded)
+    gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_COLLAPSE], node);
+  else
+    gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_EXPAND], node);
+}
+
+static GtkCTreeRow *
+row_new (GtkCTree *ctree)
+{
+  GtkCList *clist;
+  GtkCTreeRow *ctree_row;
+  int i;
+
+  clist = GTK_CLIST (ctree);
+  ctree_row = g_chunk_new (GtkCTreeRow, clist->row_mem_chunk);
+  ctree_row->row.cell = g_chunk_new (GtkCell, clist->cell_mem_chunk);
+
+  for (i = 0; i < clist->columns; i++)
+    {
+      ctree_row->row.cell[i].type = GTK_CELL_EMPTY;
+      ctree_row->row.cell[i].vertical = 0;
+      ctree_row->row.cell[i].horizontal = 0;
+      ctree_row->row.cell[i].style = NULL;
+    }
+
+  GTK_CELL_PIXTEXT (ctree_row->row.cell[ctree->tree_column])->text = NULL;
+
+  ctree_row->row.fg_set     = FALSE;
+  ctree_row->row.bg_set     = FALSE;
+  ctree_row->row.style      = NULL;
+  ctree_row->row.selectable = TRUE;
+  ctree_row->row.state      = GTK_STATE_NORMAL;
+  ctree_row->row.data       = NULL;
+  ctree_row->row.destroy    = NULL;
+
+  ctree_row->level         = 0;
+  ctree_row->expanded      = FALSE;
+  ctree_row->parent        = NULL;
+  ctree_row->sibling       = NULL;
+  ctree_row->children      = NULL;
+  ctree_row->pixmap_closed = NULL;
+  ctree_row->mask_closed   = NULL;
+  ctree_row->pixmap_opened = NULL;
+  ctree_row->mask_opened   = NULL;
+  
+  return ctree_row;
+}
+
+static void
+row_delete (GtkCTree    *ctree,
+	    GtkCTreeRow *ctree_row)
+{
+  GtkCList *clist;
+  gint i;
+
+  clist = GTK_CLIST (ctree);
+
+  for (i = 0; i < clist->columns; i++)
+    {
+      GTK_CLIST_CLASS_FW (clist)->set_cell_contents
+	(clist, &(ctree_row->row), i, GTK_CELL_EMPTY, NULL, 0, NULL, NULL);
+      if (ctree_row->row.cell[i].style)
+	{
+	  if (GTK_WIDGET_REALIZED (ctree))
+	    gtk_style_detach (ctree_row->row.cell[i].style);
+	  gtk_style_unref (ctree_row->row.cell[i].style);
+	}
+    }
+
+  if (ctree_row->row.style)
+    {
+      if (GTK_WIDGET_REALIZED (ctree))
+	gtk_style_detach (ctree_row->row.style);
+      gtk_style_unref (ctree_row->row.style);
+    }
+
+  if (ctree_row->pixmap_closed)
+    {
+      gdk_pixmap_unref (ctree_row->pixmap_closed);
+      if (ctree_row->mask_closed)
+	gdk_bitmap_unref (ctree_row->mask_closed);
+    }
+
+  if (ctree_row->pixmap_opened)
+    {
+      gdk_pixmap_unref (ctree_row->pixmap_opened);
+      if (ctree_row->mask_opened)
+	gdk_bitmap_unref (ctree_row->mask_opened);
+    }
+
+  if (ctree_row->row.destroy)
+    {
+      GtkDestroyNotify dnotify = ctree_row->row.destroy;
+      gpointer ddata = ctree_row->row.data;
+
+      ctree_row->row.destroy = NULL;
+      ctree_row->row.data = NULL;
+
+      dnotify (ddata);
+    }
+
+  g_mem_chunk_free (clist->cell_mem_chunk, ctree_row->row.cell);
+  g_mem_chunk_free (clist->row_mem_chunk, ctree_row);
+}
+
+static void
+real_select_row (GtkCList *clist,
+		 gint      row,
+		 gint      column,
+		 GdkEvent *event)
+{
+  GList *node;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+  
+  if ((node = g_list_nth (clist->row_list, row)) &&
+      GTK_CTREE_ROW (node)->row.selectable)
+    gtk_signal_emit (GTK_OBJECT (clist), ctree_signals[TREE_SELECT_ROW],
+		     node, column);
+}
+
+static void
+real_unselect_row (GtkCList *clist,
+		   gint      row,
+		   gint      column,
+		   GdkEvent *event)
+{
+  GList *node;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+
+  if ((node = g_list_nth (clist->row_list, row)))
+    gtk_signal_emit (GTK_OBJECT (clist), ctree_signals[TREE_UNSELECT_ROW],
+		     node, column);
+}
+
+static void
+real_tree_select (GtkCTree     *ctree,
+		  GtkCTreeNode *node,
+		  gint          column)
+{
+  GtkCList *clist;
+  GList *list;
+  GtkCTreeNode *sel_row;
+  gboolean node_selected;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  if (!node || GTK_CTREE_ROW (node)->row.state == GTK_STATE_SELECTED ||
+      !GTK_CTREE_ROW (node)->row.selectable)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  switch (clist->selection_mode)
+    {
+    case GTK_SELECTION_SINGLE:
+    case GTK_SELECTION_BROWSE:
+
+      node_selected = FALSE;
+      list = clist->selection;
+
+      while (list)
+	{
+	  sel_row = list->data;
+	  list = list->next;
+	  
+	  if (node == sel_row)
+	    node_selected = TRUE;
+	  else
+	    gtk_signal_emit (GTK_OBJECT (ctree),
+			     ctree_signals[TREE_UNSELECT_ROW], sel_row, column);
+	}
+
+      if (node_selected)
+	return;
+
+    default:
+      break;
+    }
+
+  GTK_CTREE_ROW (node)->row.state = GTK_STATE_SELECTED;
+
+  if (!clist->selection)
+    {
+      clist->selection = g_list_append (clist->selection, node);
+      clist->selection_end = clist->selection;
+    }
+  else
+    clist->selection_end = g_list_append (clist->selection_end, node)->next;
+
+  tree_draw_node (ctree, node);
+}
+
+static void
+real_tree_unselect (GtkCTree     *ctree,
+		    GtkCTreeNode *node,
+		    gint          column)
+{
+  GtkCList *clist;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  if (!node || GTK_CTREE_ROW (node)->row.state != GTK_STATE_SELECTED)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  if (clist->selection_end && clist->selection_end->data == node)
+    clist->selection_end = clist->selection_end->prev;
+
+  clist->selection = g_list_remove (clist->selection, node);
+  
+  GTK_CTREE_ROW (node)->row.state = GTK_STATE_NORMAL;
+
+  tree_draw_node (ctree, node);
+}
+
+static void
+select_row_recursive (GtkCTree     *ctree, 
+		      GtkCTreeNode *node, 
+		      gpointer      data)
+{
+  if (!node || GTK_CTREE_ROW (node)->row.state == GTK_STATE_SELECTED ||
+      !GTK_CTREE_ROW (node)->row.selectable)
+    return;
+
+  GTK_CLIST (ctree)->undo_unselection = 
+    g_list_prepend (GTK_CLIST (ctree)->undo_unselection, node);
+  gtk_ctree_select (ctree, node);
+}
+
+static void
+real_select_all (GtkCList *clist)
+{
+  GtkCTree *ctree;
+  GtkCTreeNode *node;
+  
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+
+  ctree = GTK_CTREE (clist);
+
+  switch (clist->selection_mode)
+    {
+    case GTK_SELECTION_SINGLE:
+    case GTK_SELECTION_BROWSE:
+      return;
+
+    case GTK_SELECTION_EXTENDED:
+
+      gtk_clist_freeze (clist);
+
+      g_list_free (clist->undo_selection);
+      g_list_free (clist->undo_unselection);
+      clist->undo_selection = NULL;
+      clist->undo_unselection = NULL;
+	  
+      clist->anchor_state = GTK_STATE_SELECTED;
+      clist->anchor = -1;
+      clist->drag_pos = -1;
+      clist->undo_anchor = clist->focus_row;
+
+      for (node = GTK_CTREE_NODE (clist->row_list); node;
+	   node = GTK_CTREE_NODE_NEXT (node))
+	gtk_ctree_pre_recursive (ctree, node, select_row_recursive, NULL);
+
+      gtk_clist_thaw (clist);
+      break;
+
+    case GTK_SELECTION_MULTIPLE:
+      gtk_ctree_select_recursive (ctree, NULL);
+      break;
+
+    default:
+      /* do nothing */
+      break;
+    }
+}
+
+static void
+real_unselect_all (GtkCList *clist)
+{
+  GtkCTree *ctree;
+  GtkCTreeNode *node;
+  GList *list;
+ 
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+  
+  ctree = GTK_CTREE (clist);
+
+  switch (clist->selection_mode)
+    {
+    case GTK_SELECTION_BROWSE:
+      if (clist->focus_row >= 0)
+	{
+	  gtk_ctree_select
+	    (ctree,
+	     GTK_CTREE_NODE (g_list_nth (clist->row_list, clist->focus_row)));
+	  return;
+	}
+      break;
+
+    case GTK_SELECTION_EXTENDED:
+      g_list_free (clist->undo_selection);
+      g_list_free (clist->undo_unselection);
+      clist->undo_selection = NULL;
+      clist->undo_unselection = NULL;
+
+      clist->anchor = -1;
+      clist->drag_pos = -1;
+      clist->undo_anchor = clist->focus_row;
+      break;
+
+    default:
+      break;
+    }
+
+  list = clist->selection;
+
+  while (list)
+    {
+      node = list->data;
+      list = list->next;
+      gtk_ctree_unselect (ctree, node);
+    }
+}
+
+static gboolean
+ctree_is_hot_spot (GtkCTree     *ctree, 
+		   GtkCTreeNode *node,
+		   gint          row, 
+		   gint          x, 
+		   gint          y)
+{
+  GtkCTreeRow *tree_row;
+  GtkCList *clist;
+  GtkCellPixText *cell;
+  gint xl;
+  gint yu;
+  
+  g_return_val_if_fail (ctree != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), FALSE);
+  g_return_val_if_fail (node != NULL, FALSE);
+
+  clist = GTK_CLIST (ctree);
+
+  if (!clist->column[ctree->tree_column].visible ||
+      ctree->expander_style == GTK_CTREE_EXPANDER_NONE)
+    return FALSE;
+
+  tree_row = GTK_CTREE_ROW (node);
+
+  cell = GTK_CELL_PIXTEXT(tree_row->row.cell[ctree->tree_column]);
+
+  yu = (ROW_TOP_YPIXEL (clist, row) + (clist->row_height - PM_SIZE) / 2 -
+	(clist->row_height - 1) % 2);
+
+  if (clist->column[ctree->tree_column].justification == GTK_JUSTIFY_RIGHT)
+    xl = (clist->column[ctree->tree_column].area.x + 
+	  clist->column[ctree->tree_column].area.width - 1 + clist->hoffset -
+	  (tree_row->level - 1) * ctree->tree_indent - PM_SIZE -
+	  (ctree->line_style == GTK_CTREE_LINES_TABBED) * 3);
+  else
+    xl = (clist->column[ctree->tree_column].area.x + clist->hoffset +
+	  (tree_row->level - 1) * ctree->tree_indent +
+	  (ctree->line_style == GTK_CTREE_LINES_TABBED) * 3);
+
+  return (x >= xl && x <= xl + PM_SIZE && y >= yu && y <= yu + PM_SIZE);
+}
+
+/***********************************************************
+ ***********************************************************
+ ***                  Public interface                   ***
+ ***********************************************************
+ ***********************************************************/
+
+
+/***********************************************************
+ *           Creation, insertion, deletion                 *
+ ***********************************************************/
+
+void
+gtk_ctree_construct (GtkCTree    *ctree,
+		     gint         columns, 
+		     gint         tree_column,
+		     gchar       *titles[])
+{
+  GtkCList *clist;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (GTK_OBJECT_CONSTRUCTED (ctree) == FALSE);
+
+  clist = GTK_CLIST (ctree);
+
+  clist->row_mem_chunk = g_mem_chunk_new ("ctree row mem chunk",
+					  sizeof (GtkCTreeRow),
+					  sizeof (GtkCTreeRow)
+					  * CLIST_OPTIMUM_SIZE, 
+					  G_ALLOC_AND_FREE);
+
+  clist->cell_mem_chunk = g_mem_chunk_new ("ctree cell mem chunk",
+					   sizeof (GtkCell) * columns,
+					   sizeof (GtkCell) * columns
+					   * CLIST_OPTIMUM_SIZE, 
+					   G_ALLOC_AND_FREE);
+
+  ctree->tree_column = tree_column;
+
+  gtk_clist_construct (clist, columns, titles);
+}
+
+GtkWidget *
+gtk_ctree_new_with_titles (gint         columns, 
+			   gint         tree_column,
+			   gchar       *titles[])
+{
+  GtkWidget *widget;
+
+  g_return_val_if_fail (columns > 0, NULL);
+  g_return_val_if_fail (tree_column >= 0 && tree_column < columns, NULL);
+
+  widget = gtk_type_new (GTK_TYPE_CTREE);
+  gtk_ctree_construct (GTK_CTREE (widget), columns, tree_column, titles);
+
+  return widget;
+}
+
+GtkWidget *
+gtk_ctree_new (gint columns, 
+	       gint tree_column)
+{
+  return gtk_ctree_new_with_titles (columns, tree_column, NULL);
+}
+
+static gint
+real_insert_row (GtkCList *clist,
+		 gint      row,
+		 gchar    *text[])
+{
+  GtkCTreeNode *parent = NULL;
+  GtkCTreeNode *sibling;
+  GtkCTreeNode *node;
+
+  g_return_val_if_fail (clist != NULL, -1);
+  g_return_val_if_fail (GTK_IS_CTREE (clist), -1);
+
+  sibling = GTK_CTREE_NODE (g_list_nth (clist->row_list, row));
+  if (sibling)
+    parent = GTK_CTREE_ROW (sibling)->parent;
+
+  node = gtk_ctree_insert_node (GTK_CTREE (clist), parent, sibling, text, 5,
+				NULL, NULL, NULL, NULL, TRUE, FALSE);
+
+  if (GTK_CLIST_AUTO_SORT (clist) || !sibling)
+    return g_list_position (clist->row_list, (GList *) node);
+  
+  return row;
+}
+
+GtkCTreeNode * 
+gtk_ctree_insert_node (GtkCTree     *ctree,
+		       GtkCTreeNode *parent, 
+		       GtkCTreeNode *sibling,
+		       gchar        *text[],
+		       guint8        spacing,
+		       GdkPixmap    *pixmap_closed,
+		       GdkBitmap    *mask_closed,
+		       GdkPixmap    *pixmap_opened,
+		       GdkBitmap    *mask_opened,
+		       gboolean      is_leaf,
+		       gboolean      expanded)
+{
+  GtkCList *clist;
+  GtkCTreeRow *new_row;
+  GtkCTreeNode *node;
+  GList *list;
+  gint i;
+
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+  if (sibling)
+    g_return_val_if_fail (GTK_CTREE_ROW (sibling)->parent == parent, NULL);
+
+  if (parent && GTK_CTREE_ROW (parent)->is_leaf)
+    return NULL;
+
+  clist = GTK_CLIST (ctree);
+
+  /* create the row */
+  new_row = row_new (ctree);
+  list = g_list_alloc ();
+  list->data = new_row;
+  node = GTK_CTREE_NODE (list);
+
+  if (text)
+    for (i = 0; i < clist->columns; i++)
+      if (text[i] && i != ctree->tree_column)
+	GTK_CLIST_CLASS_FW (clist)->set_cell_contents
+	  (clist, &(new_row->row), i, GTK_CELL_TEXT, text[i], 0, NULL, NULL);
+
+  set_node_info (ctree, node, text ?
+		 text[ctree->tree_column] : NULL, spacing, pixmap_closed,
+		 mask_closed, pixmap_opened, mask_opened, is_leaf, expanded);
+
+  /* sorted insertion */
+  if (GTK_CLIST_AUTO_SORT (clist))
+    {
+      if (parent)
+	sibling = GTK_CTREE_ROW (parent)->children;
+      else
+	sibling = GTK_CTREE_NODE (clist->row_list);
+
+      while (sibling && clist->compare
+	     (clist, GTK_CTREE_ROW (node), GTK_CTREE_ROW (sibling)) > 0)
+	sibling = GTK_CTREE_ROW (sibling)->sibling;
+    }
+
+  gtk_ctree_link (ctree, node, parent, sibling, TRUE);
+
+  if (text && !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist) &&
+      gtk_ctree_is_viewable (ctree, node))
+    {
+      for (i = 0; i < clist->columns; i++)
+	if (clist->column[i].auto_resize)
+	  column_auto_resize (clist, &(new_row->row), i, 0);
+    }
+
+  if (clist->rows == 1)
+    {
+      clist->focus_row = 0;
+      if (clist->selection_mode == GTK_SELECTION_BROWSE)
+	gtk_ctree_select (ctree, node);
+    }
+
+
+  CLIST_REFRESH (clist);
+
+  return node;
+}
+
+GtkCTreeNode *
+gtk_ctree_insert_gnode (GtkCTree          *ctree,
+			GtkCTreeNode      *parent,
+			GtkCTreeNode      *sibling,
+			GNode             *gnode,
+			GtkCTreeGNodeFunc  func,
+			gpointer           data)
+{
+  GtkCList *clist;
+  GtkCTreeNode *cnode = NULL;
+  GtkCTreeNode *child = NULL;
+  GtkCTreeNode *new_child;
+  GList *list;
+  GNode *work;
+  guint depth = 1;
+
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+  g_return_val_if_fail (gnode != NULL, NULL);
+  g_return_val_if_fail (func != NULL, NULL);
+  if (sibling)
+    g_return_val_if_fail (GTK_CTREE_ROW (sibling)->parent == parent, NULL);
+  
+  clist = GTK_CLIST (ctree);
+
+  if (parent)
+    depth = GTK_CTREE_ROW (parent)->level + 1;
+
+  list = g_list_alloc ();
+  list->data = row_new (ctree);
+  cnode = GTK_CTREE_NODE (list);
+
+  gtk_clist_freeze (clist);
+
+  set_node_info (ctree, cnode, "", 0, NULL, NULL, NULL, NULL, TRUE, FALSE);
+
+  if (!func (ctree, depth, gnode, cnode, data))
+    {
+      tree_delete_row (ctree, cnode, NULL);
+      return NULL;
+    }
+
+  if (GTK_CLIST_AUTO_SORT (clist))
+    {
+      if (parent)
+	sibling = GTK_CTREE_ROW (parent)->children;
+      else
+	sibling = GTK_CTREE_NODE (clist->row_list);
+
+      while (sibling && clist->compare
+	     (clist, GTK_CTREE_ROW (cnode), GTK_CTREE_ROW (sibling)) > 0)
+	sibling = GTK_CTREE_ROW (sibling)->sibling;
+    }
+
+  gtk_ctree_link (ctree, cnode, parent, sibling, TRUE);
+
+  for (work = g_node_last_child (gnode); work; work = work->prev)
+    {
+      new_child = gtk_ctree_insert_gnode (ctree, cnode, child,
+					  work, func, data);
+      if (new_child)
+	child = new_child;
+    }	
+  
+  gtk_clist_thaw (clist);
+
+  return cnode;
+}
+
+GNode *
+gtk_ctree_export_to_gnode (GtkCTree          *ctree,
+			   GNode             *parent,
+			   GNode             *sibling,
+			   GtkCTreeNode      *node,
+			   GtkCTreeGNodeFunc  func,
+			   gpointer           data)
+{
+  GtkCTreeNode *work;
+  GNode *gnode;
+  gint depth;
+
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (func != NULL, NULL);
+  if (sibling)
+    {
+      g_return_val_if_fail (parent != NULL, NULL);
+      g_return_val_if_fail (sibling->parent == parent, NULL);
+    }
+
+  gnode = g_node_new (NULL);
+  depth = g_node_depth (parent) + 1;
+  
+  if (!func (ctree, depth, gnode, node, data))
+    {
+      g_node_destroy (gnode);
+      return NULL;
+    }
+
+  if (parent)
+    g_node_insert_before (parent, sibling, gnode);
+
+  if (!GTK_CTREE_ROW (node)->is_leaf)
+    {
+      GNode *new_sibling = NULL;
+
+      for (work = GTK_CTREE_ROW (node)->children; work;
+	   work = GTK_CTREE_ROW (work)->sibling)
+	new_sibling = gtk_ctree_export_to_gnode (ctree, gnode, new_sibling,
+						 work, func, data);
+
+      g_node_reverse_children (gnode);
+    }
+
+  return gnode;
+}
+  
+static void
+real_remove_row (GtkCList *clist,
+		 gint      row)
+{
+  GtkCTreeNode *node;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+
+  node = GTK_CTREE_NODE (g_list_nth (clist->row_list, row));
+
+  if (node)
+    gtk_ctree_remove_node (GTK_CTREE (clist), node);
+}
+
+void
+gtk_ctree_remove_node (GtkCTree     *ctree, 
+		       GtkCTreeNode *node)
+{
+  GtkCList *clist;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  clist = GTK_CLIST (ctree);
+
+  gtk_clist_freeze (clist);
+
+  if (node)
+    {
+      gboolean visible;
+
+      visible = gtk_ctree_is_viewable (ctree, node);
+      gtk_ctree_unlink (ctree, node, TRUE);
+      gtk_ctree_post_recursive (ctree, node, GTK_CTREE_FUNC (tree_delete),
+				NULL);
+      if (clist->selection_mode == GTK_SELECTION_BROWSE && !clist->selection &&
+	  clist->focus_row >= 0)
+	gtk_clist_select_row (clist, clist->focus_row, -1);
+
+      auto_resize_columns (clist);
+    }
+  else
+    gtk_clist_clear (clist);
+
+  gtk_clist_thaw (clist);
+}
+
+static void
+real_clear (GtkCList *clist)
+{
+  GtkCTree *ctree;
+  GtkCTreeNode *work;
+  GtkCTreeNode *ptr;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+
+  ctree = GTK_CTREE (clist);
+
+  /* remove all rows */
+  work = GTK_CTREE_NODE (clist->row_list);
+  clist->row_list = NULL;
+  clist->row_list_end = NULL;
+
+  GTK_CLIST_SET_FLAG (clist, CLIST_AUTO_RESIZE_BLOCKED);
+  while (work)
+    {
+      ptr = work;
+      work = GTK_CTREE_ROW (work)->sibling;
+      gtk_ctree_post_recursive (ctree, ptr, GTK_CTREE_FUNC (tree_delete_row), 
+				NULL);
+    }
+  GTK_CLIST_UNSET_FLAG (clist, CLIST_AUTO_RESIZE_BLOCKED);
+
+  parent_class->clear (clist);
+}
+
+
+/***********************************************************
+ *  Generic recursive functions, querying / finding tree   *
+ *  information                                            *
+ ***********************************************************/
+
+
+void
+gtk_ctree_post_recursive (GtkCTree     *ctree, 
+			  GtkCTreeNode *node,
+			  GtkCTreeFunc  func,
+			  gpointer      data)
+{
+  GtkCTreeNode *work;
+  GtkCTreeNode *tmp;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (func != NULL);
+
+  if (node)
+    work = GTK_CTREE_ROW (node)->children;
+  else
+    work = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  while (work)
+    {
+      tmp = GTK_CTREE_ROW (work)->sibling;
+      gtk_ctree_post_recursive (ctree, work, func, data);
+      work = tmp;
+    }
+
+  if (node)
+    func (ctree, node, data);
+}
+
+void
+gtk_ctree_post_recursive_to_depth (GtkCTree     *ctree, 
+				   GtkCTreeNode *node,
+				   gint          depth,
+				   GtkCTreeFunc  func,
+				   gpointer      data)
+{
+  GtkCTreeNode *work;
+  GtkCTreeNode *tmp;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (func != NULL);
+
+  if (depth < 0)
+    {
+      gtk_ctree_post_recursive (ctree, node, func, data);
+      return;
+    }
+
+  if (node)
+    work = GTK_CTREE_ROW (node)->children;
+  else
+    work = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  if (work && GTK_CTREE_ROW (work)->level <= depth)
+    {
+      while (work)
+	{
+	  tmp = GTK_CTREE_ROW (work)->sibling;
+	  gtk_ctree_post_recursive_to_depth (ctree, work, depth, func, data);
+	  work = tmp;
+	}
+    }
+
+  if (node && GTK_CTREE_ROW (node)->level <= depth)
+    func (ctree, node, data);
+}
+
+void
+gtk_ctree_pre_recursive (GtkCTree     *ctree, 
+			 GtkCTreeNode *node,
+			 GtkCTreeFunc  func,
+			 gpointer      data)
+{
+  GtkCTreeNode *work;
+  GtkCTreeNode *tmp;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (func != NULL);
+
+  if (node)
+    {
+      work = GTK_CTREE_ROW (node)->children;
+      func (ctree, node, data);
+    }
+  else
+    work = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  while (work)
+    {
+      tmp = GTK_CTREE_ROW (work)->sibling;
+      gtk_ctree_pre_recursive (ctree, work, func, data);
+      work = tmp;
+    }
+}
+
+void
+gtk_ctree_pre_recursive_to_depth (GtkCTree     *ctree, 
+				  GtkCTreeNode *node,
+				  gint          depth, 
+				  GtkCTreeFunc  func,
+				  gpointer      data)
+{
+  GtkCTreeNode *work;
+  GtkCTreeNode *tmp;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (func != NULL);
+
+  if (depth < 0)
+    {
+      gtk_ctree_pre_recursive (ctree, node, func, data);
+      return;
+    }
+
+  if (node)
+    {
+      work = GTK_CTREE_ROW (node)->children;
+      if (GTK_CTREE_ROW (node)->level <= depth)
+	func (ctree, node, data);
+    }
+  else
+    work = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  if (work && GTK_CTREE_ROW (work)->level <= depth)
+    {
+      while (work)
+	{
+	  tmp = GTK_CTREE_ROW (work)->sibling;
+	  gtk_ctree_pre_recursive_to_depth (ctree, work, depth, func, data);
+	  work = tmp;
+	}
+    }
+}
+
+gboolean
+gtk_ctree_is_viewable (GtkCTree     *ctree, 
+		       GtkCTreeNode *node)
+{ 
+  GtkCTreeRow *work;
+
+  g_return_val_if_fail (ctree != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), FALSE);
+  g_return_val_if_fail (node != NULL, FALSE);
+
+  work = GTK_CTREE_ROW (node);
+
+  while (work->parent && GTK_CTREE_ROW (work->parent)->expanded)
+    work = GTK_CTREE_ROW (work->parent);
+
+  if (!work->parent)
+    return TRUE;
+
+  return FALSE;
+}
+
+GtkCTreeNode * 
+gtk_ctree_last (GtkCTree     *ctree,
+		GtkCTreeNode *node)
+{
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+
+  if (!node) 
+    return NULL;
+
+  while (GTK_CTREE_ROW (node)->sibling)
+    node = GTK_CTREE_ROW (node)->sibling;
+  
+  if (GTK_CTREE_ROW (node)->children)
+    return gtk_ctree_last (ctree, GTK_CTREE_ROW (node)->children);
+  
+  return node;
+}
+
+GtkCTreeNode *
+gtk_ctree_find_node_ptr (GtkCTree    *ctree,
+			 GtkCTreeRow *ctree_row)
+{
+  GtkCTreeNode *node;
+  
+  g_return_val_if_fail (ctree != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), FALSE);
+  g_return_val_if_fail (ctree_row != NULL, FALSE);
+  
+  if (ctree_row->parent)
+    node = GTK_CTREE_ROW(ctree_row->parent)->children;
+  else
+    node = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  while (GTK_CTREE_ROW (node) != ctree_row)
+    node = GTK_CTREE_ROW (node)->sibling;
+  
+  return node;
+}
+
+GtkCTreeNode *
+gtk_ctree_node_nth (GtkCTree *ctree,
+		    guint     row)
+{
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+
+  if ((row < 0) || (row >= GTK_CLIST(ctree)->rows))
+    return NULL;
+ 
+  return GTK_CTREE_NODE (g_list_nth (GTK_CLIST (ctree)->row_list, row));
+}
+
+gboolean
+gtk_ctree_find (GtkCTree     *ctree,
+		GtkCTreeNode *node,
+		GtkCTreeNode *child)
+{
+  if (!child)
+    return FALSE;
+
+  if (!node)
+    node = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  while (node)
+    {
+      if (node == child) 
+	return TRUE;
+      if (GTK_CTREE_ROW (node)->children)
+	{
+	  if (gtk_ctree_find (ctree, GTK_CTREE_ROW (node)->children, child))
+	    return TRUE;
+	}
+      node = GTK_CTREE_ROW (node)->sibling;
+    }
+  return FALSE;
+}
+
+gboolean
+gtk_ctree_is_ancestor (GtkCTree     *ctree,
+		       GtkCTreeNode *node,
+		       GtkCTreeNode *child)
+{
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), FALSE);
+  g_return_val_if_fail (node != NULL, FALSE);
+
+  if (GTK_CTREE_ROW (node)->children)
+    return gtk_ctree_find (ctree, GTK_CTREE_ROW (node)->children, child);
+
+  return FALSE;
+}
+
+GtkCTreeNode *
+gtk_ctree_find_by_row_data (GtkCTree     *ctree,
+			    GtkCTreeNode *node,
+			    gpointer      data)
+{
+  GtkCTreeNode *work;
+  
+  if (!node)
+    node = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+  
+  while (node)
+    {
+      if (GTK_CTREE_ROW (node)->row.data == data) 
+	return node;
+      if (GTK_CTREE_ROW (node)->children &&
+	  (work = gtk_ctree_find_by_row_data 
+	   (ctree, GTK_CTREE_ROW (node)->children, data)))
+	return work;
+      node = GTK_CTREE_ROW (node)->sibling;
+    }
+  return NULL;
+}
+
+GList *
+gtk_ctree_find_all_by_row_data (GtkCTree     *ctree,
+				GtkCTreeNode *node,
+				gpointer      data)
+{
+  GList *list = NULL;
+
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+
+  /* if node == NULL then look in the whole tree */
+  if (!node)
+    node = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  while (node)
+    {
+      if (GTK_CTREE_ROW (node)->row.data == data)
+        list = g_list_append (list, node);
+
+      if (GTK_CTREE_ROW (node)->children)
+        {
+	  GList *sub_list;
+
+          sub_list = gtk_ctree_find_all_by_row_data (ctree,
+						     GTK_CTREE_ROW
+						     (node)->children,
+						     data);
+          list = g_list_concat (list, sub_list);
+        }
+      node = GTK_CTREE_ROW (node)->sibling;
+    }
+  return list;
+}
+
+GtkCTreeNode *
+gtk_ctree_find_by_row_data_custom (GtkCTree     *ctree,
+				   GtkCTreeNode *node,
+				   gpointer      data,
+				   GCompareFunc  func)
+{
+  GtkCTreeNode *work;
+
+  g_return_val_if_fail (func != NULL, NULL);
+
+  if (!node)
+    node = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  while (node)
+    {
+      if (!func (GTK_CTREE_ROW (node)->row.data, data))
+	return node;
+      if (GTK_CTREE_ROW (node)->children &&
+	  (work = gtk_ctree_find_by_row_data_custom
+	   (ctree, GTK_CTREE_ROW (node)->children, data, func)))
+	return work;
+      node = GTK_CTREE_ROW (node)->sibling;
+    }
+  return NULL;
+}
+
+GList *
+gtk_ctree_find_all_by_row_data_custom (GtkCTree     *ctree,
+				       GtkCTreeNode *node,
+				       gpointer      data,
+				       GCompareFunc  func)
+{
+  GList *list = NULL;
+
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+  g_return_val_if_fail (func != NULL, NULL);
+
+  /* if node == NULL then look in the whole tree */
+  if (!node)
+    node = GTK_CTREE_NODE (GTK_CLIST (ctree)->row_list);
+
+  while (node)
+    {
+      if (!func (GTK_CTREE_ROW (node)->row.data, data))
+        list = g_list_append (list, node);
+
+      if (GTK_CTREE_ROW (node)->children)
+        {
+	  GList *sub_list;
+
+          sub_list = gtk_ctree_find_all_by_row_data_custom (ctree,
+							    GTK_CTREE_ROW
+							    (node)->children,
+							    data,
+							    func);
+          list = g_list_concat (list, sub_list);
+        }
+      node = GTK_CTREE_ROW (node)->sibling;
+    }
+  return list;
+}
+
+gboolean
+gtk_ctree_is_hot_spot (GtkCTree *ctree, 
+		       gint      x, 
+		       gint      y)
+{
+  GtkCTreeNode *node;
+  gint column;
+  gint row;
+  
+  g_return_val_if_fail (ctree != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), FALSE);
+
+  if (gtk_clist_get_selection_info (GTK_CLIST (ctree), x, y, &row, &column))
+    if ((node = GTK_CTREE_NODE(g_list_nth (GTK_CLIST (ctree)->row_list, row))))
+      return ctree_is_hot_spot (ctree, node, row, x, y);
+
+  return FALSE;
+}
+
+
+/***********************************************************
+ *   Tree signals : move, expand, collapse, (un)select     *
+ ***********************************************************/
+
+
+void
+gtk_ctree_move (GtkCTree     *ctree,
+		GtkCTreeNode *node,
+		GtkCTreeNode *new_parent, 
+		GtkCTreeNode *new_sibling)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+  
+  gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_MOVE], node,
+		   new_parent, new_sibling);
+}
+
+void
+gtk_ctree_expand (GtkCTree     *ctree,
+		  GtkCTreeNode *node)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+  
+  if (GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_EXPAND], node);
+}
+
+void 
+gtk_ctree_expand_recursive (GtkCTree     *ctree,
+			    GtkCTreeNode *node)
+{
+  GtkCList *clist;
+  gboolean thaw = FALSE;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  clist = GTK_CLIST (ctree);
+
+  if (node && GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  if (CLIST_UNFROZEN (clist) && (!node || gtk_ctree_is_viewable (ctree, node)))
+    {
+      gtk_clist_freeze (clist);
+      thaw = TRUE;
+    }
+
+  gtk_ctree_post_recursive (ctree, node, GTK_CTREE_FUNC (tree_expand), NULL);
+
+  if (thaw)
+    gtk_clist_thaw (clist);
+}
+
+void 
+gtk_ctree_expand_to_depth (GtkCTree     *ctree,
+			   GtkCTreeNode *node,
+			   gint          depth)
+{
+  GtkCList *clist;
+  gboolean thaw = FALSE;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  clist = GTK_CLIST (ctree);
+
+  if (node && GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  if (CLIST_UNFROZEN (clist) && (!node || gtk_ctree_is_viewable (ctree, node)))
+    {
+      gtk_clist_freeze (clist);
+      thaw = TRUE;
+    }
+
+  gtk_ctree_post_recursive_to_depth (ctree, node, depth,
+				     GTK_CTREE_FUNC (tree_expand), NULL);
+
+  if (thaw)
+    gtk_clist_thaw (clist);
+}
+
+void
+gtk_ctree_collapse (GtkCTree     *ctree,
+		    GtkCTreeNode *node)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+  
+  if (GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_COLLAPSE], node);
+}
+
+void 
+gtk_ctree_collapse_recursive (GtkCTree     *ctree,
+			      GtkCTreeNode *node)
+{
+  GtkCList *clist;
+  gboolean thaw = FALSE;
+  gint i;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  if (node && GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  if (CLIST_UNFROZEN (clist) && (!node || gtk_ctree_is_viewable (ctree, node)))
+    {
+      gtk_clist_freeze (clist);
+      thaw = TRUE;
+    }
+
+  GTK_CLIST_SET_FLAG (clist, CLIST_AUTO_RESIZE_BLOCKED);
+  gtk_ctree_post_recursive (ctree, node, GTK_CTREE_FUNC (tree_collapse), NULL);
+  GTK_CLIST_UNSET_FLAG (clist, CLIST_AUTO_RESIZE_BLOCKED);
+  for (i = 0; i < clist->columns; i++)
+    if (clist->column[i].auto_resize)
+      gtk_clist_set_column_width (clist, i,
+				  gtk_clist_optimal_column_width (clist, i));
+
+  if (thaw)
+    gtk_clist_thaw (clist);
+}
+
+void 
+gtk_ctree_collapse_to_depth (GtkCTree     *ctree,
+			     GtkCTreeNode *node,
+			     gint          depth)
+{
+  GtkCList *clist;
+  gboolean thaw = FALSE;
+  gint i;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  if (node && GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  if (CLIST_UNFROZEN (clist) && (!node || gtk_ctree_is_viewable (ctree, node)))
+    {
+      gtk_clist_freeze (clist);
+      thaw = TRUE;
+    }
+
+  GTK_CLIST_SET_FLAG (clist, CLIST_AUTO_RESIZE_BLOCKED);
+  gtk_ctree_post_recursive_to_depth (ctree, node, depth,
+				     GTK_CTREE_FUNC (tree_collapse_to_depth),
+				     GINT_TO_POINTER (depth));
+  GTK_CLIST_UNSET_FLAG (clist, CLIST_AUTO_RESIZE_BLOCKED);
+  for (i = 0; i < clist->columns; i++)
+    if (clist->column[i].auto_resize)
+      gtk_clist_set_column_width (clist, i,
+				  gtk_clist_optimal_column_width (clist, i));
+
+  if (thaw)
+    gtk_clist_thaw (clist);
+}
+
+void
+gtk_ctree_toggle_expansion (GtkCTree     *ctree,
+			    GtkCTreeNode *node)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+  
+  if (GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  tree_toggle_expansion (ctree, node, NULL);
+}
+
+void 
+gtk_ctree_toggle_expansion_recursive (GtkCTree     *ctree,
+				      GtkCTreeNode *node)
+{
+  GtkCList *clist;
+  gboolean thaw = FALSE;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  
+  if (node && GTK_CTREE_ROW (node)->is_leaf)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  if (CLIST_UNFROZEN (clist) && (!node || gtk_ctree_is_viewable (ctree, node)))
+    {
+      gtk_clist_freeze (clist);
+      thaw = TRUE;
+    }
+  
+  gtk_ctree_post_recursive (ctree, node,
+			    GTK_CTREE_FUNC (tree_toggle_expansion), NULL);
+
+  if (thaw)
+    gtk_clist_thaw (clist);
+}
+
+void
+gtk_ctree_select (GtkCTree     *ctree, 
+		  GtkCTreeNode *node)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  if (GTK_CTREE_ROW (node)->row.selectable)
+    gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_SELECT_ROW],
+		     node, -1);
+}
+
+void
+gtk_ctree_unselect (GtkCTree     *ctree, 
+		    GtkCTreeNode *node)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  gtk_signal_emit (GTK_OBJECT (ctree), ctree_signals[TREE_UNSELECT_ROW],
+		   node, -1);
+}
+
+void
+gtk_ctree_select_recursive (GtkCTree     *ctree, 
+			    GtkCTreeNode *node)
+{
+  gtk_ctree_real_select_recursive (ctree, node, TRUE);
+}
+
+void
+gtk_ctree_unselect_recursive (GtkCTree     *ctree, 
+			      GtkCTreeNode *node)
+{
+  gtk_ctree_real_select_recursive (ctree, node, FALSE);
+}
+
+void
+gtk_ctree_real_select_recursive (GtkCTree     *ctree, 
+				 GtkCTreeNode *node, 
+				 gint          state)
+{
+  GtkCList *clist;
+  gboolean thaw = FALSE;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  clist = GTK_CLIST (ctree);
+
+  if ((state && 
+       (clist->selection_mode ==  GTK_SELECTION_BROWSE ||
+	clist->selection_mode == GTK_SELECTION_SINGLE)) ||
+      (!state && clist->selection_mode ==  GTK_SELECTION_BROWSE))
+    return;
+
+  if (CLIST_UNFROZEN (clist) && (!node || gtk_ctree_is_viewable (ctree, node)))
+    {
+      gtk_clist_freeze (clist);
+      thaw = TRUE;
+    }
+
+  if (clist->selection_mode == GTK_SELECTION_EXTENDED)
+    {
+      GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+      
+      g_list_free (clist->undo_selection);
+      g_list_free (clist->undo_unselection);
+      clist->undo_selection = NULL;
+      clist->undo_unselection = NULL;
+    }
+
+  if (state)
+    gtk_ctree_post_recursive (ctree, node,
+			      GTK_CTREE_FUNC (tree_select), NULL);
+  else 
+    gtk_ctree_post_recursive (ctree, node,
+			      GTK_CTREE_FUNC (tree_unselect), NULL);
+  
+  if (thaw)
+    gtk_clist_thaw (clist);
+}
+
+
+/***********************************************************
+ *           Analogons of GtkCList functions               *
+ ***********************************************************/
+
+
+void 
+gtk_ctree_node_set_text (GtkCTree     *ctree,
+			 GtkCTreeNode *node,
+			 gint          column,
+			 const gchar  *text)
+{
+  GtkCList *clist;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return;
+  
+  clist = GTK_CLIST (ctree);
+
+  GTK_CLIST_CLASS_FW (clist)->set_cell_contents
+    (clist, &(GTK_CTREE_ROW(node)->row), column, GTK_CELL_TEXT,
+     text, 0, NULL, NULL);
+
+  tree_draw_node (ctree, node);
+}
+
+void 
+gtk_ctree_node_set_pixmap (GtkCTree     *ctree,
+			   GtkCTreeNode *node,
+			   gint          column,
+			   GdkPixmap    *pixmap,
+			   GdkBitmap    *mask)
+{
+  GtkCList *clist;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (pixmap != NULL);
+
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return;
+
+  gdk_pixmap_ref (pixmap);
+  if (mask) 
+    gdk_pixmap_ref (mask);
+
+  clist = GTK_CLIST (ctree);
+
+  GTK_CLIST_CLASS_FW (clist)->set_cell_contents
+    (clist, &(GTK_CTREE_ROW (node)->row), column, GTK_CELL_PIXMAP,
+     NULL, 0, pixmap, mask);
+
+  tree_draw_node (ctree, node);
+}
+
+void 
+gtk_ctree_node_set_pixtext (GtkCTree     *ctree,
+			    GtkCTreeNode *node,
+			    gint          column,
+			    const gchar  *text,
+			    guint8        spacing,
+			    GdkPixmap    *pixmap,
+			    GdkBitmap    *mask)
+{
+  GtkCList *clist;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+  if (column != ctree->tree_column)
+    g_return_if_fail (pixmap != NULL);
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  if (pixmap)
+    {
+      gdk_pixmap_ref (pixmap);
+      if (mask) 
+	gdk_pixmap_ref (mask);
+    }
+
+  GTK_CLIST_CLASS_FW (clist)->set_cell_contents
+    (clist, &(GTK_CTREE_ROW (node)->row), column, GTK_CELL_PIXTEXT,
+     text, spacing, pixmap, mask);
+
+  tree_draw_node (ctree, node);
+}
+
+void 
+gtk_ctree_set_node_info (GtkCTree     *ctree,
+			 GtkCTreeNode *node,
+			 const gchar  *text,
+			 guint8        spacing,
+			 GdkPixmap    *pixmap_closed,
+			 GdkBitmap    *mask_closed,
+			 GdkPixmap    *pixmap_opened,
+			 GdkBitmap    *mask_opened,
+			 gboolean      is_leaf,
+			 gboolean      expanded)
+{
+  gboolean old_leaf;
+  gboolean old_expanded;
+ 
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  old_leaf = GTK_CTREE_ROW (node)->is_leaf;
+  old_expanded = GTK_CTREE_ROW (node)->expanded;
+
+  if (is_leaf && GTK_CTREE_ROW (node)->children)
+    {
+      GtkCTreeNode *work;
+      GtkCTreeNode *ptr;
+      
+      work = GTK_CTREE_ROW (node)->children;
+      while (work)
+	{
+	  ptr = work;
+	  work = GTK_CTREE_ROW(work)->sibling;
+	  gtk_ctree_remove_node (ctree, ptr);
+	}
+    }
+
+  set_node_info (ctree, node, text, spacing, pixmap_closed, mask_closed,
+		 pixmap_opened, mask_opened, is_leaf, expanded);
+
+  if (!is_leaf && !old_leaf)
+    {
+      GTK_CTREE_ROW (node)->expanded = old_expanded;
+      if (expanded && !old_expanded)
+	gtk_ctree_expand (ctree, node);
+      else if (!expanded && old_expanded)
+	gtk_ctree_collapse (ctree, node);
+    }
+
+  GTK_CTREE_ROW (node)->expanded = (is_leaf) ? FALSE : expanded;
+  
+  tree_draw_node (ctree, node);
+}
+
+void
+gtk_ctree_node_set_shift (GtkCTree     *ctree,
+			  GtkCTreeNode *node,
+			  gint          column,
+			  gint          vertical,
+			  gint          horizontal)
+{
+  GtkCList *clist;
+  GtkRequisition requisition;
+  gboolean visible = FALSE;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  if (clist->column[column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    {
+      visible = gtk_ctree_is_viewable (ctree, node);
+      if (visible)
+	GTK_CLIST_CLASS_FW (clist)->cell_size_request
+	  (clist, &GTK_CTREE_ROW (node)->row, column, &requisition);
+    }
+
+  GTK_CTREE_ROW (node)->row.cell[column].vertical   = vertical;
+  GTK_CTREE_ROW (node)->row.cell[column].horizontal = horizontal;
+
+  if (visible)
+    column_auto_resize (clist, &GTK_CTREE_ROW (node)->row,
+			column, requisition.width);
+
+  tree_draw_node (ctree, node);
+}
+
+static void
+remove_grab (GtkCList *clist)
+{
+  if (gdk_pointer_is_grabbed () && GTK_WIDGET_HAS_GRAB (clist))
+    {
+      gtk_grab_remove (GTK_WIDGET (clist));
+      gdk_pointer_ungrab (GDK_CURRENT_TIME);
+    }
+
+  if (clist->htimer)
+    {
+      gtk_timeout_remove (clist->htimer);
+      clist->htimer = 0;
+    }
+
+  if (clist->vtimer)
+    {
+      gtk_timeout_remove (clist->vtimer);
+      clist->vtimer = 0;
+    }
+}
+
+void
+gtk_ctree_node_set_selectable (GtkCTree     *ctree,
+			       GtkCTreeNode *node,
+			       gboolean      selectable)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  if (selectable == GTK_CTREE_ROW (node)->row.selectable)
+    return;
+
+  GTK_CTREE_ROW (node)->row.selectable = selectable;
+
+  if (!selectable && GTK_CTREE_ROW (node)->row.state == GTK_STATE_SELECTED)
+    {
+      GtkCList *clist;
+
+      clist = GTK_CLIST (ctree);
+
+      if (clist->anchor >= 0 &&
+	  clist->selection_mode == GTK_SELECTION_EXTENDED)
+	{
+	  clist->drag_button = 0;
+	  remove_grab (clist);
+
+	  GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+	}
+      gtk_ctree_unselect (ctree, node);
+    }      
+}
+
+gboolean
+gtk_ctree_node_get_selectable (GtkCTree     *ctree,
+			       GtkCTreeNode *node)
+{
+  g_return_val_if_fail (node != NULL, FALSE);
+
+  return GTK_CTREE_ROW (node)->row.selectable;
+}
+
+GtkCellType 
+gtk_ctree_node_get_cell_type (GtkCTree     *ctree,
+			      GtkCTreeNode *node,
+			      gint          column)
+{
+  g_return_val_if_fail (ctree != NULL, -1);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), -1);
+  g_return_val_if_fail (node != NULL, -1);
+
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return -1;
+
+  return GTK_CTREE_ROW (node)->row.cell[column].type;
+}
+
+gint
+gtk_ctree_node_get_text (GtkCTree      *ctree,
+			 GtkCTreeNode  *node,
+			 gint           column,
+			 gchar        **text)
+{
+  g_return_val_if_fail (ctree != NULL, 0);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), 0);
+  g_return_val_if_fail (node != NULL, 0);
+
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return 0;
+
+  if (GTK_CTREE_ROW (node)->row.cell[column].type != GTK_CELL_TEXT)
+    return 0;
+
+  if (text)
+    *text = GTK_CELL_TEXT (GTK_CTREE_ROW (node)->row.cell[column])->text;
+
+  return 1;
+}
+
+gint
+gtk_ctree_node_get_pixmap (GtkCTree     *ctree,
+			   GtkCTreeNode *node,
+			   gint          column,
+			   GdkPixmap   **pixmap,
+			   GdkBitmap   **mask)
+{
+  g_return_val_if_fail (ctree != NULL, 0);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), 0);
+  g_return_val_if_fail (node != NULL, 0);
+
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return 0;
+
+  if (GTK_CTREE_ROW (node)->row.cell[column].type != GTK_CELL_PIXMAP)
+    return 0;
+
+  if (pixmap)
+    *pixmap = GTK_CELL_PIXMAP (GTK_CTREE_ROW(node)->row.cell[column])->pixmap;
+  if (mask)
+    *mask = GTK_CELL_PIXMAP (GTK_CTREE_ROW (node)->row.cell[column])->mask;
+
+  return 1;
+}
+
+gint
+gtk_ctree_node_get_pixtext (GtkCTree      *ctree,
+			    GtkCTreeNode  *node,
+			    gint           column,
+			    gchar        **text,
+			    guint8        *spacing,
+			    GdkPixmap    **pixmap,
+			    GdkBitmap    **mask)
+{
+  g_return_val_if_fail (ctree != NULL, 0);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), 0);
+  g_return_val_if_fail (node != NULL, 0);
+  
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return 0;
+  
+  if (GTK_CTREE_ROW (node)->row.cell[column].type != GTK_CELL_PIXTEXT)
+    return 0;
+  
+  if (text)
+    *text = GTK_CELL_PIXTEXT (GTK_CTREE_ROW (node)->row.cell[column])->text;
+  if (spacing)
+    *spacing = GTK_CELL_PIXTEXT (GTK_CTREE_ROW 
+				 (node)->row.cell[column])->spacing;
+  if (pixmap)
+    *pixmap = GTK_CELL_PIXTEXT (GTK_CTREE_ROW 
+				(node)->row.cell[column])->pixmap;
+  if (mask)
+    *mask = GTK_CELL_PIXTEXT (GTK_CTREE_ROW (node)->row.cell[column])->mask;
+  
+  return 1;
+}
+
+gint
+gtk_ctree_get_node_info (GtkCTree      *ctree,
+			 GtkCTreeNode  *node,
+			 gchar        **text,
+			 guint8        *spacing,
+			 GdkPixmap    **pixmap_closed,
+			 GdkBitmap    **mask_closed,
+			 GdkPixmap    **pixmap_opened,
+			 GdkBitmap    **mask_opened,
+			 gboolean      *is_leaf,
+			 gboolean      *expanded)
+{
+  g_return_val_if_fail (ctree != NULL, 0);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), 0);
+  g_return_val_if_fail (node != NULL, 0);
+  
+  if (text)
+    *text = GTK_CELL_PIXTEXT 
+      (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->text;
+  if (spacing)
+    *spacing = GTK_CELL_PIXTEXT 
+      (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->spacing;
+  if (pixmap_closed)
+    *pixmap_closed = GTK_CTREE_ROW (node)->pixmap_closed;
+  if (mask_closed)
+    *mask_closed = GTK_CTREE_ROW (node)->mask_closed;
+  if (pixmap_opened)
+    *pixmap_opened = GTK_CTREE_ROW (node)->pixmap_opened;
+  if (mask_opened)
+    *mask_opened = GTK_CTREE_ROW (node)->mask_opened;
+  if (is_leaf)
+    *is_leaf = GTK_CTREE_ROW (node)->is_leaf;
+  if (expanded)
+    *expanded = GTK_CTREE_ROW (node)->expanded;
+  
+  return 1;
+}
+
+void
+gtk_ctree_node_set_cell_style (GtkCTree     *ctree,
+			       GtkCTreeNode *node,
+			       gint          column,
+			       GtkStyle     *style)
+{
+  GtkCList *clist;
+  GtkRequisition requisition;
+  gboolean visible = FALSE;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  clist = GTK_CLIST (ctree);
+
+  if (column < 0 || column >= clist->columns)
+    return;
+
+  if (GTK_CTREE_ROW (node)->row.cell[column].style == style)
+    return;
+
+  if (clist->column[column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    {
+      visible = gtk_ctree_is_viewable (ctree, node);
+      if (visible)
+	GTK_CLIST_CLASS_FW (clist)->cell_size_request
+	  (clist, &GTK_CTREE_ROW (node)->row, column, &requisition);
+    }
+
+  if (GTK_CTREE_ROW (node)->row.cell[column].style)
+    {
+      if (GTK_WIDGET_REALIZED (ctree))
+        gtk_style_detach (GTK_CTREE_ROW (node)->row.cell[column].style);
+      gtk_style_unref (GTK_CTREE_ROW (node)->row.cell[column].style);
+    }
+
+  GTK_CTREE_ROW (node)->row.cell[column].style = style;
+
+  if (GTK_CTREE_ROW (node)->row.cell[column].style)
+    {
+      gtk_style_ref (GTK_CTREE_ROW (node)->row.cell[column].style);
+      
+      if (GTK_WIDGET_REALIZED (ctree))
+        GTK_CTREE_ROW (node)->row.cell[column].style =
+	  gtk_style_attach (GTK_CTREE_ROW (node)->row.cell[column].style,
+			    clist->clist_window);
+    }
+
+  if (visible)
+    column_auto_resize (clist, &GTK_CTREE_ROW (node)->row, column,
+			requisition.width);
+
+  tree_draw_node (ctree, node);
+}
+
+GtkStyle *
+gtk_ctree_node_get_cell_style (GtkCTree     *ctree,
+			       GtkCTreeNode *node,
+			       gint          column)
+{
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+  g_return_val_if_fail (node != NULL, NULL);
+
+  if (column < 0 || column >= GTK_CLIST (ctree)->columns)
+    return NULL;
+
+  return GTK_CTREE_ROW (node)->row.cell[column].style;
+}
+
+void
+gtk_ctree_node_set_row_style (GtkCTree     *ctree,
+			      GtkCTreeNode *node,
+			      GtkStyle     *style)
+{
+  GtkCList *clist;
+  GtkRequisition requisition;
+  gboolean visible;
+  gint *old_width = NULL;
+  gint i;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  clist = GTK_CLIST (ctree);
+
+  if (GTK_CTREE_ROW (node)->row.style == style)
+    return;
+  
+  visible = gtk_ctree_is_viewable (ctree, node);
+  if (visible && !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    {
+      old_width = g_new (gint, clist->columns);
+      for (i = 0; i < clist->columns; i++)
+	if (clist->column[i].auto_resize)
+	  {
+	    GTK_CLIST_CLASS_FW (clist)->cell_size_request
+	      (clist, &GTK_CTREE_ROW (node)->row, i, &requisition);
+	    old_width[i] = requisition.width;
+	  }
+    }
+
+  if (GTK_CTREE_ROW (node)->row.style)
+    {
+      if (GTK_WIDGET_REALIZED (ctree))
+        gtk_style_detach (GTK_CTREE_ROW (node)->row.style);
+      gtk_style_unref (GTK_CTREE_ROW (node)->row.style);
+    }
+
+  GTK_CTREE_ROW (node)->row.style = style;
+
+  if (GTK_CTREE_ROW (node)->row.style)
+    {
+      gtk_style_ref (GTK_CTREE_ROW (node)->row.style);
+      
+      if (GTK_WIDGET_REALIZED (ctree))
+        GTK_CTREE_ROW (node)->row.style =
+	  gtk_style_attach (GTK_CTREE_ROW (node)->row.style,
+			    clist->clist_window);
+    }
+
+  if (visible && !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    {
+      for (i = 0; i < clist->columns; i++)
+	if (clist->column[i].auto_resize)
+	  column_auto_resize (clist, &GTK_CTREE_ROW (node)->row, i,
+			      old_width[i]);
+      g_free (old_width);
+    }
+  tree_draw_node (ctree, node);
+}
+
+GtkStyle *
+gtk_ctree_node_get_row_style (GtkCTree     *ctree,
+			      GtkCTreeNode *node)
+{
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+  g_return_val_if_fail (node != NULL, NULL);
+
+  return GTK_CTREE_ROW (node)->row.style;
+}
+
+void
+gtk_ctree_node_set_foreground (GtkCTree     *ctree,
+			       GtkCTreeNode *node,
+			       GdkColor     *color)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  if (color)
+    {
+      GTK_CTREE_ROW (node)->row.foreground = *color;
+      GTK_CTREE_ROW (node)->row.fg_set = TRUE;
+      if (GTK_WIDGET_REALIZED (ctree))
+	gdk_color_alloc (gtk_widget_get_colormap (GTK_WIDGET (ctree)),
+			 &GTK_CTREE_ROW (node)->row.foreground);
+    }
+  else
+    GTK_CTREE_ROW (node)->row.fg_set = FALSE;
+
+  tree_draw_node (ctree, node);
+}
+
+void
+gtk_ctree_node_set_background (GtkCTree     *ctree,
+			       GtkCTreeNode *node,
+			       GdkColor     *color)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  if (color)
+    {
+      GTK_CTREE_ROW (node)->row.background = *color;
+      GTK_CTREE_ROW (node)->row.bg_set = TRUE;
+      if (GTK_WIDGET_REALIZED (ctree))
+	gdk_color_alloc (gtk_widget_get_colormap (GTK_WIDGET (ctree)),
+			 &GTK_CTREE_ROW (node)->row.background);
+    }
+  else
+    GTK_CTREE_ROW (node)->row.bg_set = FALSE;
+
+  tree_draw_node (ctree, node);
+}
+
+void
+gtk_ctree_node_set_row_data (GtkCTree     *ctree,
+			     GtkCTreeNode *node,
+			     gpointer      data)
+{
+  gtk_ctree_node_set_row_data_full (ctree, node, data, NULL);
+}
+
+void
+gtk_ctree_node_set_row_data_full (GtkCTree         *ctree,
+				  GtkCTreeNode     *node,
+				  gpointer          data,
+				  GtkDestroyNotify  destroy)
+{
+  GtkDestroyNotify dnotify;
+  gpointer ddata;
+  
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (node != NULL);
+
+  dnotify = GTK_CTREE_ROW (node)->row.destroy;
+  ddata = GTK_CTREE_ROW (node)->row.data;
+  
+  GTK_CTREE_ROW (node)->row.data = data;
+  GTK_CTREE_ROW (node)->row.destroy = destroy;
+
+  if (dnotify)
+    dnotify (ddata);
+}
+
+gpointer
+gtk_ctree_node_get_row_data (GtkCTree     *ctree,
+			     GtkCTreeNode *node)
+{
+  g_return_val_if_fail (ctree != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), NULL);
+
+  return node ? GTK_CTREE_ROW (node)->row.data : NULL;
+}
+
+void
+gtk_ctree_node_moveto (GtkCTree     *ctree,
+		       GtkCTreeNode *node,
+		       gint          column,
+		       gfloat        row_align,
+		       gfloat        col_align)
+{
+  gint row = -1;
+  GtkCList *clist;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  clist = GTK_CLIST (ctree);
+
+  while (node && !gtk_ctree_is_viewable (ctree, node))
+    node = GTK_CTREE_ROW (node)->parent;
+
+  if (node)
+    row = g_list_position (clist->row_list, (GList *)node);
+  
+  gtk_clist_moveto (clist, row, column, row_align, col_align);
+}
+
+GtkVisibility gtk_ctree_node_is_visible (GtkCTree     *ctree,
+                                         GtkCTreeNode *node)
+{
+  gint row;
+  
+  g_return_val_if_fail (ctree != NULL, 0);
+  g_return_val_if_fail (node != NULL, 0);
+  
+  row = g_list_position (GTK_CLIST (ctree)->row_list, (GList*) node);
+  return gtk_clist_row_is_visible (GTK_CLIST (ctree), row);
+}
+
+
+/***********************************************************
+ *             GtkCTree specific functions                 *
+ ***********************************************************/
+
+void
+gtk_ctree_set_indent (GtkCTree *ctree, 
+                      gint      indent)
+{
+  GtkCList *clist;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (indent >= 0);
+
+  if (indent == ctree->tree_indent)
+    return;
+
+  clist = GTK_CLIST (ctree);
+  ctree->tree_indent = indent;
+
+  if (clist->column[ctree->tree_column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    gtk_clist_set_column_width
+      (clist, ctree->tree_column,
+       gtk_clist_optimal_column_width (clist, ctree->tree_column));
+  else
+    CLIST_REFRESH (ctree);
+}
+
+void
+gtk_ctree_set_spacing (GtkCTree *ctree, 
+		       gint      spacing)
+{
+  GtkCList *clist;
+  gint old_spacing;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+  g_return_if_fail (spacing >= 0);
+
+  if (spacing == ctree->tree_spacing)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  old_spacing = ctree->tree_spacing;
+  ctree->tree_spacing = spacing;
+
+  if (clist->column[ctree->tree_column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    gtk_clist_set_column_width (clist, ctree->tree_column,
+				clist->column[ctree->tree_column].width +
+				spacing - old_spacing);
+  else
+    CLIST_REFRESH (ctree);
+}
+
+void
+gtk_ctree_set_show_stub (GtkCTree *ctree, 
+			 gboolean  show_stub)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  show_stub = show_stub != FALSE;
+
+  if (show_stub != ctree->show_stub)
+    {
+      GtkCList *clist;
+
+      clist = GTK_CLIST (ctree);
+      ctree->show_stub = show_stub;
+
+      if (CLIST_UNFROZEN (clist) && clist->rows &&
+	  gtk_clist_row_is_visible (clist, 0) != GTK_VISIBILITY_NONE)
+	GTK_CLIST_CLASS_FW (clist)->draw_row
+	  (clist, NULL, 0, GTK_CLIST_ROW (clist->row_list));
+    }
+}
+
+void 
+gtk_ctree_set_line_style (GtkCTree          *ctree, 
+			  GtkCTreeLineStyle  line_style)
+{
+  GtkCList *clist;
+  GtkCTreeLineStyle old_style;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  if (line_style == ctree->line_style)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  old_style = ctree->line_style;
+  ctree->line_style = line_style;
+
+  if (clist->column[ctree->tree_column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    {
+      if (old_style == GTK_CTREE_LINES_TABBED)
+	gtk_clist_set_column_width
+	  (clist, ctree->tree_column,
+	   clist->column[ctree->tree_column].width - 3);
+      else if (line_style == GTK_CTREE_LINES_TABBED)
+	gtk_clist_set_column_width
+	  (clist, ctree->tree_column,
+	   clist->column[ctree->tree_column].width + 3);
+    }
+
+  if (GTK_WIDGET_REALIZED (ctree))
+    {
+      switch (line_style)
+	{
+	case GTK_CTREE_LINES_SOLID:
+	  if (GTK_WIDGET_REALIZED (ctree))
+	    gdk_gc_set_line_attributes (ctree->lines_gc, 1, GDK_LINE_SOLID, 
+					None, None);
+	  break;
+	case GTK_CTREE_LINES_DOTTED:
+	  if (GTK_WIDGET_REALIZED (ctree))
+	    gdk_gc_set_line_attributes (ctree->lines_gc, 1, 
+					GDK_LINE_ON_OFF_DASH, None, None);
+	  gdk_gc_set_dashes (ctree->lines_gc, 0, "\1\1", 2);
+	  break;
+	case GTK_CTREE_LINES_TABBED:
+	  if (GTK_WIDGET_REALIZED (ctree))
+	    gdk_gc_set_line_attributes (ctree->lines_gc, 1, GDK_LINE_SOLID, 
+					None, None);
+	  break;
+	case GTK_CTREE_LINES_NONE:
+	  break;
+	default:
+	  return;
+	}
+      CLIST_REFRESH (ctree);
+    }
+}
+
+void 
+gtk_ctree_set_expander_style (GtkCTree              *ctree, 
+			      GtkCTreeExpanderStyle  expander_style)
+{
+  GtkCList *clist;
+  GtkCTreeExpanderStyle old_style;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  if (expander_style == ctree->expander_style)
+    return;
+
+  clist = GTK_CLIST (ctree);
+
+  old_style = ctree->expander_style;
+  ctree->expander_style = expander_style;
+
+  if (clist->column[ctree->tree_column].auto_resize &&
+      !GTK_CLIST_AUTO_RESIZE_BLOCKED (clist))
+    {
+      gint new_width;
+
+      new_width = clist->column[ctree->tree_column].width;
+      switch (old_style)
+	{
+	case GTK_CTREE_EXPANDER_NONE:
+	  break;
+	case GTK_CTREE_EXPANDER_TRIANGLE:
+	  new_width -= PM_SIZE + 3;
+	  break;
+	case GTK_CTREE_EXPANDER_SQUARE:
+	case GTK_CTREE_EXPANDER_CIRCULAR:
+	  new_width -= PM_SIZE + 1;
+	  break;
+	}
+
+      switch (expander_style)
+	{
+	case GTK_CTREE_EXPANDER_NONE:
+	  break;
+	case GTK_CTREE_EXPANDER_TRIANGLE:
+	  new_width += PM_SIZE + 3;
+	  break;
+	case GTK_CTREE_EXPANDER_SQUARE:
+	case GTK_CTREE_EXPANDER_CIRCULAR:
+	  new_width += PM_SIZE + 1;
+	  break;
+	}
+
+      gtk_clist_set_column_width (clist, ctree->tree_column, new_width);
+    }
+
+  if (GTK_WIDGET_DRAWABLE (clist))
+    CLIST_REFRESH (clist);
+}
+
+
+/***********************************************************
+ *             Tree sorting functions                      *
+ ***********************************************************/
+
+
+static void
+tree_sort (GtkCTree     *ctree,
+	   GtkCTreeNode *node,
+	   gpointer      data)
+{
+  GtkCTreeNode *list_start;
+  GtkCTreeNode *cmp;
+  GtkCTreeNode *work;
+  GtkCList *clist;
+
+  clist = GTK_CLIST (ctree);
+
+  if (node)
+    list_start = GTK_CTREE_ROW (node)->children;
+  else
+    list_start = GTK_CTREE_NODE (clist->row_list);
+
+  while (list_start)
+    {
+      cmp = list_start;
+      work = GTK_CTREE_ROW (cmp)->sibling;
+      while (work)
+	{
+	  if (clist->sort_type == GTK_SORT_ASCENDING)
+	    {
+	      if (clist->compare 
+		  (clist, GTK_CTREE_ROW (work), GTK_CTREE_ROW (cmp)) < 0)
+		cmp = work;
+	    }
+	  else
+	    {
+	      if (clist->compare 
+		  (clist, GTK_CTREE_ROW (work), GTK_CTREE_ROW (cmp)) > 0)
+		cmp = work;
+	    }
+	  work = GTK_CTREE_ROW (work)->sibling;
+	}
+      if (cmp == list_start)
+	list_start = GTK_CTREE_ROW (cmp)->sibling;
+      else
+	{
+	  gtk_ctree_unlink (ctree, cmp, FALSE);
+	  gtk_ctree_link (ctree, cmp, node, list_start, FALSE);
+	}
+    }
+}
+
+void
+gtk_ctree_sort_recursive (GtkCTree     *ctree, 
+			  GtkCTreeNode *node)
+{
+  GtkCList *clist;
+  GtkCTreeNode *focus_node = NULL;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  clist = GTK_CLIST (ctree);
+
+  gtk_clist_freeze (clist);
+
+  if (clist->selection_mode == GTK_SELECTION_EXTENDED)
+    {
+      GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+      
+      g_list_free (clist->undo_selection);
+      g_list_free (clist->undo_unselection);
+      clist->undo_selection = NULL;
+      clist->undo_unselection = NULL;
+    }
+
+  if (!node || (node && gtk_ctree_is_viewable (ctree, node)))
+    focus_node =
+      GTK_CTREE_NODE (g_list_nth (clist->row_list, clist->focus_row));
+      
+  gtk_ctree_post_recursive (ctree, node, GTK_CTREE_FUNC (tree_sort), NULL);
+
+  if (!node)
+    tree_sort (ctree, NULL, NULL);
+
+  if (focus_node)
+    {
+      clist->focus_row = g_list_position (clist->row_list,(GList *)focus_node);
+      clist->undo_anchor = clist->focus_row;
+    }
+
+  gtk_clist_thaw (clist);
+}
+
+static void
+real_sort_list (GtkCList *clist)
+{
+  gtk_ctree_sort_recursive (GTK_CTREE (clist), NULL);
+}
+
+void
+gtk_ctree_sort_node (GtkCTree     *ctree, 
+		     GtkCTreeNode *node)
+{
+  GtkCList *clist;
+  GtkCTreeNode *focus_node = NULL;
+
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  clist = GTK_CLIST (ctree);
+
+  gtk_clist_freeze (clist);
+
+  if (clist->selection_mode == GTK_SELECTION_EXTENDED)
+    {
+      GTK_CLIST_CLASS_FW (clist)->resync_selection (clist, NULL);
+      
+      g_list_free (clist->undo_selection);
+      g_list_free (clist->undo_unselection);
+      clist->undo_selection = NULL;
+      clist->undo_unselection = NULL;
+    }
+
+  if (!node || (node && gtk_ctree_is_viewable (ctree, node)))
+    focus_node = GTK_CTREE_NODE
+      (g_list_nth (clist->row_list, clist->focus_row));
+
+  tree_sort (ctree, node, NULL);
+
+  if (focus_node)
+    {
+      clist->focus_row = g_list_position (clist->row_list,(GList *)focus_node);
+      clist->undo_anchor = clist->focus_row;
+    }
+
+  gtk_clist_thaw (clist);
+}
+
+/************************************************************************/
+
+static void
+fake_unselect_all (GtkCList *clist,
+		   gint      row)
+{
+  GList *list;
+  GList *focus_node = NULL;
+
+  if (row >= 0 && (focus_node = g_list_nth (clist->row_list, row)))
+    {
+      if (GTK_CTREE_ROW (focus_node)->row.state == GTK_STATE_NORMAL &&
+	  GTK_CTREE_ROW (focus_node)->row.selectable)
+	{
+	  GTK_CTREE_ROW (focus_node)->row.state = GTK_STATE_SELECTED;
+	  
+	  if (CLIST_UNFROZEN (clist) &&
+	      gtk_clist_row_is_visible (clist, row) != GTK_VISIBILITY_NONE)
+	    GTK_CLIST_CLASS_FW (clist)->draw_row (clist, NULL, row,
+						  GTK_CLIST_ROW (focus_node));
+	}  
+    }
+
+  clist->undo_selection = clist->selection;
+  clist->selection = NULL;
+  clist->selection_end = NULL;
+  
+  for (list = clist->undo_selection; list; list = list->next)
+    {
+      if (list->data == focus_node)
+	continue;
+
+      GTK_CTREE_ROW ((GList *)(list->data))->row.state = GTK_STATE_NORMAL;
+      tree_draw_node (GTK_CTREE (clist), GTK_CTREE_NODE (list->data));
+    }
+}
+
+static GList *
+selection_find (GtkCList *clist,
+		gint      row_number,
+		GList    *row_list_element)
+{
+  return g_list_find (clist->selection, row_list_element);
+}
+
+static void
+resync_selection (GtkCList *clist, GdkEvent *event)
+{
+  GtkCTree *ctree;
+  GList *list;
+  GtkCTreeNode *node;
+  gint i;
+  gint e;
+  gint row;
+  gboolean unselect;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+
+  if (clist->selection_mode != GTK_SELECTION_EXTENDED)
+    return;
+
+  if (clist->anchor < 0 || clist->drag_pos < 0)
+    return;
+
+  ctree = GTK_CTREE (clist);
+  
+  clist->freeze_count++;
+
+  i = MIN (clist->anchor, clist->drag_pos);
+  e = MAX (clist->anchor, clist->drag_pos);
+
+  if (clist->undo_selection)
+    {
+      list = clist->selection;
+      clist->selection = clist->undo_selection;
+      clist->selection_end = g_list_last (clist->selection);
+      clist->undo_selection = list;
+      list = clist->selection;
+
+      while (list)
+	{
+	  node = list->data;
+	  list = list->next;
+	  
+	  unselect = TRUE;
+
+	  if (gtk_ctree_is_viewable (ctree, node))
+	    {
+	      row = g_list_position (clist->row_list, (GList *)node);
+	      if (row >= i && row <= e)
+		unselect = FALSE;
+	    }
+	  if (unselect && GTK_CTREE_ROW (node)->row.selectable)
+	    {
+	      GTK_CTREE_ROW (node)->row.state = GTK_STATE_SELECTED;
+	      gtk_ctree_unselect (ctree, node);
+	      clist->undo_selection = g_list_prepend (clist->undo_selection,
+						      node);
+	    }
+	}
+    }    
+
+  if (clist->anchor < clist->drag_pos)
+    {
+      for (node = GTK_CTREE_NODE (g_list_nth (clist->row_list, i)); i <= e;
+	   i++, node = GTK_CTREE_NODE_NEXT (node))
+	if (GTK_CTREE_ROW (node)->row.selectable)
+	  {
+	    if (g_list_find (clist->selection, node))
+	      {
+		if (GTK_CTREE_ROW (node)->row.state == GTK_STATE_NORMAL)
+		  {
+		    GTK_CTREE_ROW (node)->row.state = GTK_STATE_SELECTED;
+		    gtk_ctree_unselect (ctree, node);
+		    clist->undo_selection =
+		      g_list_prepend (clist->undo_selection, node);
+		  }
+	      }
+	    else if (GTK_CTREE_ROW (node)->row.state == GTK_STATE_SELECTED)
+	      {
+		GTK_CTREE_ROW (node)->row.state = GTK_STATE_NORMAL;
+		clist->undo_unselection =
+		  g_list_prepend (clist->undo_unselection, node);
+	      }
+	  }
+    }
+  else
+    {
+      for (node = GTK_CTREE_NODE (g_list_nth (clist->row_list, e)); i <= e;
+	   e--, node = GTK_CTREE_NODE_PREV (node))
+	if (GTK_CTREE_ROW (node)->row.selectable)
+	  {
+	    if (g_list_find (clist->selection, node))
+	      {
+		if (GTK_CTREE_ROW (node)->row.state == GTK_STATE_NORMAL)
+		  {
+		    GTK_CTREE_ROW (node)->row.state = GTK_STATE_SELECTED;
+		    gtk_ctree_unselect (ctree, node);
+		    clist->undo_selection =
+		      g_list_prepend (clist->undo_selection, node);
+		  }
+	      }
+	    else if (GTK_CTREE_ROW (node)->row.state == GTK_STATE_SELECTED)
+	      {
+		GTK_CTREE_ROW (node)->row.state = GTK_STATE_NORMAL;
+		clist->undo_unselection =
+		  g_list_prepend (clist->undo_unselection, node);
+	      }
+	  }
+    }
+
+  clist->undo_unselection = g_list_reverse (clist->undo_unselection);
+  for (list = clist->undo_unselection; list; list = list->next)
+    gtk_ctree_select (ctree, list->data);
+
+  clist->anchor = -1;
+  clist->drag_pos = -1;
+
+  if (!CLIST_UNFROZEN (clist))
+    clist->freeze_count--;
+}
+
+static void
+real_undo_selection (GtkCList *clist)
+{
+  GtkCTree *ctree;
+  GList *work;
+
+  g_return_if_fail (clist != NULL);
+  g_return_if_fail (GTK_IS_CTREE (clist));
+
+  if (clist->selection_mode != GTK_SELECTION_EXTENDED)
+    return;
+
+  if (!(clist->undo_selection || clist->undo_unselection))
+    {
+      gtk_clist_unselect_all (clist);
+      return;
+    }
+
+  ctree = GTK_CTREE (clist);
+
+  for (work = clist->undo_selection; work; work = work->next)
+    if (GTK_CTREE_ROW (work->data)->row.selectable)
+      gtk_ctree_select (ctree, GTK_CTREE_NODE (work->data));
+
+  for (work = clist->undo_unselection; work; work = work->next)
+    if (GTK_CTREE_ROW (work->data)->row.selectable)
+      gtk_ctree_unselect (ctree, GTK_CTREE_NODE (work->data));
+
+  if (GTK_WIDGET_HAS_FOCUS (clist) && clist->focus_row != clist->undo_anchor)
+    {
+      gtk_widget_draw_focus (GTK_WIDGET (clist));
+      clist->focus_row = clist->undo_anchor;
+      gtk_widget_draw_focus (GTK_WIDGET (clist));
+    }
+  else
+    clist->focus_row = clist->undo_anchor;
+  
+  clist->undo_anchor = -1;
+ 
+  g_list_free (clist->undo_selection);
+  g_list_free (clist->undo_unselection);
+  clist->undo_selection = NULL;
+  clist->undo_unselection = NULL;
+
+  if (ROW_TOP_YPIXEL (clist, clist->focus_row) + clist->row_height >
+      clist->clist_window_height)
+    gtk_clist_moveto (clist, clist->focus_row, -1, 1, 0);
+  else if (ROW_TOP_YPIXEL (clist, clist->focus_row) < 0)
+    gtk_clist_moveto (clist, clist->focus_row, -1, 0, 0);
+
+}
+
+void
+gtk_ctree_set_drag_compare_func (GtkCTree                *ctree,
+				 GtkCTreeCompareDragFunc  cmp_func)
+{
+  g_return_if_fail (ctree != NULL);
+  g_return_if_fail (GTK_IS_CTREE (ctree));
+
+  ctree->drag_compare = cmp_func;
+}
+
+static gboolean
+check_drag (GtkCTree        *ctree,
+	    GtkCTreeNode    *drag_source,
+	    GtkCTreeNode    *drag_target,
+	    GtkCListDragPos  insert_pos)
+{
+  g_return_val_if_fail (ctree != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_CTREE (ctree), FALSE);
+
+  if (drag_source && drag_source != drag_target &&
+      (!GTK_CTREE_ROW (drag_source)->children ||
+       !gtk_ctree_is_ancestor (ctree, drag_source, drag_target)))
+    {
+      switch (insert_pos)
+	{
+	case GTK_CLIST_DRAG_NONE:
+	  return FALSE;
+	case GTK_CLIST_DRAG_AFTER:
+	  if (GTK_CTREE_ROW (drag_target)->sibling != drag_source)
+	    return (!ctree->drag_compare ||
+		    ctree->drag_compare (ctree,
+					 drag_source,
+					 GTK_CTREE_ROW (drag_target)->parent,
+					 GTK_CTREE_ROW(drag_target)->sibling));
+	  break;
+	case GTK_CLIST_DRAG_BEFORE:
+	  if (GTK_CTREE_ROW (drag_source)->sibling != drag_target)
+	    return (!ctree->drag_compare ||
+		    ctree->drag_compare (ctree,
+					 drag_source,
+					 GTK_CTREE_ROW (drag_target)->parent,
+					 drag_target));
+	  break;
+	case GTK_CLIST_DRAG_INTO:
+	  if (!GTK_CTREE_ROW (drag_target)->is_leaf &&
+	      GTK_CTREE_ROW (drag_target)->children != drag_source)
+	    return (!ctree->drag_compare ||
+		    ctree->drag_compare (ctree,
+					 drag_source,
+					 drag_target,
+					 GTK_CTREE_ROW (drag_target)->children));
+	  break;
+	}
+    }
+  return FALSE;
+}
+
+
+
+/************************************/
+static void
+drag_dest_info_destroy (gpointer data)
+{
+  GtkCListDestInfo *info = data;
+
+  g_free (info);
+}
+
+static void
+drag_dest_cell (GtkCList         *clist,
+		gint              x,
+		gint              y,
+		GtkCListDestInfo *dest_info)
+{
+  GtkWidget *widget;
+
+  widget = GTK_WIDGET (clist);
+
+  dest_info->insert_pos = GTK_CLIST_DRAG_NONE;
+
+  y -= (GTK_CONTAINER (widget)->border_width +
+	widget->style->klass->ythickness + clist->column_title_area.height);
+  dest_info->cell.row = ROW_FROM_YPIXEL (clist, y);
+
+  if (dest_info->cell.row >= clist->rows)
+    {
+      dest_info->cell.row = clist->rows - 1;
+      y = ROW_TOP_YPIXEL (clist, dest_info->cell.row) + clist->row_height;
+    }
+  if (dest_info->cell.row < -1)
+    dest_info->cell.row = -1;
+
+  x -= GTK_CONTAINER (widget)->border_width + widget->style->klass->xthickness;
+  dest_info->cell.column = COLUMN_FROM_XPIXEL (clist, x);
+
+  if (dest_info->cell.row >= 0)
+    {
+      gint y_delta;
+      gint h = 0;
+
+      y_delta = y - ROW_TOP_YPIXEL (clist, dest_info->cell.row);
+      
+      if (GTK_CLIST_DRAW_DRAG_RECT(clist) &&
+	  !GTK_CTREE_ROW (g_list_nth (clist->row_list,
+				      dest_info->cell.row))->is_leaf)
+	{
+	  dest_info->insert_pos = GTK_CLIST_DRAG_INTO;
+	  h = clist->row_height / 4;
+	}
+      else if (GTK_CLIST_DRAW_DRAG_LINE(clist))
+	{
+	  dest_info->insert_pos = GTK_CLIST_DRAG_BEFORE;
+	  h = clist->row_height / 2;
+	}
+
+      if (GTK_CLIST_DRAW_DRAG_LINE(clist))
+	{
+	  if (y_delta < h)
+	    dest_info->insert_pos = GTK_CLIST_DRAG_BEFORE;
+	  else if (clist->row_height - y_delta < h)
+	    dest_info->insert_pos = GTK_CLIST_DRAG_AFTER;
+	}
+    }
+}
+
+static void
+gtk_ctree_drag_begin (GtkWidget	     *widget,
+		      GdkDragContext *context)
+{
+  GtkCList *clist;
+  GtkCTree *ctree;
+  gboolean use_icons;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_CTREE (widget));
+  g_return_if_fail (context != NULL);
+
+  clist = GTK_CLIST (widget);
+  ctree = GTK_CTREE (widget);
+
+  use_icons = GTK_CLIST_USE_DRAG_ICONS (clist);
+  GTK_CLIST_UNSET_FLAG (clist, CLIST_USE_DRAG_ICONS);
+  GTK_WIDGET_CLASS (parent_class)->drag_begin (widget, context);
+
+  if (use_icons)
+    {
+      GtkCTreeNode *node;
+
+      GTK_CLIST_SET_FLAG (clist, CLIST_USE_DRAG_ICONS);
+      node = GTK_CTREE_NODE (g_list_nth (clist->row_list,
+					 clist->click_cell.row));
+      if (node)
+	{
+	  if (GTK_CELL_PIXTEXT
+	      (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap)
+	    {
+	      gtk_drag_set_icon_pixmap
+		(context,
+		 gtk_widget_get_colormap (widget),
+		 GTK_CELL_PIXTEXT
+		 (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->pixmap,
+		 GTK_CELL_PIXTEXT
+		 (GTK_CTREE_ROW (node)->row.cell[ctree->tree_column])->mask,
+		 -2, -2);
+	      return;
+	    }
+	}
+      gtk_drag_set_icon_default (context);
+    }
+}
+
+static gint
+gtk_ctree_drag_motion (GtkWidget      *widget,
+		       GdkDragContext *context,
+		       gint            x,
+		       gint            y,
+		       guint           time)
+{
+  GtkCList *clist;
+  GtkCTree *ctree;
+  GtkCListDestInfo new_info;
+  GtkCListDestInfo *dest_info;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_CTREE (widget), FALSE);
+
+  clist = GTK_CLIST (widget);
+  ctree = GTK_CTREE (widget);
+
+  dest_info = g_dataset_get_data (context, "gtk-clist-drag-dest");
+
+  if (!dest_info)
+    {
+      dest_info = g_new (GtkCListDestInfo, 1);
+	  
+      dest_info->cell.row    = -1;
+      dest_info->cell.column = -1;
+      dest_info->insert_pos  = GTK_CLIST_DRAG_NONE;
+
+      g_dataset_set_data_full (context, "gtk-clist-drag-dest", dest_info,
+			       drag_dest_info_destroy);
+    }
+
+  drag_dest_cell (clist, x, y, &new_info);
+
+  if (GTK_CLIST_REORDERABLE (clist))
+    {
+      GList *list;
+      GdkAtom atom = gdk_atom_intern ("gtk-clist-drag-reorder", FALSE);
+
+      list = context->targets;
+      while (list)
+	{
+	  if (atom == GPOINTER_TO_INT (list->data))
+	    break;
+	  list = list->next;
+	}
+
+      if (list)
+	{
+	  GtkCTreeNode *drag_source;
+	  GtkCTreeNode *drag_target;
+
+	  drag_source = GTK_CTREE_NODE (g_list_nth (clist->row_list,
+						    clist->click_cell.row));
+	  drag_target = GTK_CTREE_NODE (g_list_nth (clist->row_list,
+						    new_info.cell.row));
+
+	  if (gtk_drag_get_source_widget (context) != widget ||
+	      !check_drag (ctree, drag_source, drag_target,
+			   new_info.insert_pos))
+	    {
+	      if (dest_info->cell.row < 0)
+		{
+		  gdk_drag_status (context, GDK_ACTION_DEFAULT, time);
+		  return FALSE;
+		}
+	      return TRUE;
+	    }
+
+	  if (new_info.cell.row != dest_info->cell.row ||
+	      (new_info.cell.row == dest_info->cell.row &&
+	       dest_info->insert_pos != new_info.insert_pos))
+	    {
+	      if (dest_info->cell.row >= 0)
+		GTK_CLIST_CLASS_FW (clist)->draw_drag_highlight
+		  (clist,
+		   g_list_nth (clist->row_list, dest_info->cell.row)->data,
+		   dest_info->cell.row, dest_info->insert_pos);
+
+	      dest_info->insert_pos  = new_info.insert_pos;
+	      dest_info->cell.row    = new_info.cell.row;
+	      dest_info->cell.column = new_info.cell.column;
+
+	      GTK_CLIST_CLASS_FW (clist)->draw_drag_highlight
+		(clist,
+		 g_list_nth (clist->row_list, dest_info->cell.row)->data,
+		 dest_info->cell.row, dest_info->insert_pos);
+
+	      gdk_drag_status (context, context->suggested_action, time);
+	    }
+	  return TRUE;
+	}
+    }
+
+  dest_info->insert_pos  = new_info.insert_pos;
+  dest_info->cell.row    = new_info.cell.row;
+  dest_info->cell.column = new_info.cell.column;
+  return TRUE;
+}
+
+static void
+gtk_ctree_drag_data_received (GtkWidget        *widget,
+			      GdkDragContext   *context,
+			      gint              x,
+			      gint              y,
+			      GtkSelectionData *selection_data,
+			      guint             info,
+			      guint32           time)
+{
+  GtkCTree *ctree;
+  GtkCList *clist;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_CTREE (widget));
+  g_return_if_fail (context != NULL);
+  g_return_if_fail (selection_data != NULL);
+
+  ctree = GTK_CTREE (widget);
+  clist = GTK_CLIST (widget);
+
+  if (GTK_CLIST_REORDERABLE (clist) &&
+      gtk_drag_get_source_widget (context) == widget &&
+      selection_data->target ==
+      gdk_atom_intern ("gtk-clist-drag-reorder", FALSE) &&
+      selection_data->format == GTK_TYPE_POINTER &&
+      selection_data->length == sizeof (GtkCListCellInfo))
+    {
+      GtkCListCellInfo *source_info;
+
+      source_info = (GtkCListCellInfo *)(selection_data->data);
+      if (source_info)
+	{
+	  GtkCListDestInfo dest_info;
+	  GtkCTreeNode *source_node;
+	  GtkCTreeNode *dest_node;
+
+	  drag_dest_cell (clist, x, y, &dest_info);
+	  
+	  source_node = GTK_CTREE_NODE (g_list_nth (clist->row_list,
+						    source_info->row));
+	  dest_node = GTK_CTREE_NODE (g_list_nth (clist->row_list,
+						  dest_info.cell.row));
+
+	  if (!source_node || !dest_node)
+	    return;
+
+	  switch (dest_info.insert_pos)
+	    {
+	    case GTK_CLIST_DRAG_NONE:
+	      break;
+	    case GTK_CLIST_DRAG_INTO:
+	      if (check_drag (ctree, source_node, dest_node,
+			      dest_info.insert_pos))
+		gtk_ctree_move (ctree, source_node, dest_node,
+				GTK_CTREE_ROW (dest_node)->children);
+	      g_dataset_remove_data (context, "gtk-clist-drag-dest");
+	      break;
+	    case GTK_CLIST_DRAG_BEFORE:
+	      if (check_drag (ctree, source_node, dest_node,
+			      dest_info.insert_pos))
+		gtk_ctree_move (ctree, source_node,
+				GTK_CTREE_ROW (dest_node)->parent, dest_node);
+	      g_dataset_remove_data (context, "gtk-clist-drag-dest");
+	      break;
+	    case GTK_CLIST_DRAG_AFTER:
+	      if (check_drag (ctree, source_node, dest_node,
+			      dest_info.insert_pos))
+		gtk_ctree_move (ctree, source_node,
+				GTK_CTREE_ROW (dest_node)->parent, 
+				GTK_CTREE_ROW (dest_node)->sibling);
+	      g_dataset_remove_data (context, "gtk-clist-drag-dest");
+	      break;
+	    }
+	}
+    }
+}
diff -uNr a/gtk/gtkdnd.c b/gtk/gtkdnd.c
--- a/gtk/gtkdnd.c	Fri Mar 23 18:24:31 2001
+++ b/gtk/gtkdnd.c	Mon May 27 17:47:20 2002
@@ -2673,7 +2673,8 @@
   if (gdk_drag_motion (info->context, dest_window, protocol,
 		       x_root, y_root, action, 
 		       possible_actions,
-		       time))
+		       time)
+      && info->last_event != event)
     {
       if (info->last_event)
 	gdk_event_free ((GdkEvent *)info->last_event);
diff -uNr a/gtk/gtkentry.c b/gtk/gtkentry.c
--- a/gtk/gtkentry.c	Sun Apr  1 22:14:54 2001
+++ b/gtk/gtkentry.c	Mon May 27 17:47:20 2002
@@ -34,9 +34,9 @@
 #include "gtksignal.h"
 #include "gtkstyle.h"
 
-#define MIN_ENTRY_WIDTH  150
-#define DRAW_TIMEOUT     20
-
+#define MIN_ENTRY_WIDTH      150
+#define DRAW_TIMEOUT         20
+#define CURSOR_BLINK_TIMEOUT 500
 /* If you are going to change this, see the note in entry_adjust_scroll */
 #define INNER_BORDER     2
 
@@ -77,6 +77,8 @@
 					   GdkEventMotion    *event);
 static gint gtk_entry_key_press           (GtkWidget         *widget,
 					   GdkEventKey       *event);
+static void gtk_entry_cursor_reset        (GtkEntry *entry);
+static gint gtk_entry_cursor_timeout_cb   (gpointer data);
 static gint gtk_entry_focus_in            (GtkWidget         *widget,
 					   GdkEventFocus     *event);
 static gint gtk_entry_focus_out           (GtkWidget         *widget,
@@ -467,6 +469,8 @@
   tmp_pos = entry->text_length;
   gtk_editable_insert_text (GTK_EDITABLE(entry), text, strlen (text), &tmp_pos);
   GTK_EDITABLE(entry)->current_pos = tmp_pos;
+
+  gtk_entry_cursor_reset (entry);
 }
 
 void
@@ -558,6 +562,7 @@
 gtk_entry_finalize (GtkObject *object)
 {
   GtkEntry *entry;
+  int cursor_timeout_id;
 
   g_return_if_fail (object != NULL);
   g_return_if_fail (GTK_IS_ENTRY (object));
@@ -567,6 +572,12 @@
   if (entry->timer)
     gtk_timeout_remove (entry->timer);
 
+  cursor_timeout_id =
+    cursor_timeout_id = GPOINTER_TO_INT (gtk_object_get_data (GTK_OBJECT (entry),
+							      "gtk_entry_cursor_timeout_id"));
+  if (cursor_timeout_id != 0)
+    gtk_timeout_remove (cursor_timeout_id);
+
   entry->text_size = 0;
 
   if (entry->text)
@@ -724,6 +735,7 @@
 gtk_entry_unrealize (GtkWidget *widget)
 {
   GtkEntry *entry;
+  int cursor_timeout_id;
 
   g_return_if_fail (widget != NULL);
   g_return_if_fail (GTK_IS_ENTRY (widget));
@@ -743,6 +755,17 @@
     }
 #endif
 
+  cursor_timeout_id =
+    cursor_timeout_id = GPOINTER_TO_INT (gtk_object_get_data (GTK_OBJECT (entry),
+							      "gtk_entry_cursor_timeout_id"));
+  if (cursor_timeout_id != 0)
+    {  
+      gtk_timeout_remove (cursor_timeout_id);
+      gtk_object_set_data (GTK_OBJECT (entry), "gtk_entry_cursor_timeout_id",
+			   GINT_TO_POINTER (0));
+    }
+  
+
   if (entry->text_area)
     {
       gdk_window_set_user_data (entry->text_area, NULL);
@@ -1232,6 +1255,8 @@
 	  gtk_editable_insert_text (editable, event->string, event->length, &tmp_pos);
 	  editable->current_pos = tmp_pos;
 
+	  gtk_entry_cursor_reset (entry);
+
 	  return_val = TRUE;
 	}
       break;
@@ -1276,6 +1301,50 @@
 }
 
 static gint
+gtk_entry_cursor_timeout_cb (gpointer data)
+{
+  GtkEntry *entry;
+  gboolean cursor_visible;
+
+  entry = GTK_ENTRY (data);
+
+  cursor_visible = GPOINTER_TO_INT (gtk_object_get_data (GTK_OBJECT (entry),
+							 "gtk_entry_cursor_visible"));
+  cursor_visible = ! cursor_visible;
+  gtk_object_set_data (GTK_OBJECT (entry), "gtk_entry_cursor_visible",
+		       GINT_TO_POINTER (cursor_visible));
+
+  gtk_entry_draw_cursor (entry);
+
+  return TRUE;
+}
+
+static void
+gtk_entry_cursor_reset (GtkEntry *entry)
+{
+  gint timeout_id;
+
+  gtk_object_set_data (GTK_OBJECT (entry), "gtk_entry_cursor_visible",
+		       GINT_TO_POINTER (TRUE));
+
+  timeout_id = GPOINTER_TO_INT (gtk_object_get_data (GTK_OBJECT (entry),
+						     "gtk_entry_cursor_timeout_id"));
+  if (timeout_id != 0)
+    gtk_timeout_remove (timeout_id);
+
+  if (GTK_WIDGET_HAS_FOCUS (entry))
+    {
+      timeout_id = gtk_timeout_add (CURSOR_BLINK_TIMEOUT,
+				    gtk_entry_cursor_timeout_cb, entry);
+      gtk_object_set_data (GTK_OBJECT (entry), "gtk_entry_cursor_timeout_id",
+			   GINT_TO_POINTER (timeout_id));
+    }
+  else
+    gtk_object_set_data (GTK_OBJECT (entry), "gtk_entry_cursor_timeout_id",
+			 GINT_TO_POINTER (0));
+}
+
+static gint
 gtk_entry_focus_in (GtkWidget     *widget,
 		    GdkEventFocus *event)
 {
@@ -1291,6 +1360,8 @@
     gdk_im_begin (GTK_EDITABLE(widget)->ic, GTK_ENTRY(widget)->text_area);
 #endif
 
+  gtk_entry_cursor_reset (GTK_ENTRY (widget));
+
   return FALSE;
 }
 
@@ -1309,6 +1380,7 @@
   gdk_im_end ();
 #endif
 
+  gtk_entry_cursor_reset (GTK_ENTRY (widget));
   return FALSE;
 }
 
@@ -1510,6 +1582,7 @@
   GtkEditable *editable;
   gint xoffset;
   gint text_area_height;
+  gboolean cursor_visible;
 
   g_return_if_fail (entry != NULL);
   g_return_if_fail (GTK_IS_ENTRY (entry));
@@ -1524,7 +1597,12 @@
 
       gdk_window_get_size (entry->text_area, NULL, &text_area_height);
 
-      if (GTK_WIDGET_HAS_FOCUS (widget) &&
+      cursor_visible = GPOINTER_TO_INT (gtk_object_get_data
+					(GTK_OBJECT (widget),
+					 "gtk_entry_cursor_visible"));
+
+      if (cursor_visible &&
+	  GTK_WIDGET_HAS_FOCUS (widget) &&
 	  (editable->selection_start_pos == editable->selection_end_pos))
 	{
 	  gdk_draw_line (drawable, widget->style->fg_gc[GTK_STATE_NORMAL], 
@@ -2006,6 +2084,8 @@
     editable->current_pos += x;
 
   /* Ignore vertical motion */
+
+  gtk_entry_cursor_reset (entry);
 }
 
 static void
@@ -2071,6 +2151,8 @@
 	}
 
       editable->current_pos = i;
+
+      gtk_entry_cursor_reset (entry);
     }
 }
 
@@ -2113,6 +2195,8 @@
 	i = 0;
 	  
       editable->current_pos = i;
+
+      gtk_entry_cursor_reset (entry);
     }
 }
 
@@ -2127,6 +2211,8 @@
     editable->current_pos = entry->text_length;
   else
     editable->current_pos = column;
+
+  gtk_entry_cursor_reset (entry);
 }
 
 static void
@@ -2273,6 +2359,8 @@
   gtk_editable_claim_selection (editable, entry->text_length != 0, time);
 
   editable->current_pos = editable->selection_end_pos;
+
+  gtk_entry_cursor_reset (entry);
 }
 
 static void 
diff -uNr a/gtk/gtkentry.c~ b/gtk/gtkentry.c~
--- a/gtk/gtkentry.c~	Wed Dec 31 19:00:00 1969
+++ b/gtk/gtkentry.c~	Sun Apr  1 22:14:54 2001
@@ -0,0 +1,2408 @@
+/* GTK - The GIMP Toolkit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include <ctype.h>
+#include <string.h>
+#include "gdk/gdkkeysyms.h"
+#include "gdk/gdki18n.h"
+#include "gtkentry.h"
+#include "gtkmain.h"
+#include "gtkselection.h"
+#include "gtksignal.h"
+#include "gtkstyle.h"
+
+#define MIN_ENTRY_WIDTH  150
+#define DRAW_TIMEOUT     20
+
+/* If you are going to change this, see the note in entry_adjust_scroll */
+#define INNER_BORDER     2
+
+enum {
+  ARG_0,
+  ARG_MAX_LENGTH,
+  ARG_VISIBILITY
+};
+
+
+static void gtk_entry_class_init          (GtkEntryClass     *klass);
+static void gtk_entry_init                (GtkEntry          *entry);
+static void gtk_entry_set_arg      	  (GtkObject         *object,
+					   GtkArg            *arg,
+					   guint              arg_id);
+static void gtk_entry_get_arg		  (GtkObject         *object,
+					   GtkArg            *arg,
+					   guint              arg_id);
+static void gtk_entry_finalize            (GtkObject         *object);
+static void gtk_entry_realize             (GtkWidget         *widget);
+static void gtk_entry_unrealize           (GtkWidget         *widget);
+static void gtk_entry_draw_focus          (GtkWidget         *widget);
+static void gtk_entry_size_request        (GtkWidget         *widget,
+					   GtkRequisition    *requisition);
+static void gtk_entry_size_allocate       (GtkWidget         *widget,
+					   GtkAllocation     *allocation);
+static void gtk_entry_make_backing_pixmap (GtkEntry *entry,
+					   gint width, gint height);
+static void gtk_entry_draw                (GtkWidget         *widget,
+					   GdkRectangle      *area);
+static gint gtk_entry_expose              (GtkWidget         *widget,
+					   GdkEventExpose    *event);
+static gint gtk_entry_button_press        (GtkWidget         *widget,
+					   GdkEventButton    *event);
+static gint gtk_entry_button_release      (GtkWidget         *widget,
+					   GdkEventButton    *event);
+static gint gtk_entry_motion_notify       (GtkWidget         *widget,
+					   GdkEventMotion    *event);
+static gint gtk_entry_key_press           (GtkWidget         *widget,
+					   GdkEventKey       *event);
+static gint gtk_entry_focus_in            (GtkWidget         *widget,
+					   GdkEventFocus     *event);
+static gint gtk_entry_focus_out           (GtkWidget         *widget,
+					   GdkEventFocus     *event);
+static void gtk_entry_draw_text           (GtkEntry          *entry);
+static void gtk_entry_draw_cursor         (GtkEntry          *entry);
+static void gtk_entry_draw_cursor_on_drawable
+					  (GtkEntry          *entry,
+					   GdkDrawable       *drawable);
+static void gtk_entry_style_set	          (GtkWidget         *widget,
+					   GtkStyle          *previous_style);
+static void gtk_entry_state_changed	  (GtkWidget         *widget,
+					   GtkStateType       previous_state);
+#ifdef USE_XIM
+static void gtk_entry_update_ic_attr      (GtkWidget         *widget);
+#endif
+static void gtk_entry_queue_draw          (GtkEntry          *entry);
+static gint gtk_entry_timer               (gpointer           data);
+static gint gtk_entry_position            (GtkEntry          *entry,
+					   gint               x);
+static void entry_adjust_scroll           (GtkEntry          *entry);
+static void gtk_entry_grow_text           (GtkEntry          *entry);
+static void gtk_entry_insert_text         (GtkEditable       *editable,
+					   const gchar       *new_text,
+					   gint               new_text_length,
+					   gint              *position);
+static void gtk_entry_delete_text         (GtkEditable       *editable,
+					   gint               start_pos,
+					   gint               end_pos);
+static void gtk_entry_update_text         (GtkEditable       *editable,
+					   gint               start_pos,
+					   gint               end_pos);
+static gchar *gtk_entry_get_chars         (GtkEditable       *editable,
+					   gint               start_pos,
+					   gint               end_pos);
+
+/* Binding actions */
+static void gtk_entry_move_cursor         (GtkEditable *editable,
+					   gint         x,
+					   gint         y);
+static void gtk_entry_move_word           (GtkEditable *editable,
+					   gint         n);
+static void gtk_entry_move_to_column      (GtkEditable *editable,
+					   gint         row);
+static void gtk_entry_kill_char           (GtkEditable *editable,
+					   gint         direction);
+static void gtk_entry_kill_word           (GtkEditable *editable,
+					   gint         direction);
+static void gtk_entry_kill_line           (GtkEditable *editable,
+					   gint         direction);
+
+/* To be removed */
+static void gtk_move_forward_character    (GtkEntry          *entry);
+static void gtk_move_backward_character   (GtkEntry          *entry);
+static void gtk_move_forward_word         (GtkEntry          *entry);
+static void gtk_move_backward_word        (GtkEntry          *entry);
+static void gtk_move_beginning_of_line    (GtkEntry          *entry);
+static void gtk_move_end_of_line          (GtkEntry          *entry);
+static void gtk_delete_forward_character  (GtkEntry          *entry);
+static void gtk_delete_backward_character (GtkEntry          *entry);
+static void gtk_delete_forward_word       (GtkEntry          *entry);
+static void gtk_delete_backward_word      (GtkEntry          *entry);
+static void gtk_delete_line               (GtkEntry          *entry);
+static void gtk_delete_to_line_end        (GtkEntry          *entry);
+static void gtk_select_word               (GtkEntry          *entry,
+					   guint32            time);
+static void gtk_select_line               (GtkEntry          *entry,
+					   guint32            time);
+
+
+static void gtk_entry_set_selection       (GtkEditable       *editable,
+					   gint               start,
+					   gint               end);
+
+static void gtk_entry_recompute_offsets   (GtkEntry          *entry);
+static gint gtk_entry_find_position       (GtkEntry          *entry, 
+					   gint               position);
+static void gtk_entry_set_position_from_editable (GtkEditable *editable,
+						  gint         position);
+
+static GtkWidgetClass *parent_class = NULL;
+static GdkAtom ctext_atom = GDK_NONE;
+
+static const GtkTextFunction control_keys[26] =
+{
+  (GtkTextFunction)gtk_move_beginning_of_line,    /* a */
+  (GtkTextFunction)gtk_move_backward_character,   /* b */
+  (GtkTextFunction)gtk_editable_copy_clipboard,   /* c */
+  (GtkTextFunction)gtk_delete_forward_character,  /* d */
+  (GtkTextFunction)gtk_move_end_of_line,          /* e */
+  (GtkTextFunction)gtk_move_forward_character,    /* f */
+  NULL,                                           /* g */
+  (GtkTextFunction)gtk_delete_backward_character, /* h */
+  NULL,                                           /* i */
+  NULL,                                           /* j */
+  (GtkTextFunction)gtk_delete_to_line_end,        /* k */
+  NULL,                                           /* l */
+  NULL,                                           /* m */
+  NULL,                                           /* n */
+  NULL,                                           /* o */
+  NULL,                                           /* p */
+  NULL,                                           /* q */
+  NULL,                                           /* r */
+  NULL,                                           /* s */
+  NULL,                                           /* t */
+  (GtkTextFunction)gtk_delete_line,               /* u */
+  (GtkTextFunction)gtk_editable_paste_clipboard,  /* v */
+  (GtkTextFunction)gtk_delete_backward_word,      /* w */
+  (GtkTextFunction)gtk_editable_cut_clipboard,    /* x */
+  NULL,                                           /* y */
+  NULL,                                           /* z */
+};
+
+static const GtkTextFunction alt_keys[26] =
+{
+  NULL,                                           /* a */
+  (GtkTextFunction)gtk_move_backward_word,        /* b */
+  NULL,                                           /* c */
+  (GtkTextFunction)gtk_delete_forward_word,       /* d */
+  NULL,                                           /* e */
+  (GtkTextFunction)gtk_move_forward_word,         /* f */
+  NULL,                                           /* g */
+  NULL,                                           /* h */
+  NULL,                                           /* i */
+  NULL,                                           /* j */
+  NULL,                                           /* k */
+  NULL,                                           /* l */
+  NULL,                                           /* m */
+  NULL,                                           /* n */
+  NULL,                                           /* o */
+  NULL,                                           /* p */
+  NULL,                                           /* q */
+  NULL,                                           /* r */
+  NULL,                                           /* s */
+  NULL,                                           /* t */
+  NULL,                                           /* u */
+  NULL,                                           /* v */
+  NULL,                                           /* w */
+  NULL,                                           /* x */
+  NULL,                                           /* y */
+  NULL,                                           /* z */
+};
+
+
+GtkType
+gtk_entry_get_type (void)
+{
+  static GtkType entry_type = 0;
+
+  if (!entry_type)
+    {
+      static const GtkTypeInfo entry_info =
+      {
+	"GtkEntry",
+	sizeof (GtkEntry),
+	sizeof (GtkEntryClass),
+	(GtkClassInitFunc) gtk_entry_class_init,
+	(GtkObjectInitFunc) gtk_entry_init,
+	/* reserved_1 */ NULL,
+	/* reserved_2 */ NULL,
+        (GtkClassInitFunc) NULL,
+      };
+
+      entry_type = gtk_type_unique (GTK_TYPE_EDITABLE, &entry_info);
+    }
+
+  return entry_type;
+}
+
+static void
+gtk_entry_class_init (GtkEntryClass *class)
+{
+  GtkObjectClass *object_class;
+  GtkWidgetClass *widget_class;
+  GtkEditableClass *editable_class;
+
+  object_class = (GtkObjectClass*) class;
+  widget_class = (GtkWidgetClass*) class;
+  editable_class = (GtkEditableClass*) class;
+  parent_class = gtk_type_class (GTK_TYPE_EDITABLE);
+
+  gtk_object_add_arg_type ("GtkEntry::max_length", GTK_TYPE_UINT, GTK_ARG_READWRITE, ARG_MAX_LENGTH);
+  gtk_object_add_arg_type ("GtkEntry::visibility", GTK_TYPE_BOOL, GTK_ARG_READWRITE, ARG_VISIBILITY);
+
+  object_class->set_arg = gtk_entry_set_arg;
+  object_class->get_arg = gtk_entry_get_arg;
+  object_class->finalize = gtk_entry_finalize;
+
+  widget_class->realize = gtk_entry_realize;
+  widget_class->unrealize = gtk_entry_unrealize;
+  widget_class->draw_focus = gtk_entry_draw_focus;
+  widget_class->size_request = gtk_entry_size_request;
+  widget_class->size_allocate = gtk_entry_size_allocate;
+  widget_class->draw = gtk_entry_draw;
+  widget_class->expose_event = gtk_entry_expose;
+  widget_class->button_press_event = gtk_entry_button_press;
+  widget_class->button_release_event = gtk_entry_button_release;
+  widget_class->motion_notify_event = gtk_entry_motion_notify;
+  widget_class->key_press_event = gtk_entry_key_press;
+  widget_class->focus_in_event = gtk_entry_focus_in;
+  widget_class->focus_out_event = gtk_entry_focus_out;
+  widget_class->style_set = gtk_entry_style_set;
+  widget_class->state_changed = gtk_entry_state_changed;
+
+  editable_class->insert_text = gtk_entry_insert_text;
+  editable_class->delete_text = gtk_entry_delete_text;
+  editable_class->changed = (void (*)(GtkEditable *)) entry_adjust_scroll;
+
+  editable_class->move_cursor = gtk_entry_move_cursor;
+  editable_class->move_word = gtk_entry_move_word;
+  editable_class->move_to_column = gtk_entry_move_to_column;
+
+  editable_class->kill_char = gtk_entry_kill_char;
+  editable_class->kill_word = gtk_entry_kill_word;
+  editable_class->kill_line = gtk_entry_kill_line;
+
+  editable_class->update_text = gtk_entry_update_text;
+  editable_class->get_chars   = gtk_entry_get_chars;
+  editable_class->set_selection = gtk_entry_set_selection;
+  editable_class->set_position = gtk_entry_set_position_from_editable;
+}
+
+static void
+gtk_entry_set_arg (GtkObject      *object,
+		   GtkArg         *arg,
+		   guint           arg_id)
+{
+  GtkEntry *entry;
+
+  entry = GTK_ENTRY (object);
+
+  switch (arg_id)
+    {
+    case ARG_MAX_LENGTH:
+      gtk_entry_set_max_length (entry, GTK_VALUE_UINT (*arg));
+      break;
+    case ARG_VISIBILITY:
+      gtk_entry_set_visibility (entry, GTK_VALUE_BOOL (*arg));
+      break;
+    default:
+      break;
+    }
+}
+
+static void
+gtk_entry_get_arg (GtkObject      *object,
+		   GtkArg         *arg,
+		   guint           arg_id)
+{
+  GtkEntry *entry;
+
+  entry = GTK_ENTRY (object);
+
+  switch (arg_id)
+    {
+    case ARG_MAX_LENGTH:
+      GTK_VALUE_UINT (*arg) = entry->text_max_length;
+      break;
+    case ARG_VISIBILITY:
+      GTK_VALUE_BOOL (*arg) = GTK_EDITABLE (entry)->visible;
+      break;
+    default:
+      arg->type = GTK_TYPE_INVALID;
+      break;
+    }
+}
+
+static void
+gtk_entry_init (GtkEntry *entry)
+{
+  GTK_WIDGET_SET_FLAGS (entry, GTK_CAN_FOCUS);
+
+  entry->text_area = NULL;
+  entry->backing_pixmap = NULL;
+  entry->text = NULL;
+  entry->text_size = 0;
+  entry->text_length = 0;
+  entry->text_max_length = 0;
+  entry->scroll_offset = 0;
+  entry->timer = 0;
+  entry->button = 0;
+  entry->visible = 1;
+
+  entry->char_offset = NULL;
+  entry->text_mb = NULL;
+  entry->text_mb_dirty = TRUE;
+  entry->use_wchar = FALSE;
+
+  gtk_entry_grow_text (entry);
+}
+
+GtkWidget*
+gtk_entry_new (void)
+{
+  return GTK_WIDGET (gtk_type_new (GTK_TYPE_ENTRY));
+}
+
+static GdkWChar
+gtk_entry_get_invisible_char (GtkEntry *entry)
+{
+  GdkWChar ch = 0;
+
+  if (entry->use_wchar)
+    gdk_mbstowcs (&ch, "*", 1);
+  else
+    ch = '*';
+
+  return ch;
+}
+
+/*
+ * Draws the string, noting that if entry->use_wchar is false, then
+ * the text is not really wide characters, but narrow characters
+ * stored as wide characters.
+ */
+static void
+gtk_entry_draw_wchars (GtkEntry       *entry,
+		       GdkDrawable    *drawable,
+		       GdkFont	      *font,
+		       GdkGC	      *gc,
+		       gint	       x,
+		       gint	       y,
+		       const GdkWChar *text,
+		       gint	       text_length)
+{
+  if (entry->use_wchar)
+    gdk_draw_text_wc (drawable, font, gc, x, y, text, text_length);
+  else
+    {
+      gint i;
+      gchar *mbstr = g_new (gchar, text_length);
+      
+      for (i = 0; i < text_length; i++)
+        mbstr[i] = text[i];
+      gdk_draw_text (drawable, font, gc, x, y, mbstr, text_length);
+      g_free(mbstr);
+    }
+}
+
+GtkWidget*
+gtk_entry_new_with_max_length (guint16 max)
+{
+  GtkEntry *entry;
+
+  entry = gtk_type_new (GTK_TYPE_ENTRY);
+  entry->text_max_length = max;
+
+  return GTK_WIDGET (entry);
+}
+
+void
+gtk_entry_set_text (GtkEntry *entry,
+		    const gchar *text)
+{
+  gint tmp_pos;
+
+  GtkEditable *editable;
+
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+  g_return_if_fail (text != NULL);
+
+  editable = GTK_EDITABLE (entry);
+  
+  gtk_entry_delete_text (GTK_EDITABLE(entry), 0, entry->text_length);
+
+  tmp_pos = 0;
+  gtk_editable_insert_text (editable, text, strlen (text), &tmp_pos);
+  editable->current_pos = tmp_pos;
+
+  editable->selection_start_pos = 0;
+  editable->selection_end_pos = 0;
+
+  if (GTK_WIDGET_DRAWABLE (entry))
+    gtk_entry_draw_text (entry);
+}
+
+void
+gtk_entry_append_text (GtkEntry *entry,
+		       const gchar *text)
+{
+  gint tmp_pos;
+
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+  g_return_if_fail (text != NULL);
+
+  tmp_pos = entry->text_length;
+  gtk_editable_insert_text (GTK_EDITABLE(entry), text, strlen (text), &tmp_pos);
+  GTK_EDITABLE(entry)->current_pos = tmp_pos;
+}
+
+void
+gtk_entry_prepend_text (GtkEntry *entry,
+			const gchar *text)
+{
+  gint tmp_pos;
+
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+  g_return_if_fail (text != NULL);
+
+  tmp_pos = 0;
+  gtk_editable_insert_text (GTK_EDITABLE(entry), text, strlen (text), &tmp_pos);
+  GTK_EDITABLE(entry)->current_pos = tmp_pos;
+}
+
+void
+gtk_entry_set_position (GtkEntry *entry,
+			gint      position)
+{
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  if ((position == -1) || (position > entry->text_length))
+    GTK_EDITABLE(entry)->current_pos = entry->text_length;
+  else
+    GTK_EDITABLE(entry)->current_pos = position;
+  entry_adjust_scroll (entry);
+}
+
+static void
+gtk_entry_set_position_from_editable (GtkEditable *editable,
+				      gint position)
+{
+  gtk_entry_set_position (GTK_ENTRY (editable), position);
+}
+
+void
+gtk_entry_set_visibility (GtkEntry *entry,
+			  gboolean visible)
+{
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  entry->visible = visible ? TRUE : FALSE;
+  GTK_EDITABLE (entry)->visible = visible ? TRUE : FALSE;
+  gtk_entry_recompute_offsets (entry);
+  gtk_widget_queue_draw (GTK_WIDGET (entry));
+}
+
+void
+gtk_entry_set_editable(GtkEntry *entry,
+		       gboolean  editable)
+{
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  gtk_editable_set_editable (GTK_EDITABLE (entry), editable);
+}
+
+gchar*
+gtk_entry_get_text (GtkEntry *entry)
+{
+  g_return_val_if_fail (entry != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_ENTRY (entry), NULL);
+
+  if (!entry->text_mb_dirty)
+    return entry->text_mb;
+
+  if (entry->text_mb)
+    g_free(entry->text_mb);
+
+  if (!entry->text)
+    {
+      entry->text_mb = g_new(gchar, 1);
+      entry->text_mb[0] = 0;
+    }
+  else
+    {
+      entry->text_mb = gtk_entry_get_chars(GTK_EDITABLE(entry), 0, -1);
+    }
+  entry->text_mb_dirty = 0;
+
+  return entry->text_mb;
+}
+
+static void
+gtk_entry_finalize (GtkObject *object)
+{
+  GtkEntry *entry;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (object));
+
+  entry = GTK_ENTRY (object);
+
+  if (entry->timer)
+    gtk_timeout_remove (entry->timer);
+
+  entry->text_size = 0;
+
+  if (entry->text)
+    g_free (entry->text);
+  if (entry->char_offset)
+    g_free (entry->char_offset);
+  entry->text = NULL;
+
+  if (entry->text_mb)
+    g_free (entry->text_mb);
+  entry->text_mb = NULL;
+ 
+  if (entry->backing_pixmap)
+    gdk_pixmap_unref (entry->backing_pixmap);
+
+  (* GTK_OBJECT_CLASS (parent_class)->finalize) (object);
+}
+
+static void
+gtk_entry_realize (GtkWidget *widget)
+{
+  GtkEntry *entry;
+  GtkEditable *editable;
+  GtkRequisition requisition;
+  GdkWindowAttr attributes;
+  gint attributes_mask;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (widget));
+
+  GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED);
+  entry = GTK_ENTRY (widget);
+  editable = GTK_EDITABLE (widget);
+
+  gtk_widget_get_child_requisition (widget, &requisition);
+  
+  attributes.window_type = GDK_WINDOW_CHILD;
+  attributes.x = widget->allocation.x;
+  attributes.y = widget->allocation.y + (widget->allocation.height -
+					 requisition.height) / 2;
+  attributes.width = widget->allocation.width;
+  attributes.height = requisition.height;
+  attributes.wclass = GDK_INPUT_OUTPUT;
+  attributes.visual = gtk_widget_get_visual (widget);
+  attributes.colormap = gtk_widget_get_colormap (widget);
+  attributes.event_mask = gtk_widget_get_events (widget);
+  attributes.event_mask |= (GDK_EXPOSURE_MASK |
+			    GDK_BUTTON_PRESS_MASK |
+			    GDK_BUTTON_RELEASE_MASK |
+			    GDK_BUTTON1_MOTION_MASK |
+			    GDK_BUTTON3_MOTION_MASK |
+			    GDK_POINTER_MOTION_HINT_MASK |
+			    GDK_ENTER_NOTIFY_MASK |
+			    GDK_LEAVE_NOTIFY_MASK |
+			    GDK_KEY_PRESS_MASK);
+  attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
+
+  widget->window = gdk_window_new (gtk_widget_get_parent_window (widget), &attributes, attributes_mask);
+  gdk_window_set_user_data (widget->window, entry);
+
+  attributes.x = widget->style->klass->xthickness;
+  attributes.y = widget->style->klass->ythickness;
+  attributes.width = widget->allocation.width - attributes.x * 2;
+  attributes.height = requisition.height - attributes.y * 2;
+  attributes.cursor = entry->cursor = gdk_cursor_new (GDK_XTERM);
+  attributes_mask |= GDK_WA_CURSOR;
+
+  entry->text_area = gdk_window_new (widget->window, &attributes, attributes_mask);
+  gdk_window_set_user_data (entry->text_area, entry);
+
+  widget->style = gtk_style_attach (widget->style, widget->window);
+
+  gdk_window_set_background (widget->window, &widget->style->base[GTK_WIDGET_STATE (widget)]);
+  gdk_window_set_background (entry->text_area, &widget->style->base[GTK_WIDGET_STATE (widget)]);
+
+#ifdef USE_XIM
+  if (gdk_im_ready () && (editable->ic_attr = gdk_ic_attr_new ()) != NULL)
+    {
+      gint width, height;
+      GdkEventMask mask;
+      GdkColormap *colormap;
+      GdkICAttr *attr = editable->ic_attr;
+      GdkICAttributesType attrmask = GDK_IC_ALL_REQ;
+      GdkIMStyle style;
+      GdkIMStyle supported_style = GDK_IM_PREEDIT_NONE |
+				   GDK_IM_PREEDIT_NOTHING |
+			           GDK_IM_PREEDIT_POSITION |
+			           GDK_IM_STATUS_NONE |
+				   GDK_IM_STATUS_NOTHING;
+
+      if (widget->style && widget->style->font->type != GDK_FONT_FONTSET)
+	supported_style &= ~GDK_IM_PREEDIT_POSITION;
+
+      attr->style = style = gdk_im_decide_style (supported_style);
+      attr->client_window = entry->text_area;
+
+      if ((colormap = gtk_widget_get_colormap (widget)) !=
+	    gtk_widget_get_default_colormap ())
+	{
+	  attrmask |= GDK_IC_PREEDIT_COLORMAP;
+	  attr->preedit_colormap = colormap;
+	}
+      attrmask |= GDK_IC_PREEDIT_FOREGROUND;
+      attrmask |= GDK_IC_PREEDIT_BACKGROUND;
+      attr->preedit_foreground = widget->style->fg[GTK_STATE_NORMAL];
+      attr->preedit_background = widget->style->base[GTK_STATE_NORMAL];
+
+      switch (style & GDK_IM_PREEDIT_MASK)
+	{
+	case GDK_IM_PREEDIT_POSITION:
+	  if (widget->style && widget->style->font->type != GDK_FONT_FONTSET)
+	    {
+	      g_warning ("over-the-spot style requires fontset");
+	      break;
+	    }
+
+	  gdk_window_get_size (entry->text_area, &width, &height);
+
+	  attrmask |= GDK_IC_PREEDIT_POSITION_REQ;
+	  attr->spot_location.x = 0;
+	  attr->spot_location.y = height;
+	  attr->preedit_area.x = 0;
+	  attr->preedit_area.y = 0;
+	  attr->preedit_area.width = width;
+	  attr->preedit_area.height = height;
+	  attr->preedit_fontset = widget->style->font;
+
+	  break;
+	}
+      editable->ic = gdk_ic_new (attr, attrmask);
+     
+      if (editable->ic == NULL)
+	g_warning ("Can't create input context.");
+      else
+	{
+	  mask = gdk_window_get_events (entry->text_area);
+	  mask |= gdk_ic_get_events (editable->ic);
+	  gdk_window_set_events (entry->text_area, mask);
+
+	  if (GTK_WIDGET_HAS_FOCUS(widget))
+	    gdk_im_begin (editable->ic, entry->text_area);
+	}
+    }
+#endif
+
+  gdk_window_show (entry->text_area);
+
+  if (editable->selection_start_pos != editable->selection_end_pos)
+    gtk_editable_claim_selection (editable, TRUE, GDK_CURRENT_TIME);
+
+  gtk_entry_recompute_offsets (entry);
+}
+
+static void
+gtk_entry_unrealize (GtkWidget *widget)
+{
+  GtkEntry *entry;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (widget));
+
+  entry = GTK_ENTRY (widget);
+
+#ifdef USE_XIM
+  if (GTK_EDITABLE (widget)->ic)
+    {
+      gdk_ic_destroy (GTK_EDITABLE (widget)->ic);
+      GTK_EDITABLE (widget)->ic = NULL;
+    }
+  if (GTK_EDITABLE (widget)->ic_attr)
+    {
+      gdk_ic_attr_destroy (GTK_EDITABLE (widget)->ic_attr);
+      GTK_EDITABLE (widget)->ic_attr = NULL;
+    }
+#endif
+
+  if (entry->text_area)
+    {
+      gdk_window_set_user_data (entry->text_area, NULL);
+      gdk_window_destroy (entry->text_area);
+      entry->text_area = NULL;
+      gdk_cursor_destroy (entry->cursor);
+      entry->cursor = NULL;
+    }
+
+  if (GTK_WIDGET_CLASS (parent_class)->unrealize)
+    (* GTK_WIDGET_CLASS (parent_class)->unrealize) (widget);
+}
+
+static void
+gtk_entry_draw_focus (GtkWidget *widget)
+{
+  gint width, height;
+  gint x, y;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (widget));
+
+  if (GTK_WIDGET_DRAWABLE (widget))
+    {
+      x = 0;
+      y = 0;
+      gdk_window_get_size (widget->window, &width, &height);
+
+      if (GTK_WIDGET_HAS_FOCUS (widget))
+	{
+	  x += 1;
+	  y += 1;
+	  width -= 2;
+	  height -= 2;
+	}
+
+      gtk_paint_shadow (widget->style, widget->window,
+			GTK_STATE_NORMAL, GTK_SHADOW_IN,
+			NULL, widget, "entry",
+			x, y, width, height);
+
+      if (GTK_WIDGET_HAS_FOCUS (widget))
+	{
+	   gdk_window_get_size (widget->window, &width, &height);
+	   gtk_paint_focus (widget->style, widget->window, 
+			    NULL, widget, "entry",
+			    0, 0, width - 1, height - 1);
+	}
+
+      if (GTK_EDITABLE (widget)->editable)
+	gtk_entry_draw_cursor (GTK_ENTRY (widget));
+    }
+}
+
+static void
+gtk_entry_size_request (GtkWidget      *widget,
+			GtkRequisition *requisition)
+{
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (widget));
+  g_return_if_fail (requisition != NULL);
+
+  requisition->width = MIN_ENTRY_WIDTH + (widget->style->klass->xthickness + INNER_BORDER) * 2;
+  requisition->height = (widget->style->font->ascent +
+			 widget->style->font->descent +
+			 (widget->style->klass->ythickness + INNER_BORDER) * 2);
+}
+
+static void
+gtk_entry_size_allocate (GtkWidget     *widget,
+			 GtkAllocation *allocation)
+{
+  GtkEntry *entry;
+  GtkEditable *editable;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (widget));
+  g_return_if_fail (allocation != NULL);
+
+  widget->allocation = *allocation;
+  entry = GTK_ENTRY (widget);
+  editable = GTK_EDITABLE (widget);
+
+  if (GTK_WIDGET_REALIZED (widget))
+    {
+      /* We call gtk_widget_get_child_requisition, since we want (for
+       * backwards compatibility reasons) the realization here to
+       * be affected by the usize of the entry, if set
+       */
+      GtkRequisition requisition;
+      gtk_widget_get_child_requisition (widget, &requisition);
+  
+      gdk_window_move_resize (widget->window,
+			      allocation->x,
+			      allocation->y + (allocation->height - requisition.height) / 2,
+			      allocation->width, requisition.height);
+      gdk_window_move_resize (entry->text_area,
+			      widget->style->klass->xthickness,
+			      widget->style->klass->ythickness,
+			      allocation->width - widget->style->klass->xthickness * 2,
+			      requisition.height - widget->style->klass->ythickness * 2);
+
+      /* And make sure the cursor is on screen */
+      entry_adjust_scroll (entry);
+      
+#ifdef USE_XIM
+      if (editable->ic &&
+	  (gdk_ic_get_style (editable->ic) & GDK_IM_PREEDIT_POSITION))
+	{
+	  gint width, height;
+
+	  gdk_window_get_size (entry->text_area, &width, &height);
+	  editable->ic_attr->preedit_area.width = width;
+	  editable->ic_attr->preedit_area.height = height;
+	  gdk_ic_set_attr (editable->ic, editable->ic_attr,
+	      		   GDK_IC_PREEDIT_AREA);
+	}
+#endif
+    }
+}
+
+static void
+gtk_entry_draw (GtkWidget    *widget,
+		GdkRectangle *area)
+{
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (widget));
+  g_return_if_fail (area != NULL);
+
+  if (GTK_WIDGET_DRAWABLE (widget))
+    {
+      gtk_widget_draw_focus (widget);
+      gtk_entry_draw_text (GTK_ENTRY (widget));
+    }
+}
+
+static gint
+gtk_entry_expose (GtkWidget      *widget,
+		  GdkEventExpose *event)
+{
+  GtkEntry *entry;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_ENTRY (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  entry = GTK_ENTRY (widget);
+
+  if (widget->window == event->window)
+    gtk_widget_draw_focus (widget);
+  else if (entry->text_area == event->window)
+    gtk_entry_draw_text (GTK_ENTRY (widget));
+
+  return FALSE;
+}
+
+static gint
+gtk_entry_button_press (GtkWidget      *widget,
+			GdkEventButton *event)
+{
+  GtkEntry *entry;
+  GtkEditable *editable;
+  gint tmp_pos;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_ENTRY (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  if (ctext_atom == GDK_NONE)
+    ctext_atom = gdk_atom_intern ("COMPOUND_TEXT", FALSE);
+
+  entry = GTK_ENTRY (widget);
+  editable = GTK_EDITABLE (widget);
+  
+  if (entry->button && (event->button != entry->button))
+    return FALSE;
+
+  entry->button = event->button;
+  
+  if (!GTK_WIDGET_HAS_FOCUS (widget))
+    gtk_widget_grab_focus (widget);
+
+  if (event->button == 1)
+    {
+      switch (event->type)
+	{
+	case GDK_BUTTON_PRESS:
+	  gtk_grab_add (widget);
+
+	  tmp_pos = gtk_entry_position (entry, event->x + entry->scroll_offset);
+	  /* Set it now, so we display things right. We'll unset it
+	   * later if things don't work out */
+	  editable->has_selection = TRUE;
+	  gtk_entry_set_selection (editable, tmp_pos, tmp_pos);
+	  editable->current_pos = editable->selection_start_pos;
+	  break;
+
+	case GDK_2BUTTON_PRESS:
+	  gtk_select_word (entry, event->time);
+	  break;
+
+	case GDK_3BUTTON_PRESS:
+	  gtk_select_line (entry, event->time);
+	  break;
+
+	default:
+	  break;
+	}
+
+      return TRUE;
+    }
+  else if (event->type == GDK_BUTTON_PRESS)
+    {
+      if ((event->button == 2) && editable->editable)
+	{
+	  if (editable->selection_start_pos == editable->selection_end_pos ||
+	      editable->has_selection)
+	    editable->current_pos = gtk_entry_position (entry, event->x + entry->scroll_offset);
+	  gtk_selection_convert (widget, GDK_SELECTION_PRIMARY,
+				 ctext_atom, event->time);
+	}
+      else
+	{
+	  gtk_grab_add (widget);
+
+	  tmp_pos = gtk_entry_position (entry, event->x + entry->scroll_offset);
+	  gtk_entry_set_selection (editable, tmp_pos, tmp_pos);
+	  editable->has_selection = FALSE;
+	  editable->current_pos = editable->selection_start_pos;
+
+	  if (gdk_selection_owner_get (GDK_SELECTION_PRIMARY) == widget->window)
+	    gtk_selection_owner_set (NULL, GDK_SELECTION_PRIMARY, event->time);
+	}
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gint
+gtk_entry_button_release (GtkWidget      *widget,
+			  GdkEventButton *event)
+{
+  GtkEntry *entry;
+  GtkEditable *editable;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_ENTRY (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  entry = GTK_ENTRY (widget);
+  editable = GTK_EDITABLE (widget);
+
+  if (entry->button != event->button)
+    return FALSE;
+
+  entry->button = 0;
+  
+  if (event->button == 1)
+    {
+      gtk_grab_remove (widget);
+
+      editable->has_selection = FALSE;
+      if (editable->selection_start_pos != editable->selection_end_pos)
+	{
+	  if (gtk_selection_owner_set (widget,
+				       GDK_SELECTION_PRIMARY,
+				       event->time))
+	    editable->has_selection = TRUE;
+	  else
+	    gtk_entry_queue_draw (entry);
+	}
+      else
+	{
+	  if (gdk_selection_owner_get (GDK_SELECTION_PRIMARY) == widget->window)
+	    gtk_selection_owner_set (NULL, GDK_SELECTION_PRIMARY, event->time);
+	}
+
+      return TRUE;
+    }
+  else if (event->button == 3)
+    {
+      gtk_grab_remove (widget);
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+static gint
+gtk_entry_motion_notify (GtkWidget      *widget,
+			 GdkEventMotion *event)
+{
+  GtkEntry *entry;
+  gint x;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_ENTRY (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  entry = GTK_ENTRY (widget);
+
+  if (entry->button == 0)
+    return FALSE;
+
+  x = event->x;
+  if (event->is_hint || (entry->text_area != event->window))
+    gdk_window_get_pointer (entry->text_area, &x, NULL, NULL);
+
+  GTK_EDITABLE(entry)->selection_end_pos = gtk_entry_position (entry, x + entry->scroll_offset);
+  GTK_EDITABLE(entry)->current_pos = GTK_EDITABLE(entry)->selection_end_pos;
+  entry_adjust_scroll (entry);
+  gtk_entry_queue_draw (entry);
+
+  return TRUE;
+}
+
+static gint
+gtk_entry_key_press (GtkWidget   *widget,
+		     GdkEventKey *event)
+{
+  GtkEntry *entry;
+  GtkEditable *editable;
+
+  gint return_val;
+  gint key;
+  guint initial_pos;
+  gint extend_selection;
+  gint extend_start;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_ENTRY (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  entry = GTK_ENTRY (widget);
+  editable = GTK_EDITABLE (widget);
+  return_val = FALSE;
+
+  if(editable->editable == FALSE)
+    return FALSE;
+
+  initial_pos = editable->current_pos;
+
+  extend_selection = event->state & GDK_SHIFT_MASK;
+  extend_start = FALSE;
+
+  if (extend_selection)
+    {
+      if (editable->selection_start_pos == editable->selection_end_pos)
+	{
+	  editable->selection_start_pos = editable->current_pos;
+	  editable->selection_end_pos = editable->current_pos;
+	}
+      
+      extend_start = (editable->current_pos == editable->selection_start_pos);
+    }
+
+  switch (event->keyval)
+    {
+    case GDK_BackSpace:
+      return_val = TRUE;
+      if (event->state & GDK_CONTROL_MASK)
+	gtk_delete_backward_word (entry);
+      else
+	gtk_delete_backward_character (entry);
+      break;
+    case GDK_Clear:
+      return_val = TRUE;
+      gtk_delete_line (entry);
+      break;
+    case GDK_Insert:
+      return_val = TRUE;
+      if (event->state & GDK_SHIFT_MASK)
+	{
+	  extend_selection = FALSE;
+	  gtk_editable_paste_clipboard (editable);
+	}
+      else if (event->state & GDK_CONTROL_MASK)
+	{
+	  gtk_editable_copy_clipboard (editable);
+	}
+      else
+	{
+	  /* gtk_toggle_insert(entry) -- IMPLEMENT */
+	}
+      break;
+    case GDK_Delete:
+      return_val = TRUE;
+      if (event->state & GDK_CONTROL_MASK)
+	gtk_delete_forward_word (entry);
+      else if (event->state & GDK_SHIFT_MASK)
+	{
+	  extend_selection = FALSE;
+	  gtk_editable_cut_clipboard (editable);
+	}
+      else
+	gtk_delete_forward_character (entry);
+      break;
+    case GDK_Home:
+      return_val = TRUE;
+      gtk_move_beginning_of_line (entry);
+      break;
+    case GDK_End:
+      return_val = TRUE;
+      gtk_move_end_of_line (entry);
+      break;
+    case GDK_Left:
+      return_val = TRUE;
+      if (!extend_selection &&
+	  editable->selection_start_pos != editable->selection_end_pos)
+	{
+	  editable->current_pos = MIN (editable->selection_start_pos, editable->selection_end_pos);
+	  initial_pos = (guint)-1; /* Force redraw below */
+	}
+      else
+	{
+	  if (event->state & GDK_CONTROL_MASK)
+	    gtk_move_backward_word (entry);
+	  else
+	    gtk_move_backward_character (entry);
+	}
+      break;
+    case GDK_Right:
+      return_val = TRUE;
+      if (!extend_selection &&
+	  editable->selection_start_pos != editable->selection_end_pos)
+	{
+	  editable->current_pos = MAX (editable->selection_start_pos, editable->selection_end_pos);
+	  initial_pos = (guint)-1; /* Force redraw below */
+	}
+      else
+	{
+	  if (event->state & GDK_CONTROL_MASK)
+	    gtk_move_forward_word (entry);
+	  else
+	    gtk_move_forward_character (entry);
+	}
+      break;
+    case GDK_Return:
+      return_val = TRUE;
+      gtk_widget_activate (widget);
+      break;
+    /* The next two keys should not be inserted literally. Any others ??? */
+    case GDK_Tab:
+    case GDK_Escape:
+      break;
+    default:
+      if ((event->keyval >= 0x20) && (event->keyval <= 0xFF))
+	{
+	  key = event->keyval;
+
+	  if (event->state & GDK_CONTROL_MASK)
+	    {
+	      if ((key >= 'A') && (key <= 'Z'))
+		key -= 'A' - 'a';
+
+	      if ((key >= 'a') && (key <= 'z') && control_keys[key - 'a'])
+		{
+		  (* control_keys[key - 'a']) (editable, event->time);
+		  return_val = TRUE;
+		}
+	      break;
+	    }
+	  else if (event->state & GDK_MOD1_MASK)
+	    {
+	      if ((key >= 'A') && (key <= 'Z'))
+		key -= 'A' - 'a';
+
+	      if ((key >= 'a') && (key <= 'z') && alt_keys[key - 'a'])
+		{
+		  (* alt_keys[key - 'a']) (editable, event->time);
+		  return_val = TRUE;
+		}
+	      break;
+	    }
+	}
+      if (event->length > 0)
+	{
+	  gint tmp_pos;
+
+	  extend_selection = FALSE;
+	  gtk_editable_delete_selection (editable);
+
+	  tmp_pos = editable->current_pos;
+	  gtk_editable_insert_text (editable, event->string, event->length, &tmp_pos);
+	  editable->current_pos = tmp_pos;
+
+	  return_val = TRUE;
+	}
+      break;
+    }
+
+  /* since we emit signals from within the above code,
+   * the widget might already be destroyed or at least
+   * unrealized.
+   */
+  if (GTK_WIDGET_REALIZED (editable) &&
+      return_val && (editable->current_pos != initial_pos))
+    {
+      if (extend_selection)
+	{
+	  if (editable->current_pos < editable->selection_start_pos)
+	    editable->selection_start_pos = editable->current_pos;
+	  else if (editable->current_pos > editable->selection_end_pos)
+	    editable->selection_end_pos = editable->current_pos;
+	  else
+	    {
+	      if (extend_start)
+		editable->selection_start_pos = editable->current_pos;
+	      else
+		editable->selection_end_pos = editable->current_pos;
+	    }
+	}
+      else
+	{
+	  editable->selection_start_pos = 0;
+	  editable->selection_end_pos = 0;
+	}
+
+      gtk_editable_claim_selection (editable,
+				    editable->selection_start_pos != editable->selection_end_pos,
+				    event->time);
+      
+      entry_adjust_scroll (entry);
+      gtk_entry_queue_draw (entry);
+    }
+
+  return return_val;
+}
+
+static gint
+gtk_entry_focus_in (GtkWidget     *widget,
+		    GdkEventFocus *event)
+{
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_ENTRY (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  GTK_WIDGET_SET_FLAGS (widget, GTK_HAS_FOCUS);
+  gtk_widget_draw_focus (widget);
+
+#ifdef USE_XIM
+  if (GTK_EDITABLE(widget)->ic)
+    gdk_im_begin (GTK_EDITABLE(widget)->ic, GTK_ENTRY(widget)->text_area);
+#endif
+
+  return FALSE;
+}
+
+static gint
+gtk_entry_focus_out (GtkWidget     *widget,
+		     GdkEventFocus *event)
+{
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_ENTRY (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  GTK_WIDGET_UNSET_FLAGS (widget, GTK_HAS_FOCUS);
+  gtk_widget_draw_focus (widget);
+
+#ifdef USE_XIM
+  gdk_im_end ();
+#endif
+
+  return FALSE;
+}
+
+static void
+gtk_entry_make_backing_pixmap (GtkEntry *entry, gint width, gint height)
+{
+  gint pixmap_width, pixmap_height;
+
+  if (!entry->backing_pixmap)
+    {
+      /* allocate */
+      entry->backing_pixmap = gdk_pixmap_new (entry->text_area,
+					      width, height,
+					      -1);
+    }
+  else
+    {
+      /* reallocate if sizes don't match */
+      gdk_window_get_size (entry->backing_pixmap,
+			   &pixmap_width, &pixmap_height);
+      if ((pixmap_width != width) || (pixmap_height != height))
+	{
+	  gdk_pixmap_unref (entry->backing_pixmap);
+	  entry->backing_pixmap = gdk_pixmap_new (entry->text_area,
+						  width, height,
+						  -1);
+	}
+    }
+}
+
+static void
+gtk_entry_draw_text (GtkEntry *entry)
+{
+  GtkWidget *widget;
+  GtkEditable *editable;
+  GtkStateType selected_state;
+  gint start_pos;
+  gint end_pos;
+  gint start_xoffset;
+  gint selection_start_pos;
+  gint selection_end_pos;
+  gint selection_start_xoffset;
+  gint selection_end_xoffset;
+  gint width, height;
+  gint y;
+  GdkDrawable *drawable;
+  gint use_backing_pixmap;
+  GdkWChar *stars;
+  GdkWChar *toprint;
+
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  if (entry->timer)
+    {
+      gtk_timeout_remove (entry->timer);
+      entry->timer = 0;
+    }
+
+  if (GTK_WIDGET_DRAWABLE (entry))
+    {
+      widget = GTK_WIDGET (entry);
+      editable = GTK_EDITABLE (entry);
+
+      if (!entry->text)
+	{	  
+	  gtk_paint_flat_box (widget->style, entry->text_area,
+			      GTK_WIDGET_STATE(widget), GTK_SHADOW_NONE,
+			      NULL, widget, "entry_bg", 
+			      0, 0, -1, -1);
+
+	  if (editable->editable)
+	    gtk_entry_draw_cursor (entry);
+	  return;
+	}
+
+      gdk_window_get_size (entry->text_area, &width, &height);
+
+      /*
+	If the widget has focus, draw on a backing pixmap to avoid flickering
+	and copy it to the text_area.
+	Otherwise draw to text_area directly for better speed.
+      */
+      use_backing_pixmap = GTK_WIDGET_HAS_FOCUS (widget) && (entry->text != NULL);
+      if (use_backing_pixmap)
+	{
+	   gtk_entry_make_backing_pixmap (entry, width, height);
+	   drawable = entry->backing_pixmap;
+	}
+       else
+	 {
+	    drawable = entry->text_area;
+	 }
+       gtk_paint_flat_box (widget->style, drawable, 
+			   GTK_WIDGET_STATE(widget), GTK_SHADOW_NONE,
+			   NULL, widget, "entry_bg", 
+			   0, 0, width, height);
+
+      y = (height - (widget->style->font->ascent + widget->style->font->descent)) / 2;
+      y += widget->style->font->ascent;
+
+      start_pos = gtk_entry_find_position (entry, entry->scroll_offset);
+      start_xoffset = entry->char_offset[start_pos] - entry->scroll_offset;
+
+      end_pos = gtk_entry_find_position (entry, entry->scroll_offset + width);
+      if (end_pos < entry->text_length)
+	end_pos += 1;
+
+      selected_state = GTK_STATE_SELECTED;
+      if (!editable->has_selection)
+	selected_state = GTK_STATE_ACTIVE;
+
+      selection_start_pos = MIN (editable->selection_start_pos, editable->selection_end_pos);
+      selection_end_pos = MAX (editable->selection_start_pos, editable->selection_end_pos);
+      
+      selection_start_pos = CLAMP (selection_start_pos, start_pos, end_pos);
+      selection_end_pos = CLAMP (selection_end_pos, start_pos, end_pos);
+
+      selection_start_xoffset = 
+	entry->char_offset[selection_start_pos] - entry->scroll_offset;
+      selection_end_xoffset = 
+	entry->char_offset[selection_end_pos] -entry->scroll_offset;
+
+      /* if editable->visible, print a bunch of stars.  If not, print the standard text. */
+      if (editable->visible)
+	{
+	  toprint = entry->text + start_pos;
+	}
+      else
+	{
+	  gint i;
+	  GdkWChar invisible_char = gtk_entry_get_invisible_char (entry);
+	  
+	  stars = g_new (GdkWChar, end_pos - start_pos);
+	  for (i = 0; i < end_pos - start_pos; i++)
+	    stars[i] = invisible_char;
+	  toprint = stars;
+	}
+      
+      if (selection_start_pos > start_pos)
+	gtk_entry_draw_wchars (entry, drawable, widget->style->font,
+			       widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+			       INNER_BORDER + start_xoffset, y,
+			       toprint,
+			       selection_start_pos - start_pos);
+      
+      if ((selection_end_pos >= start_pos) && 
+	  (selection_start_pos < end_pos) &&
+	  (selection_start_pos != selection_end_pos))
+	 {
+	    gtk_paint_flat_box (widget->style, drawable, 
+				selected_state, GTK_SHADOW_NONE,
+				NULL, widget, "text",
+				INNER_BORDER + selection_start_xoffset,
+				INNER_BORDER,
+				selection_end_xoffset - selection_start_xoffset,
+				height - 2*INNER_BORDER);
+	    gtk_entry_draw_wchars (entry, drawable, widget->style->font,
+				   widget->style->fg_gc[selected_state],
+				   INNER_BORDER + selection_start_xoffset, y,
+				   toprint + selection_start_pos - start_pos,
+				   selection_end_pos - selection_start_pos);
+	 }	    
+       
+       if (selection_end_pos < end_pos)
+	 gtk_entry_draw_wchars (entry, drawable, widget->style->font,
+				widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+				INNER_BORDER + selection_end_xoffset, y,
+				toprint + selection_end_pos - start_pos,
+				end_pos - selection_end_pos);
+       /* free the space allocated for the stars if it's neccessary. */
+      if (!editable->visible)
+	g_free (toprint);
+
+      if (editable->editable)
+	gtk_entry_draw_cursor_on_drawable (entry, drawable);
+
+      if (use_backing_pixmap)
+	gdk_draw_pixmap(entry->text_area,
+			widget->style->fg_gc[GTK_STATE_NORMAL],
+			entry->backing_pixmap,
+			0, 0, 0, 0, width, height);	  
+    }
+}
+
+static void
+gtk_entry_draw_cursor (GtkEntry *entry)
+{
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  gtk_entry_draw_cursor_on_drawable (entry, entry->text_area);
+}
+
+static void
+gtk_entry_draw_cursor_on_drawable (GtkEntry *entry, GdkDrawable *drawable)
+{
+  GtkWidget *widget;
+  GtkEditable *editable;
+  gint xoffset;
+  gint text_area_height;
+
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  if (GTK_WIDGET_DRAWABLE (entry))
+    {
+      widget = GTK_WIDGET (entry);
+      editable = GTK_EDITABLE (entry);
+
+      xoffset = INNER_BORDER + entry->char_offset[editable->current_pos];
+      xoffset -= entry->scroll_offset;
+
+      gdk_window_get_size (entry->text_area, NULL, &text_area_height);
+
+      if (GTK_WIDGET_HAS_FOCUS (widget) &&
+	  (editable->selection_start_pos == editable->selection_end_pos))
+	{
+	  gdk_draw_line (drawable, widget->style->fg_gc[GTK_STATE_NORMAL], 
+			 xoffset, INNER_BORDER,
+			 xoffset, text_area_height - INNER_BORDER);
+	}
+      else
+	{
+	  gint yoffset = 
+	    (text_area_height - 
+	     (widget->style->font->ascent + widget->style->font->descent)) / 2
+	    + widget->style->font->ascent;
+
+	  gtk_paint_flat_box (widget->style, drawable,
+			      GTK_WIDGET_STATE(widget), GTK_SHADOW_NONE,
+			      NULL, widget, "entry_bg", 
+			      xoffset, INNER_BORDER, 
+			      1, text_area_height - INNER_BORDER);
+	  
+	  /* Draw the character under the cursor again
+	   */
+	  if ((editable->current_pos < entry->text_length) &&
+	      (editable->selection_start_pos == editable->selection_end_pos))
+	    {
+	      GdkWChar c = editable->visible ?
+		                 *(entry->text + editable->current_pos) :
+		                 '*';
+	      
+	      gtk_entry_draw_wchars (entry, drawable, widget->style->font,
+				     widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+				     xoffset, yoffset, &c, 1);
+	    }
+	}
+
+
+#ifdef USE_XIM
+      if (GTK_WIDGET_HAS_FOCUS(widget) && gdk_im_ready() && editable->ic && 
+	  (gdk_ic_get_style (editable->ic) & GDK_IM_PREEDIT_POSITION))
+	{
+	  editable->ic_attr->spot_location.x = xoffset;
+	  editable->ic_attr->spot_location.y =
+	    (text_area_height + (widget->style->font->ascent
+	        - widget->style->font->descent) + 1) / 2;
+
+	  gdk_ic_set_attr (editable->ic,
+	      		   editable->ic_attr, GDK_IC_SPOT_LOCATION);
+	}
+#endif 
+    }
+}
+
+static void
+gtk_entry_queue_draw (GtkEntry *entry)
+{
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  if (!entry->timer)
+    entry->timer = gtk_timeout_add (DRAW_TIMEOUT, gtk_entry_timer, entry);
+}
+
+static gint
+gtk_entry_timer (gpointer data)
+{
+  GtkEntry *entry;
+
+  GDK_THREADS_ENTER ();
+
+  entry = GTK_ENTRY (data);
+  entry->timer = 0;
+  gtk_entry_draw_text (entry);
+
+  GDK_THREADS_LEAVE ();
+
+  return FALSE;
+}
+
+static gint
+gtk_entry_find_position (GtkEntry *entry,
+			 gint      x)
+{
+  gint start = 0;
+  gint end = entry->text_length;
+  gint half;
+
+  if (x <= 0)
+    return 0;
+  if (x >= entry->char_offset[end])
+    return end;
+  
+  /* invariant - char_offset[start] <= x < char_offset[end] */
+
+  while (start != end)
+    {
+      half = (start+end)/2;
+      if (half == start)
+	return half;
+      else if (entry->char_offset[half] <= x)
+	start = half;
+      else
+	end = half;
+    }
+
+  return start;
+}
+
+static gint
+gtk_entry_position (GtkEntry *entry,
+		    gint      x)
+{
+  return gtk_entry_find_position(entry, x);
+}
+
+static void
+entry_adjust_scroll (GtkEntry *entry)
+{
+  gint xoffset, max_offset;
+  gint text_area_width;
+
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  if (!entry->text_area)
+    return;
+
+  gdk_window_get_size (entry->text_area, &text_area_width, NULL);
+  text_area_width -= 2 * INNER_BORDER;
+
+  /* Display as much text as we can */
+  max_offset = MAX(0, entry->char_offset[entry->text_length] - text_area_width);
+
+  if (entry->scroll_offset > max_offset)
+    entry->scroll_offset = max_offset;
+
+  /* And make sure cursor is on screen. Note that the cursor is
+   * actually drawn one pixel into the INNER_BORDER space on
+   * the right, when the scroll is at the utmost right. This
+   * looks better to to me than confining the cursor inside the
+   * border entirely, though it means that the cursor gets one
+   * pixel closer to the the edge of the widget on the right than
+   * on the left. This might need changing if one changed
+   * INNER_BORDER from 2 to 1, as one would do on a
+   * small-screen-real-estate display.
+   */
+  xoffset = entry->char_offset[GTK_EDITABLE(entry)->current_pos];
+  xoffset -= entry->scroll_offset;
+
+  if (xoffset < 0)
+    entry->scroll_offset += xoffset;
+  else if (xoffset > text_area_width)
+    entry->scroll_offset += xoffset - text_area_width;
+
+  gtk_widget_queue_draw (GTK_WIDGET (entry));
+}
+
+static void
+gtk_entry_grow_text (GtkEntry *entry)
+{
+  gint previous_size;
+  gint i;
+
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  previous_size = entry->text_size;
+  if (!entry->text_size)
+    entry->text_size = 128;
+  else
+    entry->text_size *= 2;
+  entry->text = g_realloc (entry->text, entry->text_size * sizeof(GdkWChar));
+  entry->char_offset = g_realloc (entry->char_offset, 
+				  entry->text_size * sizeof(guint));
+
+  if (entry->text_length == 0)	/* initial allocation */
+    {
+      entry->char_offset[0] = 0;
+    }
+
+  for (i = previous_size; i < entry->text_size; i++)
+    entry->text[i] = '\0';
+}
+
+static void
+gtk_entry_insert_text (GtkEditable *editable,
+		       const gchar *new_text,
+		       gint         new_text_length,
+		       gint        *position)
+{
+  GdkWChar *text;
+  gint start_pos;
+  gint end_pos;
+  gint last_pos;
+  gint max_length;
+  gint i;
+
+  guchar *new_text_nt;
+  gint insertion_length;
+  GdkWChar *insertion_text;
+  
+  GtkEntry *entry;
+  GtkWidget *widget;
+  
+  g_return_if_fail (editable != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (editable));
+
+  entry = GTK_ENTRY (editable);
+  widget = GTK_WIDGET (editable);
+
+  if ((entry->text_length == 0) && (entry->use_wchar == FALSE))
+    {
+      if (!GTK_WIDGET_REALIZED (widget))
+	gtk_widget_ensure_style (widget);
+      if ((widget->style) && (widget->style->font->type == GDK_FONT_FONTSET))
+	entry->use_wchar = TRUE;
+    }
+
+  if (new_text_length < 0)
+    {
+      new_text_nt = (gchar *)new_text;
+      new_text_length = strlen (new_text);
+      if (new_text_length <= 0) return;
+    }
+  else if (new_text_length == 0)
+    {
+      return;
+    }
+  else
+    {
+      /* make a null-terminated copy of new_text */
+      new_text_nt = g_new (gchar, new_text_length + 1);
+      memcpy (new_text_nt, new_text, new_text_length);
+      new_text_nt[new_text_length] = 0;
+    }
+    
+  /* The algorithms here will work as long as, the text size (a
+   * multiple of 2), fits into a guint16 but we specify a shorter
+   * maximum length so that if the user pastes a very long text, there
+   * is not a long hang from the slow X_LOCALE functions.  */
+ 
+  if (entry->text_max_length == 0)
+    max_length = 2047;
+  else
+    max_length = MIN (2047, entry->text_max_length);
+
+  /* Convert to wide characters */
+  insertion_text = g_new (GdkWChar, new_text_length);
+  if (entry->use_wchar)
+    insertion_length = gdk_mbstowcs (insertion_text, new_text_nt,
+				     new_text_length);
+  else
+    for (insertion_length=0; new_text_nt[insertion_length]; insertion_length++)
+      insertion_text[insertion_length] = new_text_nt[insertion_length];
+  if (new_text_nt != (guchar *)new_text)
+    g_free (new_text_nt);
+
+  /* Make sure we do not exceed the maximum size of the entry. */
+  if (insertion_length + entry->text_length > max_length)
+    insertion_length = max_length - entry->text_length;
+
+  /* Don't insert anything, if there was nothing to insert. */
+  if (insertion_length <= 0)
+    {
+      g_free(insertion_text);
+      return;
+    }
+
+  /* Make sure we are inserting at integral character position */
+  start_pos = *position;
+  if (start_pos < 0)
+    start_pos = 0;
+  else if (start_pos > entry->text_length)
+    start_pos = entry->text_length;
+
+  end_pos = start_pos + insertion_length;
+  last_pos = insertion_length + entry->text_length;
+
+  if (editable->selection_start_pos >= *position)
+    editable->selection_start_pos += insertion_length;
+  if (editable->selection_end_pos >= *position)
+    editable->selection_end_pos += insertion_length;
+
+  while (last_pos >= entry->text_size)
+    gtk_entry_grow_text (entry);
+
+  text = entry->text;
+  for (i = last_pos - 1; i >= end_pos; i--)
+    text[i] = text[i- (end_pos - start_pos)];
+  for (i = start_pos; i < end_pos; i++)
+    text[i] = insertion_text[i - start_pos];
+  g_free (insertion_text);
+
+  /* Fix up the the character offsets */
+  
+  if (GTK_WIDGET_REALIZED (entry))
+    {
+      gint offset = 0;
+      
+      for (i = last_pos; i >= end_pos; i--)
+	entry->char_offset[i] = entry->char_offset[i - insertion_length];
+      
+      for (i=start_pos; i<end_pos; i++)
+	{
+	  GdkWChar ch;
+
+	  entry->char_offset[i] = entry->char_offset[start_pos] + offset;
+
+	  if (editable->visible)
+	    ch = entry->text[i];
+	  else 
+	    ch = gtk_entry_get_invisible_char (entry);
+
+	  if (entry->use_wchar)
+	    offset += gdk_char_width_wc (GTK_WIDGET (entry)->style->font, ch);
+	  else
+	    offset += gdk_char_width (GTK_WIDGET (entry)->style->font, ch);
+	}
+      for (i = end_pos; i <= last_pos; i++)
+	entry->char_offset[i] += offset;
+    }
+
+  entry->text_length += insertion_length;
+  *position = end_pos;
+
+  entry->text_mb_dirty = 1;
+  gtk_entry_queue_draw (entry);
+}
+
+/* Recompute the x offsets of all characters in the buffer */
+static void
+gtk_entry_recompute_offsets (GtkEntry *entry)
+{
+  gint i;
+  gint offset = 0;
+  GtkEditable *editable = GTK_EDITABLE (entry);
+
+  for (i=0; i<entry->text_length; i++)
+    {
+      GdkWChar ch;
+
+      entry->char_offset[i] = offset;
+
+      if (editable->visible)
+	ch = entry->text[i];
+      else
+	ch = gtk_entry_get_invisible_char (entry);
+
+      if (entry->use_wchar)
+	offset += gdk_char_width_wc (GTK_WIDGET (entry)->style->font, ch);
+      else
+	offset += gdk_char_width (GTK_WIDGET (entry)->style->font, ch);
+    }
+  
+  entry->char_offset[i] = offset;
+}
+
+static void
+gtk_entry_delete_text (GtkEditable *editable,
+		       gint         start_pos,
+		       gint         end_pos)
+{
+  GdkWChar *text;
+  gint deletion_length;
+  gint i;
+
+  GtkEntry *entry;
+  
+  g_return_if_fail (editable != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (editable));
+
+  entry = GTK_ENTRY (editable);
+
+  if (end_pos < 0)
+    end_pos = entry->text_length;
+
+  if (editable->selection_start_pos > start_pos)
+    editable->selection_start_pos -= MIN(end_pos, editable->selection_start_pos) - start_pos;
+  if (editable->selection_end_pos > start_pos)
+    editable->selection_end_pos -= MIN(end_pos, editable->selection_end_pos) - start_pos;
+  
+  if ((start_pos < end_pos) &&
+      (start_pos >= 0) &&
+      (end_pos <= entry->text_length))
+    {
+      text = entry->text;
+      deletion_length = end_pos - start_pos;
+
+      /* Fix up the character offsets */
+      if (GTK_WIDGET_REALIZED (entry))
+	{
+	  gint deletion_width = 
+	    entry->char_offset[end_pos] - entry->char_offset[start_pos];
+
+	  for (i = 0 ; i <= entry->text_length - end_pos; i++)
+	    entry->char_offset[start_pos+i] = entry->char_offset[end_pos+i] - deletion_width;
+	}
+
+      for (i = end_pos; i < entry->text_length; i++)
+        text[i - deletion_length] = text[i];
+
+      for (i = entry->text_length - deletion_length; i < entry->text_length; i++)
+        text[i] = '\0';
+
+      entry->text_length -= deletion_length;
+      editable->current_pos = start_pos;
+    }
+
+  entry->text_mb_dirty = 1;
+  gtk_entry_queue_draw (entry);
+}
+
+static void
+gtk_entry_update_text (GtkEditable *editable,
+		       gint         start_pos,
+		       gint         end_pos)
+{
+  gtk_entry_queue_draw (GTK_ENTRY(editable));
+}
+
+static gchar *    
+gtk_entry_get_chars      (GtkEditable   *editable,
+			  gint           start_pos,
+			  gint           end_pos)
+{
+  GtkEntry *entry;
+  
+  g_return_val_if_fail (editable != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_ENTRY (editable), NULL);
+
+  entry = GTK_ENTRY (editable);
+
+  if (end_pos < 0)
+    end_pos = entry->text_length;
+
+  start_pos = MIN(entry->text_length, start_pos);
+  end_pos = MIN(entry->text_length, end_pos);
+
+  if (start_pos <= end_pos)
+    {
+      guchar *mbstr;
+      if (entry->use_wchar)
+	{
+	  GdkWChar ch;
+	  if (end_pos >= entry->text_size)
+	    gtk_entry_grow_text(entry);
+	  ch = entry->text[end_pos];
+	  entry->text[end_pos] = 0;
+	  mbstr = gdk_wcstombs (entry->text + start_pos);
+	  entry->text[end_pos] = ch;
+	  return (gchar *)mbstr;
+	}
+      else
+	{
+	  gint i;
+	  mbstr = g_new (gchar, end_pos - start_pos + 1);
+	  for (i=0; i<end_pos-start_pos; i++)
+	    mbstr[i] = entry->text[start_pos + i];
+	  mbstr[i] = 0;
+	  return (gchar *)mbstr;
+	}
+    }
+  else
+    return NULL;
+}
+
+static void 
+gtk_entry_move_cursor (GtkEditable *editable,
+		       gint         x,
+		       gint         y)
+{
+  GtkEntry *entry;
+  entry = GTK_ENTRY (editable);
+
+  /* Horizontal motion */
+  if ((gint)editable->current_pos < -x)
+    editable->current_pos = 0;
+  else if (editable->current_pos + x > entry->text_length)
+    editable->current_pos = entry->text_length;
+  else
+    editable->current_pos += x;
+
+  /* Ignore vertical motion */
+}
+
+static void
+gtk_move_forward_character (GtkEntry *entry)
+{
+  gtk_entry_move_cursor (GTK_EDITABLE (entry), 1, 0);
+}
+
+static void
+gtk_move_backward_character (GtkEntry *entry)
+{
+  gtk_entry_move_cursor (GTK_EDITABLE (entry), -1, 0);
+}
+
+static void 
+gtk_entry_move_word (GtkEditable *editable,
+		     gint         n)
+{
+  while (n > 0)
+    {
+      gtk_move_forward_word (GTK_ENTRY (editable));
+      n--;
+    }
+  while (n < 0)
+    {
+      gtk_move_backward_word (GTK_ENTRY (editable));
+      n++;
+    }
+}
+
+static void
+gtk_move_forward_word (GtkEntry *entry)
+{
+  GtkEditable *editable;
+  GdkWChar *text;
+  gint i;
+
+  editable = GTK_EDITABLE (entry);
+
+  /* Prevent any leak of information */
+  if (!editable->visible)
+    {
+      editable->current_pos = entry->text_length;
+      return;
+    }
+
+  if (entry->text && (editable->current_pos < entry->text_length))
+    {
+      text = entry->text;
+      i = editable->current_pos;
+	  
+      if ((entry->use_wchar) ? (!gdk_iswalnum (text[i])) : (!isalnum (text[i])))
+	for (; i < entry->text_length; i++)
+	  {
+	    if ((entry->use_wchar) ? gdk_iswalnum (text[i]) : isalnum (text[i]))
+	      break;
+	  }
+
+      for (; i < entry->text_length; i++)
+	{
+	  if ((entry->use_wchar) ? (!gdk_iswalnum (text[i])) : (!isalnum (text[i])))
+	    break;
+	}
+
+      editable->current_pos = i;
+    }
+}
+
+static void
+gtk_move_backward_word (GtkEntry *entry)
+{
+  GtkEditable *editable;
+  GdkWChar *text;
+  gint i;
+
+  editable = GTK_EDITABLE (entry);
+
+  /* Prevent any leak of information */
+  if (!editable->visible)
+    {
+      editable->current_pos = 0;
+      return;
+    }
+
+  if (entry->text && editable->current_pos > 0)
+    {
+      text = entry->text;
+      i = editable->current_pos - 1;
+      if ((entry->use_wchar) ? (!gdk_iswalnum (text[i])) : (!isalnum (text[i])))
+	for (; i >= 0; i--)
+	  {
+	    if ((entry->use_wchar) ? gdk_iswalnum (text[i]) : isalnum (text[i]))
+	      break;
+	  }
+      for (; i >= 0; i--)
+	{
+	  if ((entry->use_wchar) ? (!gdk_iswalnum (text[i])) : (!isalnum (text[i])))
+	    {
+	      i++;
+	      break;
+	    }
+	}
+	  
+      if (i < 0)
+	i = 0;
+	  
+      editable->current_pos = i;
+    }
+}
+
+static void
+gtk_entry_move_to_column (GtkEditable *editable, gint column)
+{
+  GtkEntry *entry;
+
+  entry = GTK_ENTRY (editable);
+  
+  if (column < 0 || column > entry->text_length)
+    editable->current_pos = entry->text_length;
+  else
+    editable->current_pos = column;
+}
+
+static void
+gtk_move_beginning_of_line (GtkEntry *entry)
+{
+  gtk_entry_move_to_column (GTK_EDITABLE (entry), 0);
+}
+
+static void
+gtk_move_end_of_line (GtkEntry *entry)
+{
+  gtk_entry_move_to_column (GTK_EDITABLE (entry), -1);
+}
+
+static void
+gtk_entry_kill_char (GtkEditable *editable,
+		     gint         direction)
+{
+  if (editable->selection_start_pos != editable->selection_end_pos)
+    gtk_editable_delete_selection (editable);
+  else
+    {
+      gint old_pos = editable->current_pos;
+      if (direction >= 0)
+	{
+	  gtk_entry_move_cursor (editable, 1, 0);
+	  gtk_editable_delete_text (editable, old_pos, editable->current_pos);
+	}
+      else
+	{
+	  gtk_entry_move_cursor (editable, -1, 0);
+	  gtk_editable_delete_text (editable, editable->current_pos, old_pos);
+	}
+    }
+}
+
+static void
+gtk_delete_forward_character (GtkEntry *entry)
+{
+  gtk_entry_kill_char (GTK_EDITABLE (entry), 1);
+}
+
+static void
+gtk_delete_backward_character (GtkEntry *entry)
+{
+  gtk_entry_kill_char (GTK_EDITABLE (entry), -1);
+}
+
+static void
+gtk_entry_kill_word (GtkEditable *editable,
+		     gint         direction)
+{
+  if (editable->selection_start_pos != editable->selection_end_pos)
+    gtk_editable_delete_selection (editable);
+  else
+    {
+      gint old_pos = editable->current_pos;
+      if (direction >= 0)
+	{
+	  gtk_entry_move_word (editable, 1);
+	  gtk_editable_delete_text (editable, old_pos, editable->current_pos);
+	}
+      else
+	{
+	  gtk_entry_move_word (editable, -1);
+	  gtk_editable_delete_text (editable, editable->current_pos, old_pos);
+	}
+    }
+}
+
+static void
+gtk_delete_forward_word (GtkEntry *entry)
+{
+  gtk_entry_kill_word (GTK_EDITABLE (entry), 1);
+}
+
+static void
+gtk_delete_backward_word (GtkEntry *entry)
+{
+  gtk_entry_kill_word (GTK_EDITABLE (entry), -1);
+}
+
+static void
+gtk_entry_kill_line (GtkEditable *editable,
+		     gint         direction)
+{
+  gint old_pos = editable->current_pos;
+  if (direction >= 0)
+    {
+      gtk_entry_move_to_column (editable, -1);
+      gtk_editable_delete_text (editable, old_pos, editable->current_pos);
+    }
+  else
+    {
+      gtk_entry_move_to_column (editable, 0);
+      gtk_editable_delete_text (editable, editable->current_pos, old_pos);
+    }
+}
+
+static void
+gtk_delete_line (GtkEntry *entry)
+{
+  gtk_entry_move_to_column (GTK_EDITABLE (entry), 0);
+  gtk_entry_kill_line (GTK_EDITABLE (entry), 1);
+}
+
+static void
+gtk_delete_to_line_end (GtkEntry *entry)
+{
+  gtk_editable_delete_text (GTK_EDITABLE(entry), GTK_EDITABLE(entry)->current_pos, entry->text_length);
+}
+
+static void
+gtk_select_word (GtkEntry *entry,
+		 guint32   time)
+{
+  GtkEditable *editable;
+  gint start_pos;
+  gint end_pos;
+
+  editable = GTK_EDITABLE (entry);
+
+  gtk_move_backward_word (entry);
+  start_pos = editable->current_pos;
+
+  gtk_move_forward_word (entry);
+  end_pos = editable->current_pos;
+
+  editable->has_selection = TRUE;
+  gtk_entry_set_selection (editable, start_pos, end_pos);
+  gtk_editable_claim_selection (editable, start_pos != end_pos, time);
+}
+
+static void
+gtk_select_line (GtkEntry *entry,
+		 guint32   time)
+{
+  GtkEditable *editable;
+
+  editable = GTK_EDITABLE (entry);
+
+  editable->has_selection = TRUE;
+  gtk_entry_set_selection (editable, 0, entry->text_length);
+  gtk_editable_claim_selection (editable, entry->text_length != 0, time);
+
+  editable->current_pos = editable->selection_end_pos;
+}
+
+static void 
+gtk_entry_set_selection (GtkEditable       *editable,
+			 gint               start,
+			 gint               end)
+{
+  gint length = GTK_ENTRY (editable)->text_length;
+  
+  g_return_if_fail (editable != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (editable));
+
+  if (end < 0)
+    end = length;
+  
+  editable->selection_start_pos = CLAMP (start, 0, length);
+  editable->selection_end_pos = MIN (end, length);
+
+  gtk_entry_queue_draw (GTK_ENTRY (editable));
+}
+
+void       
+gtk_entry_select_region  (GtkEntry       *entry,
+			  gint            start,
+			  gint            end)
+{
+  gtk_editable_select_region (GTK_EDITABLE (entry), start, end);
+}
+
+void
+gtk_entry_set_max_length (GtkEntry     *entry,
+                          guint16       max)
+{
+  g_return_if_fail (entry != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (entry));
+
+  if (max && entry->text_length > max)
+  	gtk_editable_delete_text(GTK_EDITABLE(entry), max, -1);
+  entry->text_max_length = max;
+}
+
+#ifdef USE_XIM
+static void
+gtk_entry_update_ic_attr (GtkWidget *widget)
+{
+  GtkEditable *editable = (GtkEditable *) widget;
+  GdkICAttributesType mask = 0;
+
+  if (editable->ic == NULL)
+    return;
+
+  gdk_ic_get_attr (editable->ic, editable->ic_attr,
+		   GDK_IC_PREEDIT_FOREGROUND |
+		   GDK_IC_PREEDIT_BACKGROUND |
+		   GDK_IC_PREEDIT_FONTSET);
+
+  if (editable->ic_attr->preedit_foreground.pixel != 
+      widget->style->fg[GTK_STATE_NORMAL].pixel)
+    {
+      mask |= GDK_IC_PREEDIT_FOREGROUND;
+      editable->ic_attr->preedit_foreground
+	= widget->style->fg[GTK_STATE_NORMAL];
+    }
+  if (editable->ic_attr->preedit_background.pixel != 
+      widget->style->base[GTK_STATE_NORMAL].pixel)
+    {
+      mask |= GDK_IC_PREEDIT_BACKGROUND;
+      editable->ic_attr->preedit_background
+	= widget->style->base[GTK_STATE_NORMAL];
+    }
+  if ((gdk_ic_get_style (editable->ic) & GDK_IM_PREEDIT_POSITION) && 
+      widget->style->font != NULL &&
+      widget->style->font->type == GDK_FONT_FONTSET &&
+      !gdk_font_equal (editable->ic_attr->preedit_fontset,
+		       widget->style->font))
+    {
+      mask |= GDK_IC_PREEDIT_FONTSET;
+      editable->ic_attr->preedit_fontset = widget->style->font;
+    }
+  
+  if (mask)
+    gdk_ic_set_attr (editable->ic, editable->ic_attr, mask);
+}
+#endif /* USE_XIM */
+    			  
+static void 
+gtk_entry_style_set	(GtkWidget      *widget,
+			 GtkStyle       *previous_style)
+{
+  GtkEntry *entry;
+  gint scroll_char;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (widget));
+
+  if (previous_style && GTK_WIDGET_REALIZED (widget))
+    {
+      entry = GTK_ENTRY (widget);
+  
+      scroll_char = gtk_entry_find_position (entry, entry->scroll_offset);
+      gtk_entry_recompute_offsets (GTK_ENTRY (widget));
+      entry->scroll_offset = entry->char_offset[scroll_char];
+      entry_adjust_scroll (entry);
+
+      gdk_window_set_background (widget->window, &widget->style->base[GTK_WIDGET_STATE (widget)]);
+      gdk_window_set_background (entry->text_area, &widget->style->base[GTK_WIDGET_STATE (widget)]);
+
+#ifdef USE_XIM
+      gtk_entry_update_ic_attr (widget);
+#endif
+    }
+}
+
+static void
+gtk_entry_state_changed (GtkWidget      *widget,
+			 GtkStateType    previous_state)
+{
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_ENTRY (widget));
+
+  if (GTK_WIDGET_REALIZED (widget))
+    {
+      gdk_window_set_background (widget->window, &widget->style->base[GTK_WIDGET_STATE (widget)]);
+      gdk_window_set_background (GTK_ENTRY (widget)->text_area, &widget->style->base[GTK_WIDGET_STATE (widget)]);
+
+#ifdef USE_XIM
+      gtk_entry_update_ic_attr (widget);
+#endif
+    }
+
+  if (GTK_WIDGET_DRAWABLE (widget))
+    gtk_widget_queue_clear(widget);
+}
diff -uNr a/gtk/gtkfilesel.c b/gtk/gtkfilesel.c
--- a/gtk/gtkfilesel.c	Thu Feb 15 23:36:19 2001
+++ b/gtk/gtkfilesel.c	Mon May 27 17:47:20 2002
@@ -55,6 +55,1745 @@
 #include "gtkclist.h"
 #include "gtkdialog.h"
 #include "gtkintl.h"
+#include "gtkpixmap.h"
+
+static char * home_xpm[] = {
+"48 48 714 2",
+"  	c None",
+". 	c #634D3A",
+"+ 	c #9C8871",
+"@ 	c #654E3D",
+"# 	c #35271C",
+"$ 	c #000000",
+"% 	c #050101",
+"& 	c #0B0301",
+"* 	c #080100",
+"= 	c #0F0402",
+"- 	c #B0A08D",
+"; 	c #7C6859",
+"> 	c #9C8B7C",
+", 	c #523D31",
+"' 	c #271D16",
+") 	c #200806",
+"! 	c #C6918A",
+"~ 	c #8D2C22",
+"{ 	c #541812",
+"] 	c #6E1C15",
+"^ 	c #020000",
+"/ 	c #B6A996",
+"( 	c #716052",
+"_ 	c #453324",
+": 	c #3F2E24",
+"< 	c #C3B7B0",
+"[ 	c #443529",
+"} 	c #1B140F",
+"| 	c #110403",
+"1 	c #581A14",
+"2 	c #49120D",
+"3 	c #49130E",
+"4 	c #42110C",
+"5 	c #0A0101",
+"6 	c #A79A87",
+"7 	c #837566",
+"8 	c #423124",
+"9 	c #231B15",
+"0 	c #4B423A",
+"a 	c #6B5D52",
+"b 	c #D1C9C3",
+"c 	c #3D3127",
+"d 	c #16100C",
+"e 	c #371915",
+"f 	c #B46B60",
+"g 	c #60221C",
+"h 	c #69201A",
+"i 	c #681F19",
+"j 	c #96836F",
+"k 	c #9F9185",
+"l 	c #5D4A39",
+"m 	c #0F0C09",
+"n 	c #3A3632",
+"o 	c #9A9C99",
+"p 	c #453B33",
+"q 	c #8A7C71",
+"r 	c #C4BAB0",
+"s 	c #2E241C",
+"t 	c #110C09",
+"u 	c #1D0806",
+"v 	c #62221C",
+"w 	c #541611",
+"x 	c #46120D",
+"y 	c #A2917D",
+"z 	c #AEA397",
+"A 	c #806B58",
+"B 	c #25201B",
+"C 	c #525251",
+"D 	c #949493",
+"E 	c #656665",
+"F 	c #6E6259",
+"G 	c #72665C",
+"H 	c #D4CDC6",
+"I 	c #261D18",
+"J 	c #2E0E0B",
+"K 	c #A64D41",
+"L 	c #603429",
+"M 	c #968772",
+"N 	c #B7AEA3",
+"O 	c #7F6C5D",
+"P 	c #0E0B09",
+"Q 	c #211C18",
+"R 	c #BABAB9",
+"S 	c #494948",
+"T 	c #B4B5B4",
+"U 	c #565655",
+"V 	c #B7B9B7",
+"W 	c #85807A",
+"X 	c #66594F",
+"Y 	c #BDB2A7",
+"Z 	c #3A2D23",
+"` 	c #080504",
+" .	c #2B231D",
+"..	c #190605",
+"+.	c #9F5546",
+"@.	c #998A77",
+"#.	c #B0A599",
+"$.	c #6F6254",
+"%.	c #0B0907",
+"&.	c #1F1B18",
+"*.	c #5C5C5A",
+"=.	c #B9B9B7",
+"-.	c #40403F",
+";.	c #CFD1CF",
+">.	c #565656",
+",.	c #D2D2D2",
+"'.	c #939391",
+").	c #918D88",
+"!.	c #3C2E25",
+"~.	c #A39385",
+"{.	c #5C4B40",
+"].	c #29211B",
+"^.	c #423B32",
+"/.	c #9A8B77",
+"(.	c #A99D91",
+"_.	c #564B40",
+":.	c #070605",
+"<.	c #1A1715",
+"[.	c #A6A6A5",
+"}.	c #4F514F",
+"|.	c #3A3B3A",
+"1.	c #E4E4E4",
+"2.	c #606060",
+"3.	c #A5A6A5",
+"4.	c #9D9D9C",
+"5.	c #75716E",
+"6.	c #281E17",
+"7.	c #A29387",
+"8.	c #6F5D4F",
+"9.	c #090605",
+"0.	c #271F19",
+"a.	c #B4A58D",
+"b.	c #978777",
+"c.	c #BEB5AA",
+"d.	c #4B4139",
+"e.	c #080605",
+"f.	c #1E1B19",
+"g.	c #666665",
+"h.	c #B1B1B0",
+"i.	c #5A5A5A",
+"j.	c #BEBEBD",
+"k.	c #555555",
+"l.	c #EAEAEA",
+"m.	c #696969",
+"n.	c #E7E7E7",
+"o.	c #A9A9A9",
+"p.	c #C2C3C2",
+"q.	c #686968",
+"r.	c #9C9996",
+"s.	c #2E221B",
+"t.	c #837569",
+"u.	c #685446",
+"v.	c #AA9A85",
+"w.	c #B5A997",
+"x.	c #D2CCC3",
+"y.	c #3D352D",
+"z.	c #080705",
+"A.	c #23201C",
+"B.	c #B2B2B1",
+"C.	c #AEAEAE",
+"D.	c #7D7D7D",
+"E.	c #DADADA",
+"F.	c #777777",
+"G.	c #999999",
+"H.	c #EBEBEB",
+"I.	c #A7A7A7",
+"J.	c #DDDDDD",
+"K.	c #A5A5A3",
+"L.	c #6E6B68",
+"M.	c #332921",
+"N.	c #68564A",
+"O.	c #634D3D",
+"P.	c #16100B",
+"Q.	c #1B130F",
+"R.	c #A0907A",
+"S.	c #D1C8B9",
+"T.	c #A2968A",
+"U.	c #28221C",
+"V.	c #0B0908",
+"W.	c #4A4641",
+"X.	c #828280",
+"Y.	c #EFEFEF",
+"Z.	c #858585",
+"`.	c #E9E9E9",
+" +	c #979797",
+".+	c #EEEEEE",
+"++	c #9A9A9A",
+"@+	c #6F6F6F",
+"#+	c #D4D4D4",
+"$+	c #5F5F5D",
+"%+	c #9C9C99",
+"&+	c #2D251E",
+"*+	c #5D4D40",
+"=+	c #6B5545",
+"-+	c #2B1F16",
+";+	c #C0B199",
+">+	c #E7E1D6",
+",+	c #756B5F",
+"'+	c #18130F",
+")+	c #100D0A",
+"!+	c #595551",
+"~+	c #B7B7B6",
+"{+	c #585958",
+"]+	c #A9A9A7",
+"^+	c #6E6F6E",
+"/+	c #C6C8C6",
+"(+	c #8E8E8E",
+"_+	c #F2F2F2",
+":+	c #E8E8E8",
+"<+	c #A0A0A0",
+"[+	c #9C9C9C",
+"}+	c #F0F0F0",
+"|+	c #8D8D8D",
+"1+	c #777775",
+"2+	c #AAAAA9",
+"3+	c #74726F",
+"4+	c #271F1A",
+"5+	c #58483B",
+"6+	c #695442",
+"7+	c #39291D",
+"8+	c #231D1A",
+"9+	c #B7A994",
+"0+	c #F3ECDA",
+"a+	c #DAD4C9",
+"b+	c #5F524A",
+"c+	c #94918D",
+"d+	c #717271",
+"e+	c #B6B6B5",
+"f+	c #686866",
+"g+	c #7A7A78",
+"h+	c #969696",
+"i+	c #F3F3F3",
+"j+	c #B4B4B4",
+"k+	c #E5E5E5",
+"l+	c #A2A2A2",
+"m+	c #EDEDED",
+"n+	c #AAAAAA",
+"o+	c #D9D9D9",
+"p+	c #727271",
+"q+	c #93918E",
+"r+	c #27211B",
+"s+	c #493B30",
+"t+	c #715C4B",
+"u+	c #463324",
+"v+	c #0E0906",
+"w+	c #251F1B",
+"x+	c #D6C9B2",
+"y+	c #FFFBEE",
+"z+	c #D2CBC0",
+"A+	c #4D4137",
+"B+	c #110E0B",
+"C+	c #1D1711",
+"D+	c #837F7A",
+"E+	c #696968",
+"F+	c #B5B5B5",
+"G+	c #6E6E6C",
+"H+	c #D9D9D8",
+"I+	c #F4F4F4",
+"J+	c #A6A6A6",
+"K+	c #E2E2E2",
+"L+	c #9D9D9D",
+"M+	c #A5A5A5",
+"N+	c #A3A3A3",
+"O+	c #908E8D",
+"P+	c #251F19",
+"Q+	c #3A2C24",
+"R+	c #6F5C4B",
+"S+	c #4F3A2A",
+"T+	c #150F0B",
+"U+	c #171411",
+"V+	c #B4A796",
+"W+	c #DACBB2",
+"X+	c #FEFAEE",
+"Y+	c #DBD3C9",
+"Z+	c #352C24",
+"`+	c #120F0B",
+" @	c #2E261F",
+".@	c #8E8E8D",
+"+@	c #6C6C6B",
+"@@	c #BABBBA",
+"#@	c #838383",
+"$@	c #ABABAB",
+"%@	c #BABABA",
+"&@	c #E3E3E3",
+"*@	c #ECECEC",
+"=@	c #B2B2B2",
+"-@	c #DCDCDC",
+";@	c #ABADAB",
+">@	c #656360",
+",@	c #251E17",
+"'@	c #2E231B",
+")@	c #6E5949",
+"!@	c #513B2B",
+"~@	c #1F1710",
+"{@	c #0D0A08",
+"]@	c #C5B7A5",
+"^@	c #E5DCCA",
+"/@	c #A0948B",
+"(@	c #1E1711",
+"_@	c #1C1511",
+":@	c #514940",
+"<@	c #454544",
+"[@	c #969694",
+"}@	c #B0B0AE",
+"|@	c #7F7F7D",
+"1@	c #B0B0B0",
+"2@	c #C2C2C2",
+"3@	c #C8C8C8",
+"4@	c #BBBBBB",
+"5@	c #B9B9B9",
+"6@	c #B7B7B7",
+"7@	c #DFDFDF",
+"8@	c #B6B6B6",
+"9@	c #D3D3D3",
+"0@	c #4A4948",
+"a@	c #261F1B",
+"b@	c #32251C",
+"c@	c #543F2E",
+"d@	c #493526",
+"e@	c #120D09",
+"f@	c #16120F",
+"g@	c #5F5248",
+"h@	c #221912",
+"i@	c #554437",
+"j@	c #ADA9A6",
+"k@	c #3A3A3A",
+"l@	c #232322",
+"m@	c #444544",
+"n@	c #9FA09F",
+"o@	c #C5C5C5",
+"p@	c #BFBFBF",
+"q@	c #BEBEBE",
+"r@	c #B1B1B1",
+"s@	c #9F9F9F",
+"t@	c #808080",
+"u@	c #909090",
+"v@	c #4B4B4B",
+"w@	c #4A4A4A",
+"x@	c #2A2A29",
+"y@	c #443C36",
+"z@	c #291E15",
+"A@	c #19120D",
+"B@	c #9A9088",
+"C@	c #0E0E0E",
+"D@	c #1B1B1A",
+"E@	c #4A4B4A",
+"F@	c #DCDDDC",
+"G@	c #F1F1F1",
+"H@	c #F5F5F5",
+"I@	c #373737",
+"J@	c #242424",
+"K@	c #080808",
+"L@	c #292726",
+"M@	c #1C1714",
+"N@	c #1F1F1F",
+"O@	c #E0E0E0",
+"P@	c #D1D1D1",
+"Q@	c #CFCFCF",
+"R@	c #CECECE",
+"S@	c #C9C9C9",
+"T@	c #757575",
+"U@	c #343434",
+"V@	c #1B1B1B",
+"W@	c #292929",
+"X@	c #545454",
+"Y@	c #ADADAD",
+"Z@	c #3B3B3B",
+"`@	c #D5D5D5",
+" #	c #DBDBDB",
+".#	c #D8D8D8",
+"+#	c #464646",
+"@#	c #252828",
+"##	c #050505",
+"$#	c #0F0E0C",
+"%#	c #0C0F0F",
+"&#	c #2D302E",
+"*#	c #C0C0C0",
+"=#	c #BDBDBD",
+"-#	c #272727",
+";#	c #404040",
+">#	c #E1E1E1",
+",#	c #DEDEDE",
+"'#	c #D7D7D7",
+")#	c #181B1B",
+"!#	c #374845",
+"~#	c #242D2C",
+"{#	c #303636",
+"]#	c #363D3C",
+"^#	c #595D5A",
+"/#	c #23221F",
+"(#	c #949494",
+"_#	c #4F4F4F",
+":#	c #222222",
+"<#	c #444444",
+"[#	c #939393",
+"}#	c #262626",
+"|#	c #161917",
+"1#	c #0A0B0A",
+"2#	c #080908",
+"3#	c #090B0A",
+"4#	c #161716",
+"5#	c #303030",
+"6#	c #0E0E0C",
+"7#	c #2B3534",
+"8#	c #555856",
+"9#	c #515251",
+"0#	c #8E8E8B",
+"a#	c #A5A3A0",
+"b#	c #0C0C0C",
+"c#	c #747474",
+"d#	c #3D3D3D",
+"e#	c #2E2E2E",
+"f#	c #2D2D2D",
+"g#	c #525252",
+"h#	c #7F7F7F",
+"i#	c #151515",
+"j#	c #1F221E",
+"k#	c #362E2A",
+"l#	c #050705",
+"m#	c #070C08",
+"n#	c #232D25",
+"o#	c #393939",
+"p#	c #151513",
+"q#	c #191F1E",
+"r#	c #6F6F6E",
+"s#	c #8A8B8A",
+"t#	c #CDCCCA",
+"u#	c #0A0B0B",
+"v#	c #727272",
+"w#	c #484848",
+"x#	c #2B2B2B",
+"y#	c #333333",
+"z#	c #424242",
+"A#	c #6E6E6E",
+"B#	c #1E1E1E",
+"C#	c #7A5551",
+"D#	c #C2827C",
+"E#	c #C4A6A3",
+"F#	c #271E1C",
+"G#	c #0D0C0A",
+"H#	c #313432",
+"I#	c #363B37",
+"J#	c #CBCBCB",
+"K#	c #070808",
+"L#	c #171F1E",
+"M#	c #7C7D7C",
+"N#	c #111313",
+"O#	c #666666",
+"P#	c #3F3F3F",
+"Q#	c #494949",
+"R#	c #181615",
+"S#	c #974B46",
+"T#	c #482521",
+"U#	c #B25851",
+"V#	c #DEC0BD",
+"W#	c #3C3535",
+"X#	c #010101",
+"Y#	c #262827",
+"Z#	c #1C2221",
+"`#	c #8B8B8B",
+" $	c #D1D2D2",
+".$	c #D8D9D8",
+"+$	c #080909",
+"@$	c #4D4D4D",
+"#$	c #5D5D5D",
+"$$	c #040202",
+"%$	c #391D1A",
+"&$	c #7D312B",
+"*$	c #B04D45",
+"=$	c #C47168",
+"-$	c #33201F",
+";$	c #292B2A",
+">$	c #CDCDCD",
+",$	c #CCCCCC",
+"'$	c #0E0D0C",
+")$	c #212926",
+"!$	c #999997",
+"~$	c #BBBDBD",
+"{$	c #DFE0E0",
+"]$	c #141414",
+"^$	c #282828",
+"/$	c #5F5F5F",
+"($	c #414141",
+"_$	c #080606",
+":$	c #833C34",
+"<$	c #8D3F37",
+"[$	c #9C413B",
+"}$	c #9A413A",
+"|$	c #261615",
+"1$	c #242524",
+"2$	c #CACACA",
+"3$	c #1C1E1D",
+"4$	c #29322E",
+"5$	c #D2D3D2",
+"6$	c #D7D7D6",
+"7$	c #111111",
+"8$	c #919191",
+"9$	c #2C2C2C",
+"0$	c #0D0D0D",
+"a$	c #636363",
+"b$	c #9D524A",
+"c$	c #9F3C34",
+"d$	c #994037",
+"e$	c #9C4841",
+"f$	c #151716",
+"g$	c #6C6C6C",
+"h$	c #24201D",
+"i$	c #323530",
+"j$	c #2E2E28",
+"k$	c #343532",
+"l$	c #353532",
+"m$	c #212121",
+"n$	c #3C3C3C",
+"o$	c #686868",
+"p$	c #0F0F0F",
+"q$	c #060606",
+"r$	c #8D5651",
+"s$	c #9D3D36",
+"t$	c #9C453D",
+"u$	c #A35149",
+"v$	c #2C1F1E",
+"w$	c #1B1C1B",
+"x$	c #C6C6C6",
+"y$	c #BDB4A9",
+"z$	c #B0AAA5",
+"A$	c #979796",
+"B$	c #828282",
+"C$	c #626262",
+"D$	c #090909",
+"E$	c #684946",
+"F$	c #8A362E",
+"G$	c #97453F",
+"H$	c #9C5A54",
+"I$	c #261716",
+"J$	c #191C1A",
+"K$	c #C4C4C4",
+"L$	c #C3C3C3",
+"M$	c #5C5C5C",
+"N$	c #171717",
+"O$	c #392423",
+"P$	c #632E29",
+"Q$	c #96453D",
+"R$	c #88544F",
+"S$	c #291D1C",
+"T$	c #010000",
+"U$	c #121513",
+"V$	c #1C1C1C",
+"W$	c #7A7A7A",
+"X$	c #1A1B1B",
+"Y$	c #885A56",
+"Z$	c #753B36",
+"`$	c #804F4B",
+" %	c #904F49",
+".%	c #282020",
+"+%	c #151715",
+"@%	c #949790",
+"#%	c #626362",
+"$%	c #282C23",
+"%%	c #36412B",
+"&%	c #202E15",
+"*%	c #8B8E88",
+"=%	c #394131",
+"-%	c #A0A59A",
+";%	c #1E2020",
+">%	c #524442",
+",%	c #65403C",
+"'%	c #69514E",
+")%	c #875551",
+"!%	c #2A2424",
+"~%	c #070505",
+"{%	c #202120",
+"]%	c #B0B4AB",
+"^%	c #9DA694",
+"/%	c #778B65",
+"(%	c #6B8258",
+"_%	c #6E855A",
+":%	c #7F8E6F",
+"<%	c #778868",
+"[%	c #60774B",
+"}%	c #607254",
+"|%	c #3F5431",
+"1%	c #394B30",
+"2%	c #35422E",
+"3%	c #30402C",
+"4%	c #30412C",
+"5%	c #2B3A2B",
+"6%	c #2E3F2B",
+"7%	c #3C562A",
+"8%	c #425F2C",
+"9%	c #A2AB99",
+"0%	c #3D4A35",
+"a%	c #638052",
+"b%	c #3B4A30",
+"c%	c #21291A",
+"d%	c #241918",
+"e%	c #4B3533",
+"f%	c #6B4F4D",
+"g%	c #392D2A",
+"h%	c #180C0C",
+"i%	c #152215",
+"j%	c #161E15",
+"k%	c #1F291F",
+"l%	c #222C23",
+"m%	c #29352B",
+"n%	c #2B392D",
+"o%	c #2E3F2E",
+"p%	c #32452E",
+"q%	c #32422E",
+"r%	c #2D3B2E",
+"s%	c #2A392C",
+"t%	c #2D422E",
+"u%	c #2A362B",
+"v%	c #2C3C2C",
+"w%	c #2C3C2D",
+"x%	c #2C3B2D",
+"y%	c #2B3B2C",
+"z%	c #30402A",
+"A%	c #394F2B",
+"B%	c #45632E",
+"C%	c #415F2C",
+"D%	c #3F6232",
+"E%	c #406634",
+"F%	c #416330",
+"G%	c #3D592C",
+"H%	c #405F30",
+"I%	c #3F5F2E",
+"J%	c #42482C",
+"K%	c #191210",
+"L%	c #0F0908",
+"M%	c #080505",
+"N%	c #070B07",
+"O%	c #080D09",
+"P%	c #0B0F0B",
+"Q%	c #121A0F",
+"R%	c #1B2917",
+"S%	c #293B1F",
+"T%	c #394E2D",
+"U%	c #3B5930",
+"V%	c #406532",
+"W%	c #44652E",
+"X%	c #446630",
+"Y%	c #354F30",
+"Z%	c #29362B",
+"`%	c #2A362C",
+" &	c #2B3A2C",
+".&	c #2C3B2A",
+"+&	c #304129",
+"@&	c #303F2D",
+"#&	c #446C37",
+"$&	c #446934",
+"%&	c #446332",
+"&&	c #405F2D",
+"*&	c #416531",
+"=&	c #446531",
+"-&	c #3D6232",
+";&	c #3B562B",
+">&	c #374827",
+",&	c #3F2B25",
+"'&	c #31341F",
+")&	c #1D1C11",
+"!&	c #1E2312",
+"~&	c #253719",
+"{&	c #243518",
+"]&	c #233317",
+"^&	c #2C3D1C",
+"/&	c #375125",
+"(&	c #42602D",
+"_&	c #466630",
+":&	c #44632E",
+"<&	c #3C552D",
+"[&	c #293A28",
+"}&	c #2A3B27",
+"|&	c #314527",
+"1&	c #2C3D22",
+"2&	c #1E2A19",
+"3&	c #212E1B",
+"4&	c #253321",
+"5&	c #2A3A26",
+"6&	c #446933",
+"7&	c #426531",
+"8&	c #3C6032",
+"9&	c #34512B",
+"0&	c #354B23",
+"a&	c #27371A",
+"b&	c #2B3D1C",
+"c&	c #28391B",
+"d&	c #334921",
+"e&	c #395125",
+"f&	c #3D5829",
+"g&	c #3A5226",
+"h&	c #395129",
+"i&	c #3C592D",
+"j&	c #3F6332",
+"k&	c #42652E",
+"l&	c #42632E",
+"m&	c #3C592A",
+"n&	c #233217",
+"o&	c #0B0F09",
+"p&	c #26341E",
+"q&	c #24321B",
+"r&	c #2E4122",
+"s&	c #202C1B",
+"t&	c #27361E",
+"u&	c #233219",
+"v&	c #3B5527",
+"w&	c #3C5628",
+"x&	c #334922",
+"y&	c #36542B",
+"z&	c #334A22",
+"A&	c #30441F",
+"B&	c #374F25",
+"C&	c #324821",
+"D&	c #344A22",
+"E&	c #314520",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                .                                               ",
+"                                              + @ #                                             ",
+"                            $ % & * = $     - ; > , '                                           ",
+"                            ) ! ~ { ] ^   / ( _ : < [ }                                         ",
+"                            | 1 2 3 4 5 6 7 8 9 0 a b c d                                       ",
+"                            e f g h i j k l m n o p q r s t                                     ",
+"                            u v w x y z A m B C D E F G H I t                                   ",
+"                            J K L M N O P Q R S T U V W X Y Z `  .                              ",
+"                            ..+.@.#.$.%.&.*.=.-.;.>.,.'.).!.~.{.` ].                            ",
+"                            ^./.(._.:.<.[.}.R |.1.2.1.3.4.5.6.7.8.9.0.                          ",
+"                          a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.9.}                         ",
+"                        v.w.x.y.z.A.B.U C.D.E.F.l.G.H.I.J.m.K.L.M.N.O.P.Q.                      ",
+"                      R.S.T.U.V.W.g.C.}.h.X.Y.Z.`. +.+++H.@+#+$+%+&+*+=+-+`                     ",
+"                    ;+>+,+'+)+!+~+{+]+^+/+(+_+I.:+<+.+[+}+|+l.1+2+3+4+5+6+7+` 8+                ",
+"                9+0+a+b+)+'+c+d+e+f+e+g+Y.h+i+j+k+l+m+++.+n+`.|+o+p+q+r+s+t+u+v+w+              ",
+"              x+y+z+A+B+C+D+h.E+F+G+H+ +I+J+}+n+K+L+l.M+.+N+n.I.1.[+C.O+P+Q+R+S+T+U+            ",
+"          V+W+X+Y+Z+`+ @L..@C.+@@@#@i+$@i+j+Y.%@&@I.n.I.*@I.k+C.1.=@-@;@>@,@'@)@!@~@{@          ",
+"          ]@^@/@(@_@:@<@C [@}@|@n.1@.+2@}+3@H.4@K+%@K+5@n.6@7@n+-@8@J.9@2.0@a@b@c@d@e@f@        ",
+"            g@h@i@j@k@l@m@n@B.j+o@6@p@1@q@r@6@J+=@++L+s@ +t@L+u@I.G.$@1@v@w@x@y@z@A@9           ",
+"              B@4@C@$ D@E@F@.+}+G@I+H@i+i+I+H@H@I+_+i+I+I+_+}+H..+:+J.6@I@J@$ K@L@M@$           ",
+"                $ $ $ N@k.:+n.`.l.k+K+1.l.`.`.k+1.O@J.o+P@,.,.P@Q@R@S@T@U@V@$ $ $ $ $           ",
+"                    $ W@X@o@S@3@4@%@p@5@8@M+J+$@Y@C.n+r@C.o.N+o.L+J+r@i.W@J@$ $ $               ",
+"                      Z@X@3@1.1.K+J.-@`@9@#+ #E.o+.#+#@###$#%#&#+#*#=#v@J@-#$                   ",
+"                      ;#i.o.&@K+>#7@,#J.-@R@C..#'#Q@)#!#~#{#]#^#/#(#F+_#:#-#$                   ",
+"                      <#2.[#>#}#|#1#2#3#4#5#X@r@C.o.6#7#8#9#0#a#b#c#J+d#e#f#$                   ",
+"                      g#v@h#o+i#j#k#l#$ m#n#o#`@#+,.p#q#r#h#s#t#u#v#q@w#x#y#$                   ",
+"                      2.z#A#,#B#C#D#E#F#G#H#I#J#q@4@K#L#M#h#q@'#N#O#F+P#V@<#$                   ",
+"                      A#Q#T@-@R#S#T#U#V#W#X#Y#++h+h+K@Z#`#l+ $.$+$z#F.B#i#@$$                   ",
+"                      #$Z@@+o+$$%$&$*$=$-$$ ;$Q@>$,$'$)$!$~${$1.]$>.<+^$b#f#$                   ",
+"                      /$($A#o+_$:$<$[$}$|$$ 1$>$,$2$3$4$5$'#7@6$7$k.8$9$0$5#$                   ",
+"                      m.e#a$'#K@b$c$d$e$|$$ f$M+++g$h$i$j$3$k$l$m$n$o$-#p$5#                    ",
+"                      @+d#P#,.q$r$s$t$u$v$$ w$S@3@x$y$z$A$B$C$a$>.<#O#n$p$5#                    ",
+"                      A#>.d#q@D$E$F$G$H$I$$ J$3@o@K$L$2@*#q@=#J+1@C$M$o#N$f#                    ",
+"                      c#A#<#Y@D$O$P$Q$R$S$T$U$6@F+n+<+<+[+h+(+t@a$/$w@V$V@9$                    ",
+"                        W$n$=@X$Y$Z$`$ %.%X#+%6@8@8@j+r@1@N+ +@%h+Z.#%$%%%&%                    ",
+"                        *%=%-%;%>%,%'%)%!%~%{%]%^%/%(%_%:%<%[%}%|%1%2%3%4%5%6%7%8%              ",
+"                        9%0%a%b%c%d%e%f%g%h%i%j%k%l%m%n%o%p%q%r%s%t%u%v%w%x%y%z%A%              ",
+"                  B%C%D%E%F%G%H%I%J%I$K%L%M%N%O%P%Q%R%S%T%U%V%W%X%Y%Z%`% & &.&+&6%@&            ",
+"                #&$&%&&&*&=&*&-&;&>&,&'&)&!&~&{&]&^&/&(&_&_&:&<&[&}&|&1&2&3&4&5&                ",
+"                  6&7&8&9&0&a&b&c&d&e&f&g&h&i&j&k&k&l&m&n&  o&p&q&r&s&t&u&                      ",
+"                            v&w&x&        y&z&      A&x&B&C&D&E&                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                "};
+static char * desktop_xpm[] = {
+"48 48 554 2",
+"  	c None",
+". 	c #D6CCB9",
+"+ 	c #DED6C7",
+"@ 	c #BFB090",
+"# 	c #BFB095",
+"$ 	c #9A949A",
+"% 	c #BBB5BE",
+"& 	c #B5AFB9",
+"* 	c #AEA7B1",
+"= 	c #AAA3AE",
+"- 	c #A69FAA",
+"; 	c #A49CA7",
+"> 	c #A199A5",
+", 	c #A098A4",
+"' 	c #A097A4",
+") 	c #9F97A3",
+"! 	c #A098A5",
+"~ 	c #9C94A1",
+"{ 	c #908894",
+"] 	c #9A8F83",
+"^ 	c #776D5A",
+"/ 	c #E5E0D4",
+"( 	c #F0EDE7",
+"_ 	c #E3DDD1",
+": 	c #D9D0BD",
+"< 	c #D0C6B1",
+"[ 	c #746C60",
+"} 	c #C0B29D",
+"| 	c #F2EFE9",
+"1 	c #D0C5B0",
+"2 	c #BFAF90",
+"3 	c #B8A88C",
+"4 	c #38353A",
+"5 	c #4C464F",
+"6 	c #867B8B",
+"7 	c #827787",
+"8 	c #817687",
+"9 	c #7E7383",
+"0 	c #7C7282",
+"a 	c #7A6E80",
+"b 	c #766A7C",
+"c 	c #776B7D",
+"d 	c #736879",
+"e 	c #746879",
+"f 	c #76697C",
+"g 	c #74687A",
+"h 	c #706376",
+"i 	c #6E6174",
+"j 	c #6A5D71",
+"k 	c #66596D",
+"l 	c #5D4F64",
+"m 	c #44384B",
+"n 	c #3F363B",
+"o 	c #B6B3AA",
+"p 	c #F8F8F6",
+"q 	c #ECE8E0",
+"r 	c #CFC3AB",
+"s 	c #C4B699",
+"t 	c #564F41",
+"u 	c #5A4F4B",
+"v 	c #BBAF97",
+"w 	c #FBFAF8",
+"x 	c #C0B192",
+"y 	c #BFAF8F",
+"z 	c #9F9177",
+"A 	c #0F0C10",
+"B 	c #281F2B",
+"C 	c #514259",
+"D 	c #504058",
+"E 	c #52425A",
+"F 	c #4C3C54",
+"G 	c #4B3B53",
+"H 	c #483950",
+"I 	c #4A3B52",
+"J 	c #46374D",
+"K 	c #48384F",
+"L 	c #4A3A52",
+"M 	c #45364C",
+"N 	c #403247",
+"O 	c #43354B",
+"P 	c #221B26",
+"Q 	c #433D3A",
+"R 	c #F6F4F0",
+"S 	c #D1C6B0",
+"T 	c #BEAE8F",
+"U 	c #4A4338",
+"V 	c #443D39",
+"W 	c #CEC2AC",
+"X 	c #F9F7F5",
+"Y 	c #675D52",
+"Z 	c #0A070B",
+"` 	c #2B212F",
+" .	c #493A51",
+"..	c #6A6070",
+"+.	c #706575",
+"@.	c #746979",
+"#.	c #9A939D",
+"$.	c #B4AFB7",
+"%.	c #BBB5BD",
+"&.	c #BDB7BF",
+"*.	c #E6E4E7",
+"=.	c #FDFDFD",
+"-.	c #000000",
+";.	c #281F2D",
+">.	c #221A25",
+",.	c #201A21",
+"'.	c #E8E3DB",
+").	c #C2B396",
+"!.	c #3D392E",
+"~.	c #363129",
+"{.	c #E1D9CB",
+"].	c #E9E4DB",
+"^.	c #312A2D",
+"/.	c #0B080C",
+"(.	c #372B3D",
+"_.	c #C2BDC5",
+":.	c #B8B8B8",
+"<.	c #B1B1B1",
+"[.	c #C8C8C8",
+"}.	c #DBDBDB",
+"|.	c #E6E6E6",
+"1.	c #EDEDED",
+"2.	c #F4F4F4",
+"3.	c #F7F7F7",
+"4.	c #FBFBFB",
+"5.	c #FCFCFC",
+"6.	c #FEFEFE",
+"7.	c #040305",
+"8.	c #2A212F",
+"9.	c #252023",
+"0.	c #BBB098",
+"a.	c #4A4438",
+"b.	c #27241D",
+"c.	c #D7D2C8",
+"d.	c #363237",
+"e.	c #181219",
+"f.	c #5C4F64",
+"g.	c #EAE8EB",
+"h.	c #FFFFFF",
+"i.	c #A7A7A7",
+"j.	c #989898",
+"k.	c #BEBEBE",
+"l.	c #DCDCDC",
+"m.	c #E5E5E5",
+"n.	c #EAEAEA",
+"o.	c #F5F5F5",
+"p.	c #F8F8F8",
+"q.	c #555555",
+"r.	c #020202",
+"s.	c #322835",
+"t.	c #5C524B",
+"u.	c #36312A",
+"v.	c #12100E",
+"w.	c #656263",
+"x.	c #413945",
+"y.	c #423449",
+"z.	c #6D6D6D",
+"A.	c #707070",
+"B.	c #BCBCBC",
+"C.	c #D3D3D3",
+"D.	c #9B9B9B",
+"E.	c #6F6F6F",
+"F.	c #797979",
+"G.	c #929292",
+"H.	c #D1D1D1",
+"I.	c #3D333F",
+"J.	c #120F15",
+"K.	c #C1BDC4",
+"L.	c #56475E",
+"M.	c #44364B",
+"N.	c #3F3246",
+"O.	c #D4D4D4",
+"P.	c #8F8F8F",
+"Q.	c #5D5D5D",
+"R.	c #343434",
+"S.	c #484848",
+"T.	c #5F5F5F",
+"U.	c #4E4E4E",
+"V.	c #373737",
+"W.	c #454545",
+"X.	c #A4A4A4",
+"Y.	c #DFDFDF",
+"Z.	c #B6B6B6",
+"`.	c #493951",
+" +	c #1C1620",
+".+	c #201923",
+"++	c #AEA7B0",
+"@+	c #B6B1B9",
+"#+	c #43354A",
+"$+	c #858585",
+"%+	c #737373",
+"&+	c #787878",
+"*+	c #8D8D8D",
+"=+	c #959595",
+"-+	c #ADADAD",
+";+	c #BFBFBF",
+">+	c #E8E8E8",
+",+	c #F0F0F0",
+"'+	c #F9F9F9",
+")+	c #717171",
+"!+	c #3A2E40",
+"~+	c #28212D",
+"{+	c #BCB6BE",
+"]+	c #A79FAA",
+"^+	c #C3C3C3",
+"/+	c #ACACAC",
+"(+	c #8B8B8B",
+"_+	c #5E5E5E",
+":+	c #808080",
+"<+	c #AAAAAA",
+"[+	c #332839",
+"}+	c #3D3044",
+"|+	c #362B3C",
+"1+	c #342939",
+"2+	c #C0BAC3",
+"3+	c #8F8594",
+"4+	c #CECECE",
+"5+	c #BBBBBB",
+"6+	c #949494",
+"7+	c #595959",
+"8+	c #282828",
+"9+	c #575757",
+"0+	c #6A6A6A",
+"a+	c #EFEFEF",
+"b+	c #E0E0E0",
+"c+	c #CFCFCF",
+"d+	c #D8D8D8",
+"e+	c #281F2C",
+"f+	c #35293B",
+"g+	c #322737",
+"h+	c #C5BFC8",
+"i+	c #7C7081",
+"j+	c #E1E1E1",
+"k+	c #4A4A4A",
+"l+	c #AEAEAE",
+"m+	c #E9E9E9",
+"n+	c #FAFAFA",
+"o+	c #C6C6C6",
+"p+	c #171219",
+"q+	c #C1995E",
+"r+	c #D5A960",
+"s+	c #735B57",
+"t+	c #42344A",
+"u+	c #312636",
+"v+	c #C5C0C7",
+"w+	c #685B6E",
+"x+	c #46374E",
+"y+	c #EBEBEB",
+"z+	c #EEEEEE",
+"A+	c #6C6C6C",
+"B+	c #C4C4C4",
+"C+	c #AD8947",
+"D+	c #FECA65",
+"E+	c #BE8134",
+"F+	c #5A424A",
+"G+	c #312736",
+"H+	c #BEB9C2",
+"I+	c #47384E",
+"J+	c #C9C9C9",
+"K+	c #7E7E7E",
+"L+	c #5C5C5C",
+"M+	c #3B3B3B",
+"N+	c #4C4C4C",
+"O+	c #A9A9A9",
+"P+	c #9F9F9F",
+"Q+	c #9D9D9D",
+"R+	c #FEF9EE",
+"S+	c #C59C4E",
+"T+	c #EABA62",
+"U+	c #CC7300",
+"V+	c #84532E",
+"W+	c #44354B",
+"X+	c #413347",
+"Y+	c #47384F",
+"Z+	c #332939",
+"`+	c #B4AEB7",
+" @	c #AFA8B2",
+".@	c #F3F3F3",
+"+@	c #B2B2B2",
+"@@	c #CDCDCD",
+"#@	c #ECECEC",
+"$@	c #FED076",
+"%@	c #E3B45A",
+"&@	c #C37413",
+"*@	c #AD6510",
+"=@	c #392C3E",
+"-@	c #392D40",
+";@	c #3E3044",
+">@	c #47374F",
+",@	c #B4ADB7",
+"'@	c #A39BA7",
+")@	c #493950",
+"!@	c #FEF3DD",
+"~@	c #D2A456",
+"{@	c #652A0C",
+"]@	c #2C2231",
+"^@	c #2F2535",
+"/@	c #2F2534",
+"(@	c #322838",
+"_@	c #332A37",
+":@	c #352938",
+"<@	c #B1ABB4",
+"[@	c #756C64",
+"}@	c #3A2F3D",
+"|@	c #3F3145",
+"1@	c #444444",
+"2@	c #898989",
+"3@	c #505050",
+"4@	c #3E3E3E",
+"5@	c #C3B290",
+"6@	c #F2C174",
+"7@	c #B06006",
+"8@	c #602105",
+"9@	c #662100",
+"0@	c #2C2230",
+"a@	c #241C28",
+"b@	c #231B26",
+"c@	c #1D1720",
+"d@	c #362B3D",
+"e@	c #2D2332",
+"f@	c #322B30",
+"g@	c #6D605B",
+"h@	c #2E2432",
+"i@	c #B6B0B6",
+"j@	c #C2B7A7",
+"k@	c #63574D",
+"l@	c #3E3245",
+"m@	c #D5D5D5",
+"n@	c #C7B694",
+"o@	c #E6AC5A",
+"p@	c #7E3E02",
+"q@	c #3A1E1B",
+"r@	c #211A25",
+"s@	c #18131B",
+"t@	c #231B27",
+"u@	c #171118",
+"v@	c #3B3333",
+"w@	c #988A77",
+"x@	c #8E8172",
+"y@	c #2B2230",
+"z@	c #C0B6AF",
+"A@	c #F3F0EA",
+"B@	c #B4A489",
+"C@	c #4A413F",
+"D@	c #19141B",
+"E@	c #413348",
+"F@	c #FEDB98",
+"G@	c #FACB71",
+"H@	c #DE9E42",
+"I@	c #612700",
+"J@	c #5E2004",
+"K@	c #2A1B21",
+"L@	c #1B151E",
+"M@	c #1C151E",
+"N@	c #0E0A0E",
+"O@	c #6E6258",
+"P@	c #CDC3B2",
+"Q@	c #D5CCC1",
+"R@	c #9E907B",
+"S@	c #28202D",
+"T@	c #E2DDD5",
+"U@	c #F3F1EE",
+"V@	c #D3C8B3",
+"W@	c #C9BCA4",
+"X@	c #2A2327",
+"Y@	c #120D15",
+"Z@	c #33283A",
+"`@	c #FDCE73",
+" #	c #D58824",
+".#	c #BB6C10",
+"+#	c #622304",
+"@#	c #441600",
+"##	c #1C161F",
+"$#	c #18121A",
+"%#	c #120E14",
+"&#	c #141016",
+"*#	c #100C10",
+"=#	c #998D78",
+"-#	c #E9E5E0",
+";#	c #EAE6E0",
+">#	c #BDAE90",
+",#	c #A4957F",
+"'#	c #29202D",
+")#	c #ABA4AD",
+"!#	c #F1EEE8",
+"~#	c #EFEBE5",
+"{#	c #DDD7C9",
+"]#	c #DBD3C3",
+"^#	c #BEB197",
+"/#	c #302A2B",
+"(#	c #09060A",
+"_#	c #2A212E",
+":#	c #837988",
+"<#	c #807C81",
+"[#	c #B3ADA2",
+"}#	c #EBC274",
+"|#	c #7C3D00",
+"1#	c #220B00",
+"2#	c #100D12",
+"3#	c #130F15",
+"4#	c #130F16",
+"5#	c #100C12",
+"6#	c #0A080A",
+"7#	c #9D9180",
+"8#	c #F3F2F0",
+"9#	c #F2EFEA",
+"0#	c #CBBFA7",
+"a#	c #BAAA8C",
+"b#	c #A3947F",
+"c#	c #ACA4A6",
+"d#	c #F9F8F6",
+"e#	c #E3DDCF",
+"f#	c #CEC3B0",
+"g#	c #BEB099",
+"h#	c #C4B7A0",
+"i#	c #B2A388",
+"j#	c #39342F",
+"k#	c #0A090C",
+"l#	c #251D29",
+"m#	c #17121A",
+"n#	c #1B160B",
+"o#	c #E1B359",
+"p#	c #AF7C2D",
+"q#	c #692900",
+"r#	c #5A1D00",
+"s#	c #110806",
+"t#	c #0C090D",
+"u#	c #0F0C12",
+"v#	c #181414",
+"w#	c #A59D91",
+"x#	c #F2F0EF",
+"y#	c #EDE8E1",
+"z#	c #E3DDD0",
+"A#	c #C0B19A",
+"B#	c #BCAC8D",
+"C#	c #988878",
+"D#	c #2C2331",
+"E#	c #B6ABA2",
+"F#	c #F8F7F4",
+"G#	c #CFC4AD",
+"H#	c #D2C8B3",
+"I#	c #C7BAA2",
+"J#	c #C1B396",
+"K#	c #AB9C80",
+"L#	c #AC9D82",
+"M#	c #352E2D",
+"N#	c #1A151E",
+"O#	c #322738",
+"P#	c #413349",
+"Q#	c #0A080B",
+"R#	c #09070A",
+"S#	c #403220",
+"T#	c #E3B45C",
+"U#	c #B47929",
+"V#	c #AD5D02",
+"W#	c #642102",
+"X#	c #4C1C09",
+"Y#	c #100C11",
+"Z#	c #080609",
+"`#	c #0B090D",
+" $	c #151017",
+".$	c #262120",
+"+$	c #A49987",
+"@$	c #D4CDC1",
+"#$	c #DDD6C9",
+"$$	c #E4DED4",
+"%$	c #D4CCC0",
+"&$	c #CABFAC",
+"*$	c #BDAF96",
+"=$	c #827469",
+"-$	c #584D4B",
+";$	c #2D2330",
+">$	c #B0A28A",
+",$	c #B3B0AC",
+"'$	c #565146",
+")$	c #464035",
+"!$	c #4A4139",
+"~$	c #3C352F",
+"{$	c #302927",
+"]$	c #413936",
+"^$	c #161018",
+"/$	c #251C28",
+"($	c #1E1721",
+"_$	c #271F2B",
+":$	c #6E583E",
+"<$	c #E7B75E",
+"[$	c #BF710F",
+"}$	c #914C06",
+"|$	c #2A110A",
+"1$	c #050406",
+"2$	c #130E14",
+"3$	c #151018",
+"4$	c #1C161D",
+"5$	c #4E4445",
+"6$	c #494044",
+"7$	c #8C7E6E",
+"8$	c #7C6E66",
+"9$	c #766962",
+"0$	c #817368",
+"a$	c #897B6D",
+"b$	c #6B5E5A",
+"c$	c #3C3239",
+"d$	c #1E1720",
+"e$	c #201924",
+"f$	c #736B65",
+"g$	c #544E4A",
+"h$	c #292325",
+"i$	c #110E13",
+"j$	c #17131A",
+"k$	c #1B161F",
+"l$	c #211A23",
+"m$	c #383037",
+"n$	c #241D29",
+"o$	c #241E29",
+"p$	c #261F2B",
+"q$	c #221B25",
+"r$	c #928156",
+"s$	c #D5A556",
+"t$	c #6E2E06",
+"u$	c #5C1E01",
+"v$	c #0F0705",
+"w$	c #030304",
+"x$	c #030203",
+"y$	c #050405",
+"z$	c #1D1721",
+"A$	c #211B25",
+"B$	c #251E2A",
+"C$	c #161118",
+"D$	c #D5D68D",
+"E$	c #E2BB5D",
+"F$	c #C06700",
+"G$	c #692100",
+"H$	c #4B1800",
+"I$	c #BDCC99",
+"J$	c #F2ECC5",
+"K$	c #B2A96D",
+"L$	c #965A05",
+"M$	c #A35502",
+"N$	c #270C00",
+"O$	c #EBE7C0",
+"P$	c #CDC398",
+"Q$	c #1E1D0F",
+"R$	c #0C0900",
+"S$	c #512A04",
+"T$	c #5E1E00",
+"U$	c #0D0400",
+"V$	c #9B9D78",
+"W$	c #938C6A",
+"X$	c #221E17",
+"Y$	c #121001",
+"Z$	c #391900",
+"`$	c #1B1B14",
+" %	c #060505",
+".%	c #090700",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                . + @ @ @ # $ % & * = - ; > , ' > > ) ' > ! > ! ~ { ] ^ / ( _ : < [             ",
+"              } | 1 2 2 3 4 5 6 6 7 8 8 9 0 a b c d e f g h i j k l m n o p q r s t u           ",
+"              v w x y z A B C D E F G H I F F F J K G L M N F F F F F O P Q R S T U V           ",
+"              W X y Y Z ` F F F F L  .F ..+.@.#.$.%.&.*.=.-.;.F F F F F G >.,.'.).!.~.          ",
+"              {.].^./.(.F F F F H _.:.<.[.}.|.1.2.3.4.5.6.-.7.F F F F F F F 8.9.0.a.b.          ",
+"              c.d.e.O F F F H f.g.h.i.j.k.l.m.n.o.p.1.=.6.q.r.F F F F F F F L s.t.u.v.          ",
+"              w.x.F F L y.M 6 h.h.h.z.A.B.C.D.E.F.G.H.=.h.q.-.F F F F F F L I F I.A J.          ",
+"              K.L.M.N.N K F O.P.Q.R.R.S.T.U.V.W.X.Y.Z.h.h.q.-.F F F F F `.F F F F  +.+          ",
+"            ++@+#+K G F F F $+%+&+*+=+-+;+>+,+'+5.6.h.h.h.)+-.N F F F I G F F F F !+~+          ",
+"            {+]+F F F F F F -+<.Z.^+^+/+(+_+S.A.=+:+,+h.h.<+-.[+F F G L F F F F F }+|+1+        ",
+"            2+3+F F F F F F 4+<+5+6+7+8+9+i.0+a+b+c+d+h.h.<+-.e+F I  .F F F F F F y.f+g+        ",
+"            h+i+F F F F F G j+k.k+Q.l+m+n+5.Z.p.h.h.h.h.h.o+-.p+q+r+s+F F F F F G t+[+u+        ",
+"            v+w+F F F F  .x+y+>+z+2.o.p.5.=.5.-+U.A+B+h.h.h.-.C+D+D+E+F+F G G `.`.x+[+G+        ",
+"            H+C F F F H I+F ,+J+E.K+L+M+)+A.N+&+O+P+Q+h.h.R+S+D+T+E+U+V+H W+X+x+Y+x+|+Z+        ",
+"          `+ @F F F `.`.F F .@b+n.c++@@@4.h.h.h.h.#@h.h.R+$@D+%@&@U+U+*@=@f+-@;@>@J g+1+        ",
+"          ,@'@F F )@G F F F '+n+n+4.=.=.h.X.h.h.h.A.h.!@$@D+~@U+U+U+U+{@]@^@/@(@!+M |+_@:@      ",
+"          <@[@}@|@F F F F F n+n+|.1@o+O.2@3@:+A+A+4@5@D+D+6@U+U+U+7@8@9@0@a@b@c@d@e@f@g@h@      ",
+"          i@j@k@b@l@F F F F 5.=.4.%+m@5.p.b+h.h.h.n@D+D+o@U+U+U+p@9@9@q@r@c@s@t@u@v@w@x@y@      ",
+"          z@A@B@C@D@E@F F F =.6.6.6.h.h.h.h.h.h.F@D+G@H@U+U+U+I@9@J@K@c@L@D@M@N@O@P@Q@R@S@      ",
+"          T@U@V@W@X@Y@Z@F F 6.6.6.h.h.h.h.h.h.F@D+`@ #U+U+.#+#9@@###s@$#%#&#*#=#-#;#>#,#'#      ",
+"        )#!#~#{#]#^#/#(#_#G :#<#<+<+<+<+<+[#}#D+~@U+U+U+|#9@9@1#2#3#&#4#5#6#7#8#9#0#a#b#y@      ",
+"        c#d#e#f#g#h#i#j#k#l#G m#-.-.-.-.n#o#D+p#U+U+U+q#9@r#s#t#t#5#%#u#v#w#x#y#z#A#B#C#D#      ",
+"        E#F#G#H#I#J#K#L#M#N#O#P#m#Q#R#S#T#D+U#U+U+V#W#9@X#Y#R#Z#`# $Y#.$+$@$#$$$%$&$*$=$-$;$    ",
+"        >$,$'$a.)$!$~${$]$^$/$($t@_$:$D+<$[$U+U+}$9@9@|$Z#1$1$Q#2$3$4$5$6$7$8$9$0$a$b$c$d$e$    ",
+"        f$g$h$i$j$N#k$l$m$n$o$p$q$r$D+s$[$U+U+t$9@u$v$w$x$y$R#2#s@z$A$n$B$p$p$p$p$p$p$r@m#C$    ",
+"                                  D$E$U+U+F$G$9@H$-.-.-.-.-.                                    ",
+"                                I$J$K$L$M$9@9@N$-.-.-.-.-.                                      ",
+"                                O$P$Q$R$S$T$U$-.-.-.-.                                          ",
+"                              V$W$X$-.Y$Z$-.-.-.-.                                              ",
+"                              `$ %.%    -.-.-.                                                  ",
+"                                      -.-.                                                      ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                "};
+
+static char * documents_xpm[] = {
+"48 48 317 2",
+"  	c None",
+". 	c #000000",
+"+ 	c #978F7C",
+"@ 	c #8F8775",
+"# 	c #605D52",
+"$ 	c #070706",
+"% 	c #24231F",
+"& 	c #33312C",
+"* 	c #3B3932",
+"= 	c #3A372F",
+"- 	c #676154",
+"; 	c #AE8E53",
+"> 	c #DDAF5A",
+", 	c #F3B94F",
+"' 	c #948C79",
+") 	c #24221E",
+"! 	c #7E7767",
+"~ 	c #857E6D",
+"{ 	c #524D42",
+"] 	c #3E3B34",
+"^ 	c #2F2D29",
+"/ 	c #201F1D",
+"( 	c #191816",
+"_ 	c #282622",
+": 	c #858175",
+"< 	c #A59E8D",
+"[ 	c #99927F",
+"} 	c #B18F52",
+"| 	c #E4B04F",
+"1 	c #B48B3A",
+"2 	c #6F5224",
+"3 	c #DEC277",
+"4 	c #CAAF6F",
+"5 	c #90825F",
+"6 	c #A4A093",
+"7 	c #C8C4B9",
+"8 	c #D0CDC4",
+"9 	c #C5C0B6",
+"0 	c #B2AC9E",
+"a 	c #A7A090",
+"b 	c #7E7867",
+"c 	c #6D6758",
+"d 	c #22201C",
+"e 	c #151411",
+"f 	c #181714",
+"g 	c #232220",
+"h 	c #343432",
+"i 	c #43423F",
+"j 	c #3D3C38",
+"k 	c #524E47",
+"l 	c #716B5C",
+"m 	c #928A78",
+"n 	c #8D8472",
+"o 	c #706557",
+"p 	c #50473D",
+"q 	c #29221E",
+"r 	c #201A17",
+"s 	c #4D3C1F",
+"t 	c #5F4922",
+"u 	c #604A22",
+"v 	c #E9E089",
+"w 	c #FDFAA2",
+"x 	c #FAF5A0",
+"y 	c #D3C28F",
+"z 	c #858481",
+"A 	c #C5C2BC",
+"B 	c #B6B1A5",
+"C 	c #8E8674",
+"D 	c #645F54",
+"E 	c #57544D",
+"F 	c #37352F",
+"G 	c #2C2923",
+"H 	c #2C2A24",
+"I 	c #32302B",
+"J 	c #5D5A54",
+"K 	c #737069",
+"L 	c #A7A59D",
+"M 	c #BBB9B1",
+"N 	c #A5A297",
+"O 	c #A29D93",
+"P 	c #857F6E",
+"Q 	c #8A8371",
+"R 	c #918977",
+"S 	c #857B6A",
+"T 	c #5B5146",
+"U 	c #342D27",
+"V 	c #241D17",
+"W 	c #4E3D1F",
+"X 	c #E5D683",
+"Y 	c #E8E392",
+"Z 	c #BFBD7C",
+"` 	c #312C28",
+" .	c #4E4640",
+"..	c #605750",
+"+.	c #413B34",
+"@.	c #413C36",
+"#.	c #514B42",
+"$.	c #B6B3AD",
+"%.	c #B9B5AF",
+"&.	c #C0BDB4",
+"*.	c #C1BDB2",
+"=.	c #BAB5A8",
+"-.	c #B5AFA2",
+";.	c #B0A99B",
+">.	c #A29B8A",
+",.	c #958C78",
+"'.	c #887E6D",
+").	c #675C50",
+"!.	c #3C342D",
+"~.	c #221B17",
+"{.	c #4C3B1F",
+"].	c #D0B470",
+"^.	c #B8A263",
+"/.	c #332E29",
+"(.	c #3B3530",
+"_.	c #5C524B",
+":.	c #585048",
+"<.	c #4B433E",
+"[.	c #847B75",
+"}.	c #695E56",
+"|.	c #877F78",
+"1.	c #77736D",
+"2.	c #EBE6AB",
+"3.	c #EEECCF",
+"4.	c #DEDDB0",
+"5.	c #C1BE70",
+"6.	c #9C8653",
+"7.	c #9E8B5B",
+"8.	c #1F1916",
+"9.	c #1E1815",
+"0.	c #1E1816",
+"a.	c #948259",
+"b.	c #3E3731",
+"c.	c #3E3732",
+"d.	c #534A44",
+"e.	c #625850",
+"f.	c #574E47",
+"g.	c #413A34",
+"h.	c #99918B",
+"i.	c #463E39",
+"j.	c #867E56",
+"k.	c #E3E2AB",
+"l.	c #C8C7AB",
+"m.	c #938E5B",
+"n.	c #615233",
+"o.	c #3E3522",
+"p.	c #181311",
+"q.	c #1C1714",
+"r.	c #504842",
+"s.	c #423B35",
+"t.	c #938B85",
+"u.	c #332D28",
+"v.	c #B6A267",
+"w.	c #857F4E",
+"x.	c #5F5134",
+"y.	c #352D1C",
+"z.	c #191412",
+"A.	c #5B514A",
+"B.	c #504741",
+"C.	c #645951",
+"D.	c #564D46",
+"E.	c #2F2926",
+"F.	c #3D352B",
+"G.	c #8D7E49",
+"H.	c #493D27",
+"I.	c #161210",
+"J.	c #5D534C",
+"K.	c #5E544D",
+"L.	c #635851",
+"M.	c #594F49",
+"N.	c #37302D",
+"O.	c #99928C",
+"P.	c #3A3430",
+"Q.	c #433924",
+"R.	c #251F17",
+"S.	c #171311",
+"T.	c #1A1512",
+"U.	c #61564F",
+"V.	c #5A514A",
+"W.	c #332D29",
+"X.	c #9E9792",
+"Y.	c #1A1513",
+"Z.	c #514943",
+"`.	c #5A504A",
+" +	c #2C2724",
+".+	c #9D9691",
+"++	c #332D2A",
+"@+	c #3B3531",
+"#+	c #645A52",
+"$+	c #5F554E",
+"%+	c #352F2C",
+"&+	c #A29C97",
+"*+	c #5F554D",
+"=+	c #655A52",
+"-+	c #34302B",
+";+	c #ABA5A1",
+">+	c #2E2926",
+",+	c #665B53",
+"'+	c #342E2A",
+")+	c #A59E9A",
+"!+	c #0C0908",
+"~+	c #595049",
+"{+	c #595048",
+"]+	c #282421",
+"^+	c #9F9893",
+"/+	c #624C27",
+"(+	c #231A0C",
+"_+	c #47403A",
+":+	c #514842",
+"<+	c #27221F",
+"[+	c #AAA39F",
+"}+	c #382C1D",
+"|+	c #E3AF4D",
+"1+	c #372A12",
+"2+	c #48403B",
+"3+	c #4D443F",
+"4+	c #554C46",
+"5+	c #231F1C",
+"6+	c #AFA9A5",
+"7+	c #403833",
+"8+	c #B3893E",
+"9+	c #CE9C43",
+"0+	c #2B200E",
+"a+	c #3A342F",
+"b+	c #48413B",
+"c+	c #5A5049",
+"d+	c #23201D",
+"e+	c #AAA4A0",
+"f+	c #61574F",
+"g+	c #755928",
+"h+	c #423214",
+"i+	c #140F06",
+"j+	c #18130C",
+"k+	c #39332F",
+"l+	c #36312C",
+"m+	c #4A423C",
+"n+	c #37312D",
+"o+	c #9E9995",
+"p+	c #5D544C",
+"q+	c #4F4741",
+"r+	c #665C54",
+"s+	c #040303",
+"t+	c #0B0904",
+"u+	c #71613A",
+"v+	c #242018",
+"w+	c #413A35",
+"x+	c #524A43",
+"y+	c #2F2A27",
+"z+	c #999490",
+"A+	c #120F0D",
+"B+	c #030302",
+"C+	c #D1CD7A",
+"D+	c #454025",
+"E+	c #1C1916",
+"F+	c #4A433D",
+"G+	c #86807E",
+"H+	c #60564E",
+"I+	c #3F3732",
+"J+	c #1D1714",
+"K+	c #D6CD7A",
+"L+	c #A69557",
+"M+	c #2A251D",
+"N+	c #352F2B",
+"O+	c #403934",
+"P+	c #84807D",
+"Q+	c #625750",
+"R+	c #3D3531",
+"S+	c #1B1613",
+"T+	c #38311C",
+"U+	c #9B8652",
+"V+	c #84724C",
+"W+	c #292421",
+"X+	c #3C3631",
+"Y+	c #7F7A76",
+"Z+	c #322C28",
+"`+	c #181411",
+" @	c #1C1614",
+".@	c #0F0C0B",
+"+@	c #070604",
+"@@	c #2D281D",
+"#@	c #1D1A17",
+"$@	c #302B28",
+"%@	c #696561",
+"&@	c #544B45",
+"*@	c #433C37",
+"=@	c #5E5240",
+"-@	c #938151",
+";@	c #2F271D",
+">@	c #1D1815",
+",@	c #1C1917",
+"'@	c #36302C",
+")@	c #726D6B",
+"!@	c #554C45",
+"~@	c #6F6349",
+"{@	c #E4D985",
+"]@	c #B9AF67",
+"^@	c #6A5D39",
+"/@	c #31291C",
+"(@	c #221C16",
+"_@	c #1D1B1A",
+":@	c #49423B",
+"<@	c #C2B570",
+"[@	c #F7F49D",
+"}@	c #C4BE71",
+"|@	c #635333",
+"1@	c #493E24",
+"2@	c #1C1710",
+"3@	c #49413B",
+"4@	c #4A4131",
+"5@	c #B6A864",
+"6@	c #C3AC63",
+"7@	c #78673D",
+"8@	c #252012",
+"9@	c #030202",
+"0@	c #2A2419",
+"a@	c #342D1B",
+"b@	c #17130C",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                    .                                           ",
+"                                          . . . . . . . .                                       ",
+"                                        . . . . . . . . .                                       ",
+"                                        . .             .                                       ",
+"                                      . .         + @ # $ % & * = - +   ; > ,                   ",
+"                                  + ' ) ) ! ~ { ] ^ / ( _ : < [ + + + + } | 1 2                 ",
+"          3 4 5 6 7 8 9 0 a + + + b c d e f g h i j k l m + + n o p q r r s t u                 ",
+"      v w x y z A B C D E F G H I J K L M N O P Q R n S T U r r r r r r r V W t                 ",
+"      X Y Z `  ...+.@.#.$.%.&.*.=.-.;.>.+ ,.'.).!.r r r r r r r r r r r r r ~.{.                ",
+"      ].^./.(._.:.<.[.}.|.1.2.3.4.5.6.7.8.9.0.r r r r r r r r r r r r r r r r r                 ",
+"      a.b.c.d.e.f.g.h.}.}.i.j.k.l.m.n.o.p.q.r r r r r r r r r r r r r r r r r                   ",
+"        r.<._.}.f.s.t.}.}.}.u.v.w.x.y.z.p.8.r r r r r r r r r r r r r r r r r                   ",
+"        A.B.C.}.D.E.t.}.}.}.d.F.G.H.z.I.q.r r r r r r r r r r r r r r r r r r                   ",
+"        J.K.L.}.M.N.O.}.}.}.}.P.Q.R.S.T.r r r r r r r r r r r r r r r r r r r                   ",
+"        A.U.}.}.V.W.X.}.}.}.}.A.Y.T.I.r r r r r r r r r r r r r r r r r r r r                   ",
+"        Z._.e.}.`. +.+}.}.}.}._.r 9.q.r r r r r r r r r r r r r r r r r r r r                   ",
+"        i.U.U.}._.++O.}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r r r                   ",
+"        @+#+$+}._.%+&+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r r r                   ",
+"         +*+$+=+D.-+;+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r r 9.                  ",
+"        >+K._.,+V.'+)+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r 0.!+                  ",
+"          ~+~+C.{+]+^+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r /+(+                  ",
+"          _+:+A.`.<+[+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r }+|+1+                  ",
+"        . 2+3+4+_.5+6+}.}.}.}.7+r r r r r r r r r r r r r r r r r r r r 8+9+0+                  ",
+"          a+:+b+c+d+e+}.}.f+~+7+r r r r r r r r r r r r r r r r r r r V g+h+i+. . .             ",
+"        . j+k+l+m+n+o+}.p+q+r+7+r r r r r r r r r r r r r r r r r r p.s+. t+. . . . . . .       ",
+"          u+v+w+x+y+z+K.d._.d.7+r r r r r r r r r r r r r r r r A+B+. . . . . . . . . . . .     ",
+"          C+D+E+F+W.G+,+H+f.f+I+J+8.r r r r r r r r r r r r A+B+. . . . . . . . . . . . .       ",
+"        . K+L+M+N+O+P+L._.A.Q+R+q.S+9.r r r r r r r r r A+B+. . . . . . . . . . . . .           ",
+"        . T+U+V+W+X+Y+#+f.A.q+Z+z.`+Y. @r r r r r q..@B+. . . . . . . . . . . . .               ",
+"          . +@@@#@$@%@H+&@*@=@-@;@I.z.Y.>@r r q..@. . . . . . . . . . . . . .                   ",
+"              . ,@'@)@!@*@~@{@]@^@/@(@q.r q..@. . . . . . . . . . . . . .                       ",
+"                  . _@a+:@<@[@}@|@1@2@I..@. . . . . . . . . . . . .                             ",
+"                        3@4@5@6@7@8@9@. . . . . . . . . . . . .                                 ",
+"                            0@a@b@. . . . . . . . . .                                           ",
+"                                . . . .                                                         ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                "};
+
 
 #define DIR_LIST_WIDTH   180
 #define DIR_LIST_HEIGHT  180
@@ -335,10 +2074,15 @@
 static void gtk_file_selection_delete_file (GtkWidget *widget, gpointer data);
 static void gtk_file_selection_rename_file (GtkWidget *widget, gpointer data);
 
+static void home_clicked (GtkWidget *widget, gpointer data);
+static void desktop_clicked (GtkWidget *widget, gpointer data);
+static void documents_clicked (GtkWidget *widget, gpointer data);
 
 
 static GtkWindowClass *parent_class = NULL;
 
+static char *last_dir = NULL;
+
 /* Saves errno when something cmpl does fails. */
 static gint cmpl_errno;
 
@@ -379,6 +2123,43 @@
   object_class->destroy = gtk_file_selection_destroy;
 }
 
+static GtkWidget *
+create_pixmap_button (GtkFileSelection *filesel, 
+		      GtkWidget *parent_hbox,
+		      gchar **xpm_data,
+		      gchar *title)
+{
+  GtkWidget *btn;
+  GtkWidget *hbox;
+  GtkWidget *wpixmap;
+  GtkWidget *label;
+  GdkPixmap *pixmap;
+  GdkPixmap *mask;
+  
+  btn = gtk_button_new ();
+  gtk_box_pack_start (GTK_BOX (parent_hbox), btn, TRUE, FALSE, 5);
+  gtk_widget_realize (btn);
+
+  pixmap = gdk_pixmap_create_from_xpm_d (btn->window, &mask, 
+					 &btn->style->bg[GTK_STATE_NORMAL], 
+					 (gchar**)xpm_data);
+  
+  label = gtk_label_new (title);
+  
+  wpixmap = gtk_pixmap_new (pixmap, mask);
+  
+  hbox = gtk_vbox_new (FALSE, 5);
+
+  gtk_box_pack_start (GTK_BOX (hbox), wpixmap, FALSE, FALSE, 0);
+  gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
+
+  gtk_widget_show_all (hbox);
+
+  gtk_container_add (GTK_CONTAINER (btn), hbox);
+
+  return btn;
+}
+
 static void
 gtk_file_selection_init (GtkFileSelection *filesel)
 {
@@ -388,7 +2169,10 @@
   GtkWidget *confirm_area;
   GtkWidget *pulldown_hbox;
   GtkWidget *scrolled_win;
+  GtkWidget *navigation_area;
+  GtkWidget *btn;
 
+  char *dirname;
   char *dir_title [2];
   char *file_title [2];
   
@@ -400,16 +2184,6 @@
   gtk_container_add (GTK_CONTAINER (filesel), filesel->main_vbox);
   gtk_widget_show (filesel->main_vbox);
 
-  /* The horizontal box containing create, rename etc. buttons */
-  filesel->button_area = gtk_hbutton_box_new ();
-  gtk_button_box_set_layout(GTK_BUTTON_BOX(filesel->button_area), GTK_BUTTONBOX_START);
-  gtk_button_box_set_spacing(GTK_BUTTON_BOX(filesel->button_area), 0);
-  gtk_box_pack_start (GTK_BOX (filesel->main_vbox), filesel->button_area, 
-		      FALSE, FALSE, 0);
-  gtk_widget_show (filesel->button_area);
-  
-  gtk_file_selection_show_fileop_buttons(filesel);
-
   /* hbox for pulldown menu */
   pulldown_hbox = gtk_hbox_new (TRUE, 5);
   gtk_box_pack_start (GTK_BOX (filesel->main_vbox), pulldown_hbox, FALSE, FALSE, 0);
@@ -419,13 +2193,56 @@
   filesel->history_pulldown = gtk_option_menu_new ();
   gtk_widget_show (filesel->history_pulldown);
   gtk_box_pack_start (GTK_BOX (pulldown_hbox), filesel->history_pulldown, 
-		      FALSE, FALSE, 0);
+		      TRUE, FALSE, 0);
     
   /*  The horizontal box containing the directory and file listboxes  */
   list_hbox = gtk_hbox_new (FALSE, 5);
   gtk_box_pack_start (GTK_BOX (filesel->main_vbox), list_hbox, TRUE, TRUE, 0);
   gtk_widget_show (list_hbox);
 
+  /* The navigation buttons */
+  navigation_area = gtk_vbox_new (TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (list_hbox), navigation_area, FALSE, FALSE, 5);
+  gtk_widget_show (navigation_area);
+
+  if (g_get_home_dir () != NULL) 
+    {
+      struct stat sb;
+      btn = create_pixmap_button (filesel, navigation_area, 
+				  (gchar **)home_xpm, 
+				  _("Home"));
+      gtk_widget_show (btn);
+      gtk_signal_connect (GTK_OBJECT (btn), "clicked",
+			  home_clicked, filesel);
+
+      dirname = g_strdup_printf ("%s/.gnome-desktop/", g_get_home_dir ());
+      if (stat (dirname, &sb) == 0 && S_ISDIR(sb.st_mode))
+	{
+	  btn = create_pixmap_button (filesel, navigation_area, 
+				      (gchar **)desktop_xpm, 
+				      _("Desktop"));
+	  gtk_widget_show (btn);
+	  gtk_signal_connect (GTK_OBJECT (btn), "clicked",
+			      desktop_clicked, filesel);
+
+	  
+	}
+      g_free (dirname);
+      
+      dirname = g_strdup_printf ("%s/Documents/", g_get_home_dir ());
+      if (stat (dirname, &sb) == 0 && S_ISDIR(sb.st_mode))
+	{
+	  btn = create_pixmap_button (filesel, navigation_area, 
+				      (gchar **)documents_xpm, 
+				      _("Documents"));
+	  gtk_widget_show (btn);
+	  gtk_signal_connect (GTK_OBJECT (btn), "clicked",
+			      documents_clicked, filesel);
+	}
+      
+      g_free (dirname);
+    }
+
   /* The directories clist */
   dir_title[0] = _("Directories");
   dir_title[1] = NULL;
@@ -464,6 +2281,16 @@
   gtk_widget_show (filesel->file_list);
   gtk_widget_show (scrolled_win);
 
+  /* The horizontal box containing create, rename etc. buttons */
+  filesel->button_area = gtk_hbutton_box_new ();
+  gtk_button_box_set_layout(GTK_BUTTON_BOX(filesel->button_area), GTK_BUTTONBOX_END);
+  gtk_button_box_set_spacing(GTK_BUTTON_BOX(filesel->button_area), 0);
+  gtk_box_pack_start (GTK_BOX (filesel->main_vbox), filesel->button_area, 
+		      FALSE, FALSE, 0);
+  gtk_widget_show (filesel->button_area);
+  
+  gtk_file_selection_show_fileop_buttons(filesel);
+
   /* action area for packing buttons into. */
   filesel->action_area = gtk_hbox_new (TRUE, 0);
   gtk_box_pack_start (GTK_BOX (filesel->main_vbox), filesel->action_area, 
@@ -510,6 +2337,7 @@
                              (GtkSignalFunc) gtk_button_clicked,
                              GTK_OBJECT (filesel->ok_button));
   gtk_box_pack_start (GTK_BOX (entry_vbox), filesel->selection_entry, TRUE, TRUE, 0);
+  gtk_object_set_data (GTK_OBJECT (filesel->selection_entry), "last_entry_was_dir_selection", (gpointer) FALSE);
   gtk_widget_show (filesel->selection_entry);
 
   if (!cmpl_state_okay (filesel->cmpl_state))
@@ -522,7 +2350,14 @@
     }
   else
     {
-      gtk_file_selection_populate (filesel, "", FALSE);
+      if (last_dir) 
+	{
+	  gtk_file_selection_populate (filesel, last_dir, FALSE);
+	}
+      else
+	{
+	  gtk_file_selection_populate (filesel, "", FALSE);
+	}
     }
 
   gtk_widget_grab_focus (filesel->selection_entry);
@@ -1094,6 +2929,41 @@
 }
 
 
+static void
+home_clicked (GtkWidget *widget, gpointer data)
+{
+  char *dir;
+  
+  dir = g_strdup_printf ("%s/", g_get_home_dir());
+  
+  gtk_file_selection_populate (GTK_FILE_SELECTION (data), 
+			       dir, FALSE);
+  g_free (dir);
+}
+
+static void
+desktop_clicked (GtkWidget *widget, gpointer data)
+{
+  char *dir;
+  
+  dir = g_strdup_printf ("%s/.gnome-desktop/", g_get_home_dir ());
+  
+  gtk_file_selection_populate (GTK_FILE_SELECTION (data), 
+			       dir, FALSE);
+  g_free (dir);
+}
+
+static void 
+documents_clicked (GtkWidget *widget, gpointer data)
+{
+  char *dir;
+  dir = g_strdup_printf ("%s/Documents/", g_get_home_dir ());
+  
+  gtk_file_selection_populate (GTK_FILE_SELECTION (data), dir, FALSE);
+  
+  g_free (dir);
+}
+
 static gint
 gtk_file_selection_key_press (GtkWidget   *widget,
 			      GdkEventKey *event,
@@ -1105,9 +2975,11 @@
   g_return_val_if_fail (widget != NULL, FALSE);
   g_return_val_if_fail (event != NULL, FALSE);
 
+  fs = GTK_FILE_SELECTION (user_data);
+  gtk_object_set_data (GTK_OBJECT (fs->selection_entry), "last_entry_was_dir_selection", (gpointer) FALSE);
+
   if (event->keyval == GDK_Tab)
     {
-      fs = GTK_FILE_SELECTION (user_data);
       text = gtk_entry_get_text (GTK_ENTRY (fs->selection_entry));
 
       text = g_strdup (text);
@@ -1246,7 +3118,8 @@
 
   if (filename)
     {
-      if (bevent)
+      gtk_object_set_data (GTK_OBJECT (fs->selection_entry), "last_entry_was_dir_selection", (gpointer) FALSE);
+			if (bevent)
 	switch (bevent->type)
 	  {
 	  case GDK_2BUTTON_PRESS:
@@ -1273,6 +3146,8 @@
 {
   GtkFileSelection *fs = NULL;
   gchar *filename, *temp = NULL;
+  const gchar *entry_text;
+  gboolean last_entry_was_dir_selection;
 
   g_return_if_fail (GTK_IS_CLIST (widget));
 
@@ -1283,6 +3158,10 @@
   gtk_clist_get_text (GTK_CLIST (fs->dir_list), row, 0, &temp);
   filename = g_strdup (temp);
 
+  entry_text = gtk_entry_get_text (GTK_ENTRY (fs->selection_entry));
+  last_entry_was_dir_selection = (gboolean) gtk_object_get_data (GTK_OBJECT (fs->selection_entry),
+								 "last_entry_was_dir_selection");
+
   if (filename)
     {
       if (bevent)
@@ -1293,14 +3172,24 @@
 	    break;
 	  
 	  default:
-	    gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), filename);
+	    if (!entry_text || !strlen (entry_text) || last_entry_was_dir_selection)
+	      {
+		gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), filename);
+		last_entry_was_dir_selection = TRUE;
+	      }
 	    break;
 	  }
-      else
-	gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), filename);
+      else if (!entry_text || !strlen (entry_text) || last_entry_was_dir_selection)
+	  {
+	    gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), filename);
+	    last_entry_was_dir_selection = TRUE;
+	  }
 
       g_free (filename);
     }
+
+  gtk_object_set_data (GTK_OBJECT (fs->selection_entry), "last_entry_was_dir_selection",
+		       (gpointer) last_entry_was_dir_selection);
 }
 
 static void
@@ -1443,12 +3332,19 @@
     }
   else
     {
-      if (fs->selection_entry)
+      gboolean last_entry_was_dir_selection;
+
+      last_entry_was_dir_selection = (gboolean) gtk_object_get_data (GTK_OBJECT (fs->selection_entry),
+								     "last_entry_was_dir_selection");
+
+      if (fs->selection_entry && last_entry_was_dir_selection)
 	gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), "");
     }
 
   if (!did_recurse)
     {
+      char *dirname;
+      struct stat ent_sbuf;
       if (fs->selection_entry)
 	gtk_entry_set_position (GTK_ENTRY (fs->selection_entry), selection_index);
 
@@ -1466,7 +3362,19 @@
 	{
 	  gtk_file_selection_update_history_menu (fs, cmpl_reference_position (cmpl_state));
 	}
-      
+
+      dirname = cmpl_reference_position (cmpl_state);
+      if(dirname && stat(dirname, &ent_sbuf) >= 0 && S_ISDIR(ent_sbuf.st_mode))
+        {
+          if (last_dir) 
+            {
+              g_free (last_dir);
+            }
+
+
+          
+          last_dir = g_strdup_printf ("%s%c", dirname, G_DIR_SEPARATOR);
+        }
     }
 }
 
diff -uNr a/gtk/gtkfilesel.c~ b/gtk/gtkfilesel.c~
--- a/gtk/gtkfilesel.c~	Wed Dec 31 19:00:00 1969
+++ b/gtk/gtkfilesel.c~	Mon May 27 17:47:20 2002
@@ -0,0 +1,4657 @@
+/* GTK - The GIMP Toolkit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/param.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <pwd.h>
+#include "fnmatch.h"
+
+#include "gdk/gdkkeysyms.h"
+#include "gtkbutton.h"
+#include "gtkentry.h"
+#include "gtkfilesel.h"
+#include "gtkhbox.h"
+#include "gtkhbbox.h"
+#include "gtklabel.h"
+#include "gtklist.h"
+#include "gtklistitem.h"
+#include "gtkmain.h"
+#include "gtkscrolledwindow.h"
+#include "gtksignal.h"
+#include "gtkvbox.h"
+#include "gtkmenu.h"
+#include "gtkmenuitem.h"
+#include "gtkoptionmenu.h"
+#include "gtkclist.h"
+#include "gtkdialog.h"
+#include "gtkintl.h"
+#include "gtkpixmap.h"
+
+static char * home_xpm[] = {
+"48 48 714 2",
+"  	c None",
+". 	c #634D3A",
+"+ 	c #9C8871",
+"@ 	c #654E3D",
+"# 	c #35271C",
+"$ 	c #000000",
+"% 	c #050101",
+"& 	c #0B0301",
+"* 	c #080100",
+"= 	c #0F0402",
+"- 	c #B0A08D",
+"; 	c #7C6859",
+"> 	c #9C8B7C",
+", 	c #523D31",
+"' 	c #271D16",
+") 	c #200806",
+"! 	c #C6918A",
+"~ 	c #8D2C22",
+"{ 	c #541812",
+"] 	c #6E1C15",
+"^ 	c #020000",
+"/ 	c #B6A996",
+"( 	c #716052",
+"_ 	c #453324",
+": 	c #3F2E24",
+"< 	c #C3B7B0",
+"[ 	c #443529",
+"} 	c #1B140F",
+"| 	c #110403",
+"1 	c #581A14",
+"2 	c #49120D",
+"3 	c #49130E",
+"4 	c #42110C",
+"5 	c #0A0101",
+"6 	c #A79A87",
+"7 	c #837566",
+"8 	c #423124",
+"9 	c #231B15",
+"0 	c #4B423A",
+"a 	c #6B5D52",
+"b 	c #D1C9C3",
+"c 	c #3D3127",
+"d 	c #16100C",
+"e 	c #371915",
+"f 	c #B46B60",
+"g 	c #60221C",
+"h 	c #69201A",
+"i 	c #681F19",
+"j 	c #96836F",
+"k 	c #9F9185",
+"l 	c #5D4A39",
+"m 	c #0F0C09",
+"n 	c #3A3632",
+"o 	c #9A9C99",
+"p 	c #453B33",
+"q 	c #8A7C71",
+"r 	c #C4BAB0",
+"s 	c #2E241C",
+"t 	c #110C09",
+"u 	c #1D0806",
+"v 	c #62221C",
+"w 	c #541611",
+"x 	c #46120D",
+"y 	c #A2917D",
+"z 	c #AEA397",
+"A 	c #806B58",
+"B 	c #25201B",
+"C 	c #525251",
+"D 	c #949493",
+"E 	c #656665",
+"F 	c #6E6259",
+"G 	c #72665C",
+"H 	c #D4CDC6",
+"I 	c #261D18",
+"J 	c #2E0E0B",
+"K 	c #A64D41",
+"L 	c #603429",
+"M 	c #968772",
+"N 	c #B7AEA3",
+"O 	c #7F6C5D",
+"P 	c #0E0B09",
+"Q 	c #211C18",
+"R 	c #BABAB9",
+"S 	c #494948",
+"T 	c #B4B5B4",
+"U 	c #565655",
+"V 	c #B7B9B7",
+"W 	c #85807A",
+"X 	c #66594F",
+"Y 	c #BDB2A7",
+"Z 	c #3A2D23",
+"` 	c #080504",
+" .	c #2B231D",
+"..	c #190605",
+"+.	c #9F5546",
+"@.	c #998A77",
+"#.	c #B0A599",
+"$.	c #6F6254",
+"%.	c #0B0907",
+"&.	c #1F1B18",
+"*.	c #5C5C5A",
+"=.	c #B9B9B7",
+"-.	c #40403F",
+";.	c #CFD1CF",
+">.	c #565656",
+",.	c #D2D2D2",
+"'.	c #939391",
+").	c #918D88",
+"!.	c #3C2E25",
+"~.	c #A39385",
+"{.	c #5C4B40",
+"].	c #29211B",
+"^.	c #423B32",
+"/.	c #9A8B77",
+"(.	c #A99D91",
+"_.	c #564B40",
+":.	c #070605",
+"<.	c #1A1715",
+"[.	c #A6A6A5",
+"}.	c #4F514F",
+"|.	c #3A3B3A",
+"1.	c #E4E4E4",
+"2.	c #606060",
+"3.	c #A5A6A5",
+"4.	c #9D9D9C",
+"5.	c #75716E",
+"6.	c #281E17",
+"7.	c #A29387",
+"8.	c #6F5D4F",
+"9.	c #090605",
+"0.	c #271F19",
+"a.	c #B4A58D",
+"b.	c #978777",
+"c.	c #BEB5AA",
+"d.	c #4B4139",
+"e.	c #080605",
+"f.	c #1E1B19",
+"g.	c #666665",
+"h.	c #B1B1B0",
+"i.	c #5A5A5A",
+"j.	c #BEBEBD",
+"k.	c #555555",
+"l.	c #EAEAEA",
+"m.	c #696969",
+"n.	c #E7E7E7",
+"o.	c #A9A9A9",
+"p.	c #C2C3C2",
+"q.	c #686968",
+"r.	c #9C9996",
+"s.	c #2E221B",
+"t.	c #837569",
+"u.	c #685446",
+"v.	c #AA9A85",
+"w.	c #B5A997",
+"x.	c #D2CCC3",
+"y.	c #3D352D",
+"z.	c #080705",
+"A.	c #23201C",
+"B.	c #B2B2B1",
+"C.	c #AEAEAE",
+"D.	c #7D7D7D",
+"E.	c #DADADA",
+"F.	c #777777",
+"G.	c #999999",
+"H.	c #EBEBEB",
+"I.	c #A7A7A7",
+"J.	c #DDDDDD",
+"K.	c #A5A5A3",
+"L.	c #6E6B68",
+"M.	c #332921",
+"N.	c #68564A",
+"O.	c #634D3D",
+"P.	c #16100B",
+"Q.	c #1B130F",
+"R.	c #A0907A",
+"S.	c #D1C8B9",
+"T.	c #A2968A",
+"U.	c #28221C",
+"V.	c #0B0908",
+"W.	c #4A4641",
+"X.	c #828280",
+"Y.	c #EFEFEF",
+"Z.	c #858585",
+"`.	c #E9E9E9",
+" +	c #979797",
+".+	c #EEEEEE",
+"++	c #9A9A9A",
+"@+	c #6F6F6F",
+"#+	c #D4D4D4",
+"$+	c #5F5F5D",
+"%+	c #9C9C99",
+"&+	c #2D251E",
+"*+	c #5D4D40",
+"=+	c #6B5545",
+"-+	c #2B1F16",
+";+	c #C0B199",
+">+	c #E7E1D6",
+",+	c #756B5F",
+"'+	c #18130F",
+")+	c #100D0A",
+"!+	c #595551",
+"~+	c #B7B7B6",
+"{+	c #585958",
+"]+	c #A9A9A7",
+"^+	c #6E6F6E",
+"/+	c #C6C8C6",
+"(+	c #8E8E8E",
+"_+	c #F2F2F2",
+":+	c #E8E8E8",
+"<+	c #A0A0A0",
+"[+	c #9C9C9C",
+"}+	c #F0F0F0",
+"|+	c #8D8D8D",
+"1+	c #777775",
+"2+	c #AAAAA9",
+"3+	c #74726F",
+"4+	c #271F1A",
+"5+	c #58483B",
+"6+	c #695442",
+"7+	c #39291D",
+"8+	c #231D1A",
+"9+	c #B7A994",
+"0+	c #F3ECDA",
+"a+	c #DAD4C9",
+"b+	c #5F524A",
+"c+	c #94918D",
+"d+	c #717271",
+"e+	c #B6B6B5",
+"f+	c #686866",
+"g+	c #7A7A78",
+"h+	c #969696",
+"i+	c #F3F3F3",
+"j+	c #B4B4B4",
+"k+	c #E5E5E5",
+"l+	c #A2A2A2",
+"m+	c #EDEDED",
+"n+	c #AAAAAA",
+"o+	c #D9D9D9",
+"p+	c #727271",
+"q+	c #93918E",
+"r+	c #27211B",
+"s+	c #493B30",
+"t+	c #715C4B",
+"u+	c #463324",
+"v+	c #0E0906",
+"w+	c #251F1B",
+"x+	c #D6C9B2",
+"y+	c #FFFBEE",
+"z+	c #D2CBC0",
+"A+	c #4D4137",
+"B+	c #110E0B",
+"C+	c #1D1711",
+"D+	c #837F7A",
+"E+	c #696968",
+"F+	c #B5B5B5",
+"G+	c #6E6E6C",
+"H+	c #D9D9D8",
+"I+	c #F4F4F4",
+"J+	c #A6A6A6",
+"K+	c #E2E2E2",
+"L+	c #9D9D9D",
+"M+	c #A5A5A5",
+"N+	c #A3A3A3",
+"O+	c #908E8D",
+"P+	c #251F19",
+"Q+	c #3A2C24",
+"R+	c #6F5C4B",
+"S+	c #4F3A2A",
+"T+	c #150F0B",
+"U+	c #171411",
+"V+	c #B4A796",
+"W+	c #DACBB2",
+"X+	c #FEFAEE",
+"Y+	c #DBD3C9",
+"Z+	c #352C24",
+"`+	c #120F0B",
+" @	c #2E261F",
+".@	c #8E8E8D",
+"+@	c #6C6C6B",
+"@@	c #BABBBA",
+"#@	c #838383",
+"$@	c #ABABAB",
+"%@	c #BABABA",
+"&@	c #E3E3E3",
+"*@	c #ECECEC",
+"=@	c #B2B2B2",
+"-@	c #DCDCDC",
+";@	c #ABADAB",
+">@	c #656360",
+",@	c #251E17",
+"'@	c #2E231B",
+")@	c #6E5949",
+"!@	c #513B2B",
+"~@	c #1F1710",
+"{@	c #0D0A08",
+"]@	c #C5B7A5",
+"^@	c #E5DCCA",
+"/@	c #A0948B",
+"(@	c #1E1711",
+"_@	c #1C1511",
+":@	c #514940",
+"<@	c #454544",
+"[@	c #969694",
+"}@	c #B0B0AE",
+"|@	c #7F7F7D",
+"1@	c #B0B0B0",
+"2@	c #C2C2C2",
+"3@	c #C8C8C8",
+"4@	c #BBBBBB",
+"5@	c #B9B9B9",
+"6@	c #B7B7B7",
+"7@	c #DFDFDF",
+"8@	c #B6B6B6",
+"9@	c #D3D3D3",
+"0@	c #4A4948",
+"a@	c #261F1B",
+"b@	c #32251C",
+"c@	c #543F2E",
+"d@	c #493526",
+"e@	c #120D09",
+"f@	c #16120F",
+"g@	c #5F5248",
+"h@	c #221912",
+"i@	c #554437",
+"j@	c #ADA9A6",
+"k@	c #3A3A3A",
+"l@	c #232322",
+"m@	c #444544",
+"n@	c #9FA09F",
+"o@	c #C5C5C5",
+"p@	c #BFBFBF",
+"q@	c #BEBEBE",
+"r@	c #B1B1B1",
+"s@	c #9F9F9F",
+"t@	c #808080",
+"u@	c #909090",
+"v@	c #4B4B4B",
+"w@	c #4A4A4A",
+"x@	c #2A2A29",
+"y@	c #443C36",
+"z@	c #291E15",
+"A@	c #19120D",
+"B@	c #9A9088",
+"C@	c #0E0E0E",
+"D@	c #1B1B1A",
+"E@	c #4A4B4A",
+"F@	c #DCDDDC",
+"G@	c #F1F1F1",
+"H@	c #F5F5F5",
+"I@	c #373737",
+"J@	c #242424",
+"K@	c #080808",
+"L@	c #292726",
+"M@	c #1C1714",
+"N@	c #1F1F1F",
+"O@	c #E0E0E0",
+"P@	c #D1D1D1",
+"Q@	c #CFCFCF",
+"R@	c #CECECE",
+"S@	c #C9C9C9",
+"T@	c #757575",
+"U@	c #343434",
+"V@	c #1B1B1B",
+"W@	c #292929",
+"X@	c #545454",
+"Y@	c #ADADAD",
+"Z@	c #3B3B3B",
+"`@	c #D5D5D5",
+" #	c #DBDBDB",
+".#	c #D8D8D8",
+"+#	c #464646",
+"@#	c #252828",
+"##	c #050505",
+"$#	c #0F0E0C",
+"%#	c #0C0F0F",
+"&#	c #2D302E",
+"*#	c #C0C0C0",
+"=#	c #BDBDBD",
+"-#	c #272727",
+";#	c #404040",
+">#	c #E1E1E1",
+",#	c #DEDEDE",
+"'#	c #D7D7D7",
+")#	c #181B1B",
+"!#	c #374845",
+"~#	c #242D2C",
+"{#	c #303636",
+"]#	c #363D3C",
+"^#	c #595D5A",
+"/#	c #23221F",
+"(#	c #949494",
+"_#	c #4F4F4F",
+":#	c #222222",
+"<#	c #444444",
+"[#	c #939393",
+"}#	c #262626",
+"|#	c #161917",
+"1#	c #0A0B0A",
+"2#	c #080908",
+"3#	c #090B0A",
+"4#	c #161716",
+"5#	c #303030",
+"6#	c #0E0E0C",
+"7#	c #2B3534",
+"8#	c #555856",
+"9#	c #515251",
+"0#	c #8E8E8B",
+"a#	c #A5A3A0",
+"b#	c #0C0C0C",
+"c#	c #747474",
+"d#	c #3D3D3D",
+"e#	c #2E2E2E",
+"f#	c #2D2D2D",
+"g#	c #525252",
+"h#	c #7F7F7F",
+"i#	c #151515",
+"j#	c #1F221E",
+"k#	c #362E2A",
+"l#	c #050705",
+"m#	c #070C08",
+"n#	c #232D25",
+"o#	c #393939",
+"p#	c #151513",
+"q#	c #191F1E",
+"r#	c #6F6F6E",
+"s#	c #8A8B8A",
+"t#	c #CDCCCA",
+"u#	c #0A0B0B",
+"v#	c #727272",
+"w#	c #484848",
+"x#	c #2B2B2B",
+"y#	c #333333",
+"z#	c #424242",
+"A#	c #6E6E6E",
+"B#	c #1E1E1E",
+"C#	c #7A5551",
+"D#	c #C2827C",
+"E#	c #C4A6A3",
+"F#	c #271E1C",
+"G#	c #0D0C0A",
+"H#	c #313432",
+"I#	c #363B37",
+"J#	c #CBCBCB",
+"K#	c #070808",
+"L#	c #171F1E",
+"M#	c #7C7D7C",
+"N#	c #111313",
+"O#	c #666666",
+"P#	c #3F3F3F",
+"Q#	c #494949",
+"R#	c #181615",
+"S#	c #974B46",
+"T#	c #482521",
+"U#	c #B25851",
+"V#	c #DEC0BD",
+"W#	c #3C3535",
+"X#	c #010101",
+"Y#	c #262827",
+"Z#	c #1C2221",
+"`#	c #8B8B8B",
+" $	c #D1D2D2",
+".$	c #D8D9D8",
+"+$	c #080909",
+"@$	c #4D4D4D",
+"#$	c #5D5D5D",
+"$$	c #040202",
+"%$	c #391D1A",
+"&$	c #7D312B",
+"*$	c #B04D45",
+"=$	c #C47168",
+"-$	c #33201F",
+";$	c #292B2A",
+">$	c #CDCDCD",
+",$	c #CCCCCC",
+"'$	c #0E0D0C",
+")$	c #212926",
+"!$	c #999997",
+"~$	c #BBBDBD",
+"{$	c #DFE0E0",
+"]$	c #141414",
+"^$	c #282828",
+"/$	c #5F5F5F",
+"($	c #414141",
+"_$	c #080606",
+":$	c #833C34",
+"<$	c #8D3F37",
+"[$	c #9C413B",
+"}$	c #9A413A",
+"|$	c #261615",
+"1$	c #242524",
+"2$	c #CACACA",
+"3$	c #1C1E1D",
+"4$	c #29322E",
+"5$	c #D2D3D2",
+"6$	c #D7D7D6",
+"7$	c #111111",
+"8$	c #919191",
+"9$	c #2C2C2C",
+"0$	c #0D0D0D",
+"a$	c #636363",
+"b$	c #9D524A",
+"c$	c #9F3C34",
+"d$	c #994037",
+"e$	c #9C4841",
+"f$	c #151716",
+"g$	c #6C6C6C",
+"h$	c #24201D",
+"i$	c #323530",
+"j$	c #2E2E28",
+"k$	c #343532",
+"l$	c #353532",
+"m$	c #212121",
+"n$	c #3C3C3C",
+"o$	c #686868",
+"p$	c #0F0F0F",
+"q$	c #060606",
+"r$	c #8D5651",
+"s$	c #9D3D36",
+"t$	c #9C453D",
+"u$	c #A35149",
+"v$	c #2C1F1E",
+"w$	c #1B1C1B",
+"x$	c #C6C6C6",
+"y$	c #BDB4A9",
+"z$	c #B0AAA5",
+"A$	c #979796",
+"B$	c #828282",
+"C$	c #626262",
+"D$	c #090909",
+"E$	c #684946",
+"F$	c #8A362E",
+"G$	c #97453F",
+"H$	c #9C5A54",
+"I$	c #261716",
+"J$	c #191C1A",
+"K$	c #C4C4C4",
+"L$	c #C3C3C3",
+"M$	c #5C5C5C",
+"N$	c #171717",
+"O$	c #392423",
+"P$	c #632E29",
+"Q$	c #96453D",
+"R$	c #88544F",
+"S$	c #291D1C",
+"T$	c #010000",
+"U$	c #121513",
+"V$	c #1C1C1C",
+"W$	c #7A7A7A",
+"X$	c #1A1B1B",
+"Y$	c #885A56",
+"Z$	c #753B36",
+"`$	c #804F4B",
+" %	c #904F49",
+".%	c #282020",
+"+%	c #151715",
+"@%	c #949790",
+"#%	c #626362",
+"$%	c #282C23",
+"%%	c #36412B",
+"&%	c #202E15",
+"*%	c #8B8E88",
+"=%	c #394131",
+"-%	c #A0A59A",
+";%	c #1E2020",
+">%	c #524442",
+",%	c #65403C",
+"'%	c #69514E",
+")%	c #875551",
+"!%	c #2A2424",
+"~%	c #070505",
+"{%	c #202120",
+"]%	c #B0B4AB",
+"^%	c #9DA694",
+"/%	c #778B65",
+"(%	c #6B8258",
+"_%	c #6E855A",
+":%	c #7F8E6F",
+"<%	c #778868",
+"[%	c #60774B",
+"}%	c #607254",
+"|%	c #3F5431",
+"1%	c #394B30",
+"2%	c #35422E",
+"3%	c #30402C",
+"4%	c #30412C",
+"5%	c #2B3A2B",
+"6%	c #2E3F2B",
+"7%	c #3C562A",
+"8%	c #425F2C",
+"9%	c #A2AB99",
+"0%	c #3D4A35",
+"a%	c #638052",
+"b%	c #3B4A30",
+"c%	c #21291A",
+"d%	c #241918",
+"e%	c #4B3533",
+"f%	c #6B4F4D",
+"g%	c #392D2A",
+"h%	c #180C0C",
+"i%	c #152215",
+"j%	c #161E15",
+"k%	c #1F291F",
+"l%	c #222C23",
+"m%	c #29352B",
+"n%	c #2B392D",
+"o%	c #2E3F2E",
+"p%	c #32452E",
+"q%	c #32422E",
+"r%	c #2D3B2E",
+"s%	c #2A392C",
+"t%	c #2D422E",
+"u%	c #2A362B",
+"v%	c #2C3C2C",
+"w%	c #2C3C2D",
+"x%	c #2C3B2D",
+"y%	c #2B3B2C",
+"z%	c #30402A",
+"A%	c #394F2B",
+"B%	c #45632E",
+"C%	c #415F2C",
+"D%	c #3F6232",
+"E%	c #406634",
+"F%	c #416330",
+"G%	c #3D592C",
+"H%	c #405F30",
+"I%	c #3F5F2E",
+"J%	c #42482C",
+"K%	c #191210",
+"L%	c #0F0908",
+"M%	c #080505",
+"N%	c #070B07",
+"O%	c #080D09",
+"P%	c #0B0F0B",
+"Q%	c #121A0F",
+"R%	c #1B2917",
+"S%	c #293B1F",
+"T%	c #394E2D",
+"U%	c #3B5930",
+"V%	c #406532",
+"W%	c #44652E",
+"X%	c #446630",
+"Y%	c #354F30",
+"Z%	c #29362B",
+"`%	c #2A362C",
+" &	c #2B3A2C",
+".&	c #2C3B2A",
+"+&	c #304129",
+"@&	c #303F2D",
+"#&	c #446C37",
+"$&	c #446934",
+"%&	c #446332",
+"&&	c #405F2D",
+"*&	c #416531",
+"=&	c #446531",
+"-&	c #3D6232",
+";&	c #3B562B",
+">&	c #374827",
+",&	c #3F2B25",
+"'&	c #31341F",
+")&	c #1D1C11",
+"!&	c #1E2312",
+"~&	c #253719",
+"{&	c #243518",
+"]&	c #233317",
+"^&	c #2C3D1C",
+"/&	c #375125",
+"(&	c #42602D",
+"_&	c #466630",
+":&	c #44632E",
+"<&	c #3C552D",
+"[&	c #293A28",
+"}&	c #2A3B27",
+"|&	c #314527",
+"1&	c #2C3D22",
+"2&	c #1E2A19",
+"3&	c #212E1B",
+"4&	c #253321",
+"5&	c #2A3A26",
+"6&	c #446933",
+"7&	c #426531",
+"8&	c #3C6032",
+"9&	c #34512B",
+"0&	c #354B23",
+"a&	c #27371A",
+"b&	c #2B3D1C",
+"c&	c #28391B",
+"d&	c #334921",
+"e&	c #395125",
+"f&	c #3D5829",
+"g&	c #3A5226",
+"h&	c #395129",
+"i&	c #3C592D",
+"j&	c #3F6332",
+"k&	c #42652E",
+"l&	c #42632E",
+"m&	c #3C592A",
+"n&	c #233217",
+"o&	c #0B0F09",
+"p&	c #26341E",
+"q&	c #24321B",
+"r&	c #2E4122",
+"s&	c #202C1B",
+"t&	c #27361E",
+"u&	c #233219",
+"v&	c #3B5527",
+"w&	c #3C5628",
+"x&	c #334922",
+"y&	c #36542B",
+"z&	c #334A22",
+"A&	c #30441F",
+"B&	c #374F25",
+"C&	c #324821",
+"D&	c #344A22",
+"E&	c #314520",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                .                                               ",
+"                                              + @ #                                             ",
+"                            $ % & * = $     - ; > , '                                           ",
+"                            ) ! ~ { ] ^   / ( _ : < [ }                                         ",
+"                            | 1 2 3 4 5 6 7 8 9 0 a b c d                                       ",
+"                            e f g h i j k l m n o p q r s t                                     ",
+"                            u v w x y z A m B C D E F G H I t                                   ",
+"                            J K L M N O P Q R S T U V W X Y Z `  .                              ",
+"                            ..+.@.#.$.%.&.*.=.-.;.>.,.'.).!.~.{.` ].                            ",
+"                            ^./.(._.:.<.[.}.R |.1.2.1.3.4.5.6.7.8.9.0.                          ",
+"                          a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.9.}                         ",
+"                        v.w.x.y.z.A.B.U C.D.E.F.l.G.H.I.J.m.K.L.M.N.O.P.Q.                      ",
+"                      R.S.T.U.V.W.g.C.}.h.X.Y.Z.`. +.+++H.@+#+$+%+&+*+=+-+`                     ",
+"                    ;+>+,+'+)+!+~+{+]+^+/+(+_+I.:+<+.+[+}+|+l.1+2+3+4+5+6+7+` 8+                ",
+"                9+0+a+b+)+'+c+d+e+f+e+g+Y.h+i+j+k+l+m+++.+n+`.|+o+p+q+r+s+t+u+v+w+              ",
+"              x+y+z+A+B+C+D+h.E+F+G+H+ +I+J+}+n+K+L+l.M+.+N+n.I.1.[+C.O+P+Q+R+S+T+U+            ",
+"          V+W+X+Y+Z+`+ @L..@C.+@@@#@i+$@i+j+Y.%@&@I.n.I.*@I.k+C.1.=@-@;@>@,@'@)@!@~@{@          ",
+"          ]@^@/@(@_@:@<@C [@}@|@n.1@.+2@}+3@H.4@K+%@K+5@n.6@7@n+-@8@J.9@2.0@a@b@c@d@e@f@        ",
+"            g@h@i@j@k@l@m@n@B.j+o@6@p@1@q@r@6@J+=@++L+s@ +t@L+u@I.G.$@1@v@w@x@y@z@A@9           ",
+"              B@4@C@$ D@E@F@.+}+G@I+H@i+i+I+H@H@I+_+i+I+I+_+}+H..+:+J.6@I@J@$ K@L@M@$           ",
+"                $ $ $ N@k.:+n.`.l.k+K+1.l.`.`.k+1.O@J.o+P@,.,.P@Q@R@S@T@U@V@$ $ $ $ $           ",
+"                    $ W@X@o@S@3@4@%@p@5@8@M+J+$@Y@C.n+r@C.o.N+o.L+J+r@i.W@J@$ $ $               ",
+"                      Z@X@3@1.1.K+J.-@`@9@#+ #E.o+.#+#@###$#%#&#+#*#=#v@J@-#$                   ",
+"                      ;#i.o.&@K+>#7@,#J.-@R@C..#'#Q@)#!#~#{#]#^#/#(#F+_#:#-#$                   ",
+"                      <#2.[#>#}#|#1#2#3#4#5#X@r@C.o.6#7#8#9#0#a#b#c#J+d#e#f#$                   ",
+"                      g#v@h#o+i#j#k#l#$ m#n#o#`@#+,.p#q#r#h#s#t#u#v#q@w#x#y#$                   ",
+"                      2.z#A#,#B#C#D#E#F#G#H#I#J#q@4@K#L#M#h#q@'#N#O#F+P#V@<#$                   ",
+"                      A#Q#T@-@R#S#T#U#V#W#X#Y#++h+h+K@Z#`#l+ $.$+$z#F.B#i#@$$                   ",
+"                      #$Z@@+o+$$%$&$*$=$-$$ ;$Q@>$,$'$)$!$~${$1.]$>.<+^$b#f#$                   ",
+"                      /$($A#o+_$:$<$[$}$|$$ 1$>$,$2$3$4$5$'#7@6$7$k.8$9$0$5#$                   ",
+"                      m.e#a$'#K@b$c$d$e$|$$ f$M+++g$h$i$j$3$k$l$m$n$o$-#p$5#                    ",
+"                      @+d#P#,.q$r$s$t$u$v$$ w$S@3@x$y$z$A$B$C$a$>.<#O#n$p$5#                    ",
+"                      A#>.d#q@D$E$F$G$H$I$$ J$3@o@K$L$2@*#q@=#J+1@C$M$o#N$f#                    ",
+"                      c#A#<#Y@D$O$P$Q$R$S$T$U$6@F+n+<+<+[+h+(+t@a$/$w@V$V@9$                    ",
+"                        W$n$=@X$Y$Z$`$ %.%X#+%6@8@8@j+r@1@N+ +@%h+Z.#%$%%%&%                    ",
+"                        *%=%-%;%>%,%'%)%!%~%{%]%^%/%(%_%:%<%[%}%|%1%2%3%4%5%6%7%8%              ",
+"                        9%0%a%b%c%d%e%f%g%h%i%j%k%l%m%n%o%p%q%r%s%t%u%v%w%x%y%z%A%              ",
+"                  B%C%D%E%F%G%H%I%J%I$K%L%M%N%O%P%Q%R%S%T%U%V%W%X%Y%Z%`% & &.&+&6%@&            ",
+"                #&$&%&&&*&=&*&-&;&>&,&'&)&!&~&{&]&^&/&(&_&_&:&<&[&}&|&1&2&3&4&5&                ",
+"                  6&7&8&9&0&a&b&c&d&e&f&g&h&i&j&k&k&l&m&n&  o&p&q&r&s&t&u&                      ",
+"                            v&w&x&        y&z&      A&x&B&C&D&E&                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                "};
+static char * desktop_xpm[] = {
+"48 48 554 2",
+"  	c None",
+". 	c #D6CCB9",
+"+ 	c #DED6C7",
+"@ 	c #BFB090",
+"# 	c #BFB095",
+"$ 	c #9A949A",
+"% 	c #BBB5BE",
+"& 	c #B5AFB9",
+"* 	c #AEA7B1",
+"= 	c #AAA3AE",
+"- 	c #A69FAA",
+"; 	c #A49CA7",
+"> 	c #A199A5",
+", 	c #A098A4",
+"' 	c #A097A4",
+") 	c #9F97A3",
+"! 	c #A098A5",
+"~ 	c #9C94A1",
+"{ 	c #908894",
+"] 	c #9A8F83",
+"^ 	c #776D5A",
+"/ 	c #E5E0D4",
+"( 	c #F0EDE7",
+"_ 	c #E3DDD1",
+": 	c #D9D0BD",
+"< 	c #D0C6B1",
+"[ 	c #746C60",
+"} 	c #C0B29D",
+"| 	c #F2EFE9",
+"1 	c #D0C5B0",
+"2 	c #BFAF90",
+"3 	c #B8A88C",
+"4 	c #38353A",
+"5 	c #4C464F",
+"6 	c #867B8B",
+"7 	c #827787",
+"8 	c #817687",
+"9 	c #7E7383",
+"0 	c #7C7282",
+"a 	c #7A6E80",
+"b 	c #766A7C",
+"c 	c #776B7D",
+"d 	c #736879",
+"e 	c #746879",
+"f 	c #76697C",
+"g 	c #74687A",
+"h 	c #706376",
+"i 	c #6E6174",
+"j 	c #6A5D71",
+"k 	c #66596D",
+"l 	c #5D4F64",
+"m 	c #44384B",
+"n 	c #3F363B",
+"o 	c #B6B3AA",
+"p 	c #F8F8F6",
+"q 	c #ECE8E0",
+"r 	c #CFC3AB",
+"s 	c #C4B699",
+"t 	c #564F41",
+"u 	c #5A4F4B",
+"v 	c #BBAF97",
+"w 	c #FBFAF8",
+"x 	c #C0B192",
+"y 	c #BFAF8F",
+"z 	c #9F9177",
+"A 	c #0F0C10",
+"B 	c #281F2B",
+"C 	c #514259",
+"D 	c #504058",
+"E 	c #52425A",
+"F 	c #4C3C54",
+"G 	c #4B3B53",
+"H 	c #483950",
+"I 	c #4A3B52",
+"J 	c #46374D",
+"K 	c #48384F",
+"L 	c #4A3A52",
+"M 	c #45364C",
+"N 	c #403247",
+"O 	c #43354B",
+"P 	c #221B26",
+"Q 	c #433D3A",
+"R 	c #F6F4F0",
+"S 	c #D1C6B0",
+"T 	c #BEAE8F",
+"U 	c #4A4338",
+"V 	c #443D39",
+"W 	c #CEC2AC",
+"X 	c #F9F7F5",
+"Y 	c #675D52",
+"Z 	c #0A070B",
+"` 	c #2B212F",
+" .	c #493A51",
+"..	c #6A6070",
+"+.	c #706575",
+"@.	c #746979",
+"#.	c #9A939D",
+"$.	c #B4AFB7",
+"%.	c #BBB5BD",
+"&.	c #BDB7BF",
+"*.	c #E6E4E7",
+"=.	c #FDFDFD",
+"-.	c #000000",
+";.	c #281F2D",
+">.	c #221A25",
+",.	c #201A21",
+"'.	c #E8E3DB",
+").	c #C2B396",
+"!.	c #3D392E",
+"~.	c #363129",
+"{.	c #E1D9CB",
+"].	c #E9E4DB",
+"^.	c #312A2D",
+"/.	c #0B080C",
+"(.	c #372B3D",
+"_.	c #C2BDC5",
+":.	c #B8B8B8",
+"<.	c #B1B1B1",
+"[.	c #C8C8C8",
+"}.	c #DBDBDB",
+"|.	c #E6E6E6",
+"1.	c #EDEDED",
+"2.	c #F4F4F4",
+"3.	c #F7F7F7",
+"4.	c #FBFBFB",
+"5.	c #FCFCFC",
+"6.	c #FEFEFE",
+"7.	c #040305",
+"8.	c #2A212F",
+"9.	c #252023",
+"0.	c #BBB098",
+"a.	c #4A4438",
+"b.	c #27241D",
+"c.	c #D7D2C8",
+"d.	c #363237",
+"e.	c #181219",
+"f.	c #5C4F64",
+"g.	c #EAE8EB",
+"h.	c #FFFFFF",
+"i.	c #A7A7A7",
+"j.	c #989898",
+"k.	c #BEBEBE",
+"l.	c #DCDCDC",
+"m.	c #E5E5E5",
+"n.	c #EAEAEA",
+"o.	c #F5F5F5",
+"p.	c #F8F8F8",
+"q.	c #555555",
+"r.	c #020202",
+"s.	c #322835",
+"t.	c #5C524B",
+"u.	c #36312A",
+"v.	c #12100E",
+"w.	c #656263",
+"x.	c #413945",
+"y.	c #423449",
+"z.	c #6D6D6D",
+"A.	c #707070",
+"B.	c #BCBCBC",
+"C.	c #D3D3D3",
+"D.	c #9B9B9B",
+"E.	c #6F6F6F",
+"F.	c #797979",
+"G.	c #929292",
+"H.	c #D1D1D1",
+"I.	c #3D333F",
+"J.	c #120F15",
+"K.	c #C1BDC4",
+"L.	c #56475E",
+"M.	c #44364B",
+"N.	c #3F3246",
+"O.	c #D4D4D4",
+"P.	c #8F8F8F",
+"Q.	c #5D5D5D",
+"R.	c #343434",
+"S.	c #484848",
+"T.	c #5F5F5F",
+"U.	c #4E4E4E",
+"V.	c #373737",
+"W.	c #454545",
+"X.	c #A4A4A4",
+"Y.	c #DFDFDF",
+"Z.	c #B6B6B6",
+"`.	c #493951",
+" +	c #1C1620",
+".+	c #201923",
+"++	c #AEA7B0",
+"@+	c #B6B1B9",
+"#+	c #43354A",
+"$+	c #858585",
+"%+	c #737373",
+"&+	c #787878",
+"*+	c #8D8D8D",
+"=+	c #959595",
+"-+	c #ADADAD",
+";+	c #BFBFBF",
+">+	c #E8E8E8",
+",+	c #F0F0F0",
+"'+	c #F9F9F9",
+")+	c #717171",
+"!+	c #3A2E40",
+"~+	c #28212D",
+"{+	c #BCB6BE",
+"]+	c #A79FAA",
+"^+	c #C3C3C3",
+"/+	c #ACACAC",
+"(+	c #8B8B8B",
+"_+	c #5E5E5E",
+":+	c #808080",
+"<+	c #AAAAAA",
+"[+	c #332839",
+"}+	c #3D3044",
+"|+	c #362B3C",
+"1+	c #342939",
+"2+	c #C0BAC3",
+"3+	c #8F8594",
+"4+	c #CECECE",
+"5+	c #BBBBBB",
+"6+	c #949494",
+"7+	c #595959",
+"8+	c #282828",
+"9+	c #575757",
+"0+	c #6A6A6A",
+"a+	c #EFEFEF",
+"b+	c #E0E0E0",
+"c+	c #CFCFCF",
+"d+	c #D8D8D8",
+"e+	c #281F2C",
+"f+	c #35293B",
+"g+	c #322737",
+"h+	c #C5BFC8",
+"i+	c #7C7081",
+"j+	c #E1E1E1",
+"k+	c #4A4A4A",
+"l+	c #AEAEAE",
+"m+	c #E9E9E9",
+"n+	c #FAFAFA",
+"o+	c #C6C6C6",
+"p+	c #171219",
+"q+	c #C1995E",
+"r+	c #D5A960",
+"s+	c #735B57",
+"t+	c #42344A",
+"u+	c #312636",
+"v+	c #C5C0C7",
+"w+	c #685B6E",
+"x+	c #46374E",
+"y+	c #EBEBEB",
+"z+	c #EEEEEE",
+"A+	c #6C6C6C",
+"B+	c #C4C4C4",
+"C+	c #AD8947",
+"D+	c #FECA65",
+"E+	c #BE8134",
+"F+	c #5A424A",
+"G+	c #312736",
+"H+	c #BEB9C2",
+"I+	c #47384E",
+"J+	c #C9C9C9",
+"K+	c #7E7E7E",
+"L+	c #5C5C5C",
+"M+	c #3B3B3B",
+"N+	c #4C4C4C",
+"O+	c #A9A9A9",
+"P+	c #9F9F9F",
+"Q+	c #9D9D9D",
+"R+	c #FEF9EE",
+"S+	c #C59C4E",
+"T+	c #EABA62",
+"U+	c #CC7300",
+"V+	c #84532E",
+"W+	c #44354B",
+"X+	c #413347",
+"Y+	c #47384F",
+"Z+	c #332939",
+"`+	c #B4AEB7",
+" @	c #AFA8B2",
+".@	c #F3F3F3",
+"+@	c #B2B2B2",
+"@@	c #CDCDCD",
+"#@	c #ECECEC",
+"$@	c #FED076",
+"%@	c #E3B45A",
+"&@	c #C37413",
+"*@	c #AD6510",
+"=@	c #392C3E",
+"-@	c #392D40",
+";@	c #3E3044",
+">@	c #47374F",
+",@	c #B4ADB7",
+"'@	c #A39BA7",
+")@	c #493950",
+"!@	c #FEF3DD",
+"~@	c #D2A456",
+"{@	c #652A0C",
+"]@	c #2C2231",
+"^@	c #2F2535",
+"/@	c #2F2534",
+"(@	c #322838",
+"_@	c #332A37",
+":@	c #352938",
+"<@	c #B1ABB4",
+"[@	c #756C64",
+"}@	c #3A2F3D",
+"|@	c #3F3145",
+"1@	c #444444",
+"2@	c #898989",
+"3@	c #505050",
+"4@	c #3E3E3E",
+"5@	c #C3B290",
+"6@	c #F2C174",
+"7@	c #B06006",
+"8@	c #602105",
+"9@	c #662100",
+"0@	c #2C2230",
+"a@	c #241C28",
+"b@	c #231B26",
+"c@	c #1D1720",
+"d@	c #362B3D",
+"e@	c #2D2332",
+"f@	c #322B30",
+"g@	c #6D605B",
+"h@	c #2E2432",
+"i@	c #B6B0B6",
+"j@	c #C2B7A7",
+"k@	c #63574D",
+"l@	c #3E3245",
+"m@	c #D5D5D5",
+"n@	c #C7B694",
+"o@	c #E6AC5A",
+"p@	c #7E3E02",
+"q@	c #3A1E1B",
+"r@	c #211A25",
+"s@	c #18131B",
+"t@	c #231B27",
+"u@	c #171118",
+"v@	c #3B3333",
+"w@	c #988A77",
+"x@	c #8E8172",
+"y@	c #2B2230",
+"z@	c #C0B6AF",
+"A@	c #F3F0EA",
+"B@	c #B4A489",
+"C@	c #4A413F",
+"D@	c #19141B",
+"E@	c #413348",
+"F@	c #FEDB98",
+"G@	c #FACB71",
+"H@	c #DE9E42",
+"I@	c #612700",
+"J@	c #5E2004",
+"K@	c #2A1B21",
+"L@	c #1B151E",
+"M@	c #1C151E",
+"N@	c #0E0A0E",
+"O@	c #6E6258",
+"P@	c #CDC3B2",
+"Q@	c #D5CCC1",
+"R@	c #9E907B",
+"S@	c #28202D",
+"T@	c #E2DDD5",
+"U@	c #F3F1EE",
+"V@	c #D3C8B3",
+"W@	c #C9BCA4",
+"X@	c #2A2327",
+"Y@	c #120D15",
+"Z@	c #33283A",
+"`@	c #FDCE73",
+" #	c #D58824",
+".#	c #BB6C10",
+"+#	c #622304",
+"@#	c #441600",
+"##	c #1C161F",
+"$#	c #18121A",
+"%#	c #120E14",
+"&#	c #141016",
+"*#	c #100C10",
+"=#	c #998D78",
+"-#	c #E9E5E0",
+";#	c #EAE6E0",
+">#	c #BDAE90",
+",#	c #A4957F",
+"'#	c #29202D",
+")#	c #ABA4AD",
+"!#	c #F1EEE8",
+"~#	c #EFEBE5",
+"{#	c #DDD7C9",
+"]#	c #DBD3C3",
+"^#	c #BEB197",
+"/#	c #302A2B",
+"(#	c #09060A",
+"_#	c #2A212E",
+":#	c #837988",
+"<#	c #807C81",
+"[#	c #B3ADA2",
+"}#	c #EBC274",
+"|#	c #7C3D00",
+"1#	c #220B00",
+"2#	c #100D12",
+"3#	c #130F15",
+"4#	c #130F16",
+"5#	c #100C12",
+"6#	c #0A080A",
+"7#	c #9D9180",
+"8#	c #F3F2F0",
+"9#	c #F2EFEA",
+"0#	c #CBBFA7",
+"a#	c #BAAA8C",
+"b#	c #A3947F",
+"c#	c #ACA4A6",
+"d#	c #F9F8F6",
+"e#	c #E3DDCF",
+"f#	c #CEC3B0",
+"g#	c #BEB099",
+"h#	c #C4B7A0",
+"i#	c #B2A388",
+"j#	c #39342F",
+"k#	c #0A090C",
+"l#	c #251D29",
+"m#	c #17121A",
+"n#	c #1B160B",
+"o#	c #E1B359",
+"p#	c #AF7C2D",
+"q#	c #692900",
+"r#	c #5A1D00",
+"s#	c #110806",
+"t#	c #0C090D",
+"u#	c #0F0C12",
+"v#	c #181414",
+"w#	c #A59D91",
+"x#	c #F2F0EF",
+"y#	c #EDE8E1",
+"z#	c #E3DDD0",
+"A#	c #C0B19A",
+"B#	c #BCAC8D",
+"C#	c #988878",
+"D#	c #2C2331",
+"E#	c #B6ABA2",
+"F#	c #F8F7F4",
+"G#	c #CFC4AD",
+"H#	c #D2C8B3",
+"I#	c #C7BAA2",
+"J#	c #C1B396",
+"K#	c #AB9C80",
+"L#	c #AC9D82",
+"M#	c #352E2D",
+"N#	c #1A151E",
+"O#	c #322738",
+"P#	c #413349",
+"Q#	c #0A080B",
+"R#	c #09070A",
+"S#	c #403220",
+"T#	c #E3B45C",
+"U#	c #B47929",
+"V#	c #AD5D02",
+"W#	c #642102",
+"X#	c #4C1C09",
+"Y#	c #100C11",
+"Z#	c #080609",
+"`#	c #0B090D",
+" $	c #151017",
+".$	c #262120",
+"+$	c #A49987",
+"@$	c #D4CDC1",
+"#$	c #DDD6C9",
+"$$	c #E4DED4",
+"%$	c #D4CCC0",
+"&$	c #CABFAC",
+"*$	c #BDAF96",
+"=$	c #827469",
+"-$	c #584D4B",
+";$	c #2D2330",
+">$	c #B0A28A",
+",$	c #B3B0AC",
+"'$	c #565146",
+")$	c #464035",
+"!$	c #4A4139",
+"~$	c #3C352F",
+"{$	c #302927",
+"]$	c #413936",
+"^$	c #161018",
+"/$	c #251C28",
+"($	c #1E1721",
+"_$	c #271F2B",
+":$	c #6E583E",
+"<$	c #E7B75E",
+"[$	c #BF710F",
+"}$	c #914C06",
+"|$	c #2A110A",
+"1$	c #050406",
+"2$	c #130E14",
+"3$	c #151018",
+"4$	c #1C161D",
+"5$	c #4E4445",
+"6$	c #494044",
+"7$	c #8C7E6E",
+"8$	c #7C6E66",
+"9$	c #766962",
+"0$	c #817368",
+"a$	c #897B6D",
+"b$	c #6B5E5A",
+"c$	c #3C3239",
+"d$	c #1E1720",
+"e$	c #201924",
+"f$	c #736B65",
+"g$	c #544E4A",
+"h$	c #292325",
+"i$	c #110E13",
+"j$	c #17131A",
+"k$	c #1B161F",
+"l$	c #211A23",
+"m$	c #383037",
+"n$	c #241D29",
+"o$	c #241E29",
+"p$	c #261F2B",
+"q$	c #221B25",
+"r$	c #928156",
+"s$	c #D5A556",
+"t$	c #6E2E06",
+"u$	c #5C1E01",
+"v$	c #0F0705",
+"w$	c #030304",
+"x$	c #030203",
+"y$	c #050405",
+"z$	c #1D1721",
+"A$	c #211B25",
+"B$	c #251E2A",
+"C$	c #161118",
+"D$	c #D5D68D",
+"E$	c #E2BB5D",
+"F$	c #C06700",
+"G$	c #692100",
+"H$	c #4B1800",
+"I$	c #BDCC99",
+"J$	c #F2ECC5",
+"K$	c #B2A96D",
+"L$	c #965A05",
+"M$	c #A35502",
+"N$	c #270C00",
+"O$	c #EBE7C0",
+"P$	c #CDC398",
+"Q$	c #1E1D0F",
+"R$	c #0C0900",
+"S$	c #512A04",
+"T$	c #5E1E00",
+"U$	c #0D0400",
+"V$	c #9B9D78",
+"W$	c #938C6A",
+"X$	c #221E17",
+"Y$	c #121001",
+"Z$	c #391900",
+"`$	c #1B1B14",
+" %	c #060505",
+".%	c #090700",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                . + @ @ @ # $ % & * = - ; > , ' > > ) ' > ! > ! ~ { ] ^ / ( _ : < [             ",
+"              } | 1 2 2 3 4 5 6 6 7 8 8 9 0 a b c d e f g h i j k l m n o p q r s t u           ",
+"              v w x y z A B C D E F G H I F F F J K G L M N F F F F F O P Q R S T U V           ",
+"              W X y Y Z ` F F F F L  .F ..+.@.#.$.%.&.*.=.-.;.F F F F F G >.,.'.).!.~.          ",
+"              {.].^./.(.F F F F H _.:.<.[.}.|.1.2.3.4.5.6.-.7.F F F F F F F 8.9.0.a.b.          ",
+"              c.d.e.O F F F H f.g.h.i.j.k.l.m.n.o.p.1.=.6.q.r.F F F F F F F L s.t.u.v.          ",
+"              w.x.F F L y.M 6 h.h.h.z.A.B.C.D.E.F.G.H.=.h.q.-.F F F F F F L I F I.A J.          ",
+"              K.L.M.N.N K F O.P.Q.R.R.S.T.U.V.W.X.Y.Z.h.h.q.-.F F F F F `.F F F F  +.+          ",
+"            ++@+#+K G F F F $+%+&+*+=+-+;+>+,+'+5.6.h.h.h.)+-.N F F F I G F F F F !+~+          ",
+"            {+]+F F F F F F -+<.Z.^+^+/+(+_+S.A.=+:+,+h.h.<+-.[+F F G L F F F F F }+|+1+        ",
+"            2+3+F F F F F F 4+<+5+6+7+8+9+i.0+a+b+c+d+h.h.<+-.e+F I  .F F F F F F y.f+g+        ",
+"            h+i+F F F F F G j+k.k+Q.l+m+n+5.Z.p.h.h.h.h.h.o+-.p+q+r+s+F F F F F G t+[+u+        ",
+"            v+w+F F F F  .x+y+>+z+2.o.p.5.=.5.-+U.A+B+h.h.h.-.C+D+D+E+F+F G G `.`.x+[+G+        ",
+"            H+C F F F H I+F ,+J+E.K+L+M+)+A.N+&+O+P+Q+h.h.R+S+D+T+E+U+V+H W+X+x+Y+x+|+Z+        ",
+"          `+ @F F F `.`.F F .@b+n.c++@@@4.h.h.h.h.#@h.h.R+$@D+%@&@U+U+*@=@f+-@;@>@J g+1+        ",
+"          ,@'@F F )@G F F F '+n+n+4.=.=.h.X.h.h.h.A.h.!@$@D+~@U+U+U+U+{@]@^@/@(@!+M |+_@:@      ",
+"          <@[@}@|@F F F F F n+n+|.1@o+O.2@3@:+A+A+4@5@D+D+6@U+U+U+7@8@9@0@a@b@c@d@e@f@g@h@      ",
+"          i@j@k@b@l@F F F F 5.=.4.%+m@5.p.b+h.h.h.n@D+D+o@U+U+U+p@9@9@q@r@c@s@t@u@v@w@x@y@      ",
+"          z@A@B@C@D@E@F F F =.6.6.6.h.h.h.h.h.h.F@D+G@H@U+U+U+I@9@J@K@c@L@D@M@N@O@P@Q@R@S@      ",
+"          T@U@V@W@X@Y@Z@F F 6.6.6.h.h.h.h.h.h.F@D+`@ #U+U+.#+#9@@###s@$#%#&#*#=#-#;#>#,#'#      ",
+"        )#!#~#{#]#^#/#(#_#G :#<#<+<+<+<+<+[#}#D+~@U+U+U+|#9@9@1#2#3#&#4#5#6#7#8#9#0#a#b#y@      ",
+"        c#d#e#f#g#h#i#j#k#l#G m#-.-.-.-.n#o#D+p#U+U+U+q#9@r#s#t#t#5#%#u#v#w#x#y#z#A#B#C#D#      ",
+"        E#F#G#H#I#J#K#L#M#N#O#P#m#Q#R#S#T#D+U#U+U+V#W#9@X#Y#R#Z#`# $Y#.$+$@$#$$$%$&$*$=$-$;$    ",
+"        >$,$'$a.)$!$~${$]$^$/$($t@_$:$D+<$[$U+U+}$9@9@|$Z#1$1$Q#2$3$4$5$6$7$8$9$0$a$b$c$d$e$    ",
+"        f$g$h$i$j$N#k$l$m$n$o$p$q$r$D+s$[$U+U+t$9@u$v$w$x$y$R#2#s@z$A$n$B$p$p$p$p$p$p$r@m#C$    ",
+"                                  D$E$U+U+F$G$9@H$-.-.-.-.-.                                    ",
+"                                I$J$K$L$M$9@9@N$-.-.-.-.-.                                      ",
+"                                O$P$Q$R$S$T$U$-.-.-.-.                                          ",
+"                              V$W$X$-.Y$Z$-.-.-.-.                                              ",
+"                              `$ %.%    -.-.-.                                                  ",
+"                                      -.-.                                                      ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                "};
+
+static char * documents_xpm[] = {
+"48 48 317 2",
+"  	c None",
+". 	c #000000",
+"+ 	c #978F7C",
+"@ 	c #8F8775",
+"# 	c #605D52",
+"$ 	c #070706",
+"% 	c #24231F",
+"& 	c #33312C",
+"* 	c #3B3932",
+"= 	c #3A372F",
+"- 	c #676154",
+"; 	c #AE8E53",
+"> 	c #DDAF5A",
+", 	c #F3B94F",
+"' 	c #948C79",
+") 	c #24221E",
+"! 	c #7E7767",
+"~ 	c #857E6D",
+"{ 	c #524D42",
+"] 	c #3E3B34",
+"^ 	c #2F2D29",
+"/ 	c #201F1D",
+"( 	c #191816",
+"_ 	c #282622",
+": 	c #858175",
+"< 	c #A59E8D",
+"[ 	c #99927F",
+"} 	c #B18F52",
+"| 	c #E4B04F",
+"1 	c #B48B3A",
+"2 	c #6F5224",
+"3 	c #DEC277",
+"4 	c #CAAF6F",
+"5 	c #90825F",
+"6 	c #A4A093",
+"7 	c #C8C4B9",
+"8 	c #D0CDC4",
+"9 	c #C5C0B6",
+"0 	c #B2AC9E",
+"a 	c #A7A090",
+"b 	c #7E7867",
+"c 	c #6D6758",
+"d 	c #22201C",
+"e 	c #151411",
+"f 	c #181714",
+"g 	c #232220",
+"h 	c #343432",
+"i 	c #43423F",
+"j 	c #3D3C38",
+"k 	c #524E47",
+"l 	c #716B5C",
+"m 	c #928A78",
+"n 	c #8D8472",
+"o 	c #706557",
+"p 	c #50473D",
+"q 	c #29221E",
+"r 	c #201A17",
+"s 	c #4D3C1F",
+"t 	c #5F4922",
+"u 	c #604A22",
+"v 	c #E9E089",
+"w 	c #FDFAA2",
+"x 	c #FAF5A0",
+"y 	c #D3C28F",
+"z 	c #858481",
+"A 	c #C5C2BC",
+"B 	c #B6B1A5",
+"C 	c #8E8674",
+"D 	c #645F54",
+"E 	c #57544D",
+"F 	c #37352F",
+"G 	c #2C2923",
+"H 	c #2C2A24",
+"I 	c #32302B",
+"J 	c #5D5A54",
+"K 	c #737069",
+"L 	c #A7A59D",
+"M 	c #BBB9B1",
+"N 	c #A5A297",
+"O 	c #A29D93",
+"P 	c #857F6E",
+"Q 	c #8A8371",
+"R 	c #918977",
+"S 	c #857B6A",
+"T 	c #5B5146",
+"U 	c #342D27",
+"V 	c #241D17",
+"W 	c #4E3D1F",
+"X 	c #E5D683",
+"Y 	c #E8E392",
+"Z 	c #BFBD7C",
+"` 	c #312C28",
+" .	c #4E4640",
+"..	c #605750",
+"+.	c #413B34",
+"@.	c #413C36",
+"#.	c #514B42",
+"$.	c #B6B3AD",
+"%.	c #B9B5AF",
+"&.	c #C0BDB4",
+"*.	c #C1BDB2",
+"=.	c #BAB5A8",
+"-.	c #B5AFA2",
+";.	c #B0A99B",
+">.	c #A29B8A",
+",.	c #958C78",
+"'.	c #887E6D",
+").	c #675C50",
+"!.	c #3C342D",
+"~.	c #221B17",
+"{.	c #4C3B1F",
+"].	c #D0B470",
+"^.	c #B8A263",
+"/.	c #332E29",
+"(.	c #3B3530",
+"_.	c #5C524B",
+":.	c #585048",
+"<.	c #4B433E",
+"[.	c #847B75",
+"}.	c #695E56",
+"|.	c #877F78",
+"1.	c #77736D",
+"2.	c #EBE6AB",
+"3.	c #EEECCF",
+"4.	c #DEDDB0",
+"5.	c #C1BE70",
+"6.	c #9C8653",
+"7.	c #9E8B5B",
+"8.	c #1F1916",
+"9.	c #1E1815",
+"0.	c #1E1816",
+"a.	c #948259",
+"b.	c #3E3731",
+"c.	c #3E3732",
+"d.	c #534A44",
+"e.	c #625850",
+"f.	c #574E47",
+"g.	c #413A34",
+"h.	c #99918B",
+"i.	c #463E39",
+"j.	c #867E56",
+"k.	c #E3E2AB",
+"l.	c #C8C7AB",
+"m.	c #938E5B",
+"n.	c #615233",
+"o.	c #3E3522",
+"p.	c #181311",
+"q.	c #1C1714",
+"r.	c #504842",
+"s.	c #423B35",
+"t.	c #938B85",
+"u.	c #332D28",
+"v.	c #B6A267",
+"w.	c #857F4E",
+"x.	c #5F5134",
+"y.	c #352D1C",
+"z.	c #191412",
+"A.	c #5B514A",
+"B.	c #504741",
+"C.	c #645951",
+"D.	c #564D46",
+"E.	c #2F2926",
+"F.	c #3D352B",
+"G.	c #8D7E49",
+"H.	c #493D27",
+"I.	c #161210",
+"J.	c #5D534C",
+"K.	c #5E544D",
+"L.	c #635851",
+"M.	c #594F49",
+"N.	c #37302D",
+"O.	c #99928C",
+"P.	c #3A3430",
+"Q.	c #433924",
+"R.	c #251F17",
+"S.	c #171311",
+"T.	c #1A1512",
+"U.	c #61564F",
+"V.	c #5A514A",
+"W.	c #332D29",
+"X.	c #9E9792",
+"Y.	c #1A1513",
+"Z.	c #514943",
+"`.	c #5A504A",
+" +	c #2C2724",
+".+	c #9D9691",
+"++	c #332D2A",
+"@+	c #3B3531",
+"#+	c #645A52",
+"$+	c #5F554E",
+"%+	c #352F2C",
+"&+	c #A29C97",
+"*+	c #5F554D",
+"=+	c #655A52",
+"-+	c #34302B",
+";+	c #ABA5A1",
+">+	c #2E2926",
+",+	c #665B53",
+"'+	c #342E2A",
+")+	c #A59E9A",
+"!+	c #0C0908",
+"~+	c #595049",
+"{+	c #595048",
+"]+	c #282421",
+"^+	c #9F9893",
+"/+	c #624C27",
+"(+	c #231A0C",
+"_+	c #47403A",
+":+	c #514842",
+"<+	c #27221F",
+"[+	c #AAA39F",
+"}+	c #382C1D",
+"|+	c #E3AF4D",
+"1+	c #372A12",
+"2+	c #48403B",
+"3+	c #4D443F",
+"4+	c #554C46",
+"5+	c #231F1C",
+"6+	c #AFA9A5",
+"7+	c #403833",
+"8+	c #B3893E",
+"9+	c #CE9C43",
+"0+	c #2B200E",
+"a+	c #3A342F",
+"b+	c #48413B",
+"c+	c #5A5049",
+"d+	c #23201D",
+"e+	c #AAA4A0",
+"f+	c #61574F",
+"g+	c #755928",
+"h+	c #423214",
+"i+	c #140F06",
+"j+	c #18130C",
+"k+	c #39332F",
+"l+	c #36312C",
+"m+	c #4A423C",
+"n+	c #37312D",
+"o+	c #9E9995",
+"p+	c #5D544C",
+"q+	c #4F4741",
+"r+	c #665C54",
+"s+	c #040303",
+"t+	c #0B0904",
+"u+	c #71613A",
+"v+	c #242018",
+"w+	c #413A35",
+"x+	c #524A43",
+"y+	c #2F2A27",
+"z+	c #999490",
+"A+	c #120F0D",
+"B+	c #030302",
+"C+	c #D1CD7A",
+"D+	c #454025",
+"E+	c #1C1916",
+"F+	c #4A433D",
+"G+	c #86807E",
+"H+	c #60564E",
+"I+	c #3F3732",
+"J+	c #1D1714",
+"K+	c #D6CD7A",
+"L+	c #A69557",
+"M+	c #2A251D",
+"N+	c #352F2B",
+"O+	c #403934",
+"P+	c #84807D",
+"Q+	c #625750",
+"R+	c #3D3531",
+"S+	c #1B1613",
+"T+	c #38311C",
+"U+	c #9B8652",
+"V+	c #84724C",
+"W+	c #292421",
+"X+	c #3C3631",
+"Y+	c #7F7A76",
+"Z+	c #322C28",
+"`+	c #181411",
+" @	c #1C1614",
+".@	c #0F0C0B",
+"+@	c #070604",
+"@@	c #2D281D",
+"#@	c #1D1A17",
+"$@	c #302B28",
+"%@	c #696561",
+"&@	c #544B45",
+"*@	c #433C37",
+"=@	c #5E5240",
+"-@	c #938151",
+";@	c #2F271D",
+">@	c #1D1815",
+",@	c #1C1917",
+"'@	c #36302C",
+")@	c #726D6B",
+"!@	c #554C45",
+"~@	c #6F6349",
+"{@	c #E4D985",
+"]@	c #B9AF67",
+"^@	c #6A5D39",
+"/@	c #31291C",
+"(@	c #221C16",
+"_@	c #1D1B1A",
+":@	c #49423B",
+"<@	c #C2B570",
+"[@	c #F7F49D",
+"}@	c #C4BE71",
+"|@	c #635333",
+"1@	c #493E24",
+"2@	c #1C1710",
+"3@	c #49413B",
+"4@	c #4A4131",
+"5@	c #B6A864",
+"6@	c #C3AC63",
+"7@	c #78673D",
+"8@	c #252012",
+"9@	c #030202",
+"0@	c #2A2419",
+"a@	c #342D1B",
+"b@	c #17130C",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                    .                                           ",
+"                                          . . . . . . . .                                       ",
+"                                        . . . . . . . . .                                       ",
+"                                        . .             .                                       ",
+"                                      . .         + @ # $ % & * = - +   ; > ,                   ",
+"                                  + ' ) ) ! ~ { ] ^ / ( _ : < [ + + + + } | 1 2                 ",
+"          3 4 5 6 7 8 9 0 a + + + b c d e f g h i j k l m + + n o p q r r s t u                 ",
+"      v w x y z A B C D E F G H I J K L M N O P Q R n S T U r r r r r r r V W t                 ",
+"      X Y Z `  ...+.@.#.$.%.&.*.=.-.;.>.+ ,.'.).!.r r r r r r r r r r r r r ~.{.                ",
+"      ].^./.(._.:.<.[.}.|.1.2.3.4.5.6.7.8.9.0.r r r r r r r r r r r r r r r r r                 ",
+"      a.b.c.d.e.f.g.h.}.}.i.j.k.l.m.n.o.p.q.r r r r r r r r r r r r r r r r r                   ",
+"        r.<._.}.f.s.t.}.}.}.u.v.w.x.y.z.p.8.r r r r r r r r r r r r r r r r r                   ",
+"        A.B.C.}.D.E.t.}.}.}.d.F.G.H.z.I.q.r r r r r r r r r r r r r r r r r r                   ",
+"        J.K.L.}.M.N.O.}.}.}.}.P.Q.R.S.T.r r r r r r r r r r r r r r r r r r r                   ",
+"        A.U.}.}.V.W.X.}.}.}.}.A.Y.T.I.r r r r r r r r r r r r r r r r r r r r                   ",
+"        Z._.e.}.`. +.+}.}.}.}._.r 9.q.r r r r r r r r r r r r r r r r r r r r                   ",
+"        i.U.U.}._.++O.}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r r r                   ",
+"        @+#+$+}._.%+&+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r r r                   ",
+"         +*+$+=+D.-+;+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r r 9.                  ",
+"        >+K._.,+V.'+)+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r 0.!+                  ",
+"          ~+~+C.{+]+^+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r r /+(+                  ",
+"          _+:+A.`.<+[+}.}.}.}._.r r r r r r r r r r r r r r r r r r r r }+|+1+                  ",
+"        . 2+3+4+_.5+6+}.}.}.}.7+r r r r r r r r r r r r r r r r r r r r 8+9+0+                  ",
+"          a+:+b+c+d+e+}.}.f+~+7+r r r r r r r r r r r r r r r r r r r V g+h+i+. . .             ",
+"        . j+k+l+m+n+o+}.p+q+r+7+r r r r r r r r r r r r r r r r r r p.s+. t+. . . . . . .       ",
+"          u+v+w+x+y+z+K.d._.d.7+r r r r r r r r r r r r r r r r A+B+. . . . . . . . . . . .     ",
+"          C+D+E+F+W.G+,+H+f.f+I+J+8.r r r r r r r r r r r r A+B+. . . . . . . . . . . . .       ",
+"        . K+L+M+N+O+P+L._.A.Q+R+q.S+9.r r r r r r r r r A+B+. . . . . . . . . . . . .           ",
+"        . T+U+V+W+X+Y+#+f.A.q+Z+z.`+Y. @r r r r r q..@B+. . . . . . . . . . . . .               ",
+"          . +@@@#@$@%@H+&@*@=@-@;@I.z.Y.>@r r q..@. . . . . . . . . . . . . .                   ",
+"              . ,@'@)@!@*@~@{@]@^@/@(@q.r q..@. . . . . . . . . . . . . .                       ",
+"                  . _@a+:@<@[@}@|@1@2@I..@. . . . . . . . . . . . .                             ",
+"                        3@4@5@6@7@8@9@. . . . . . . . . . . . .                                 ",
+"                            0@a@b@. . . . . . . . . .                                           ",
+"                                . . . .                                                         ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                ",
+"                                                                                                "};
+
+
+#define DIR_LIST_WIDTH   180
+#define DIR_LIST_HEIGHT  180
+#define FILE_LIST_WIDTH  180
+#define FILE_LIST_HEIGHT 180
+
+/* The Hurd doesn't define either PATH_MAX or MAXPATHLEN, so we put this
+ * in here, since the rest of the code in the file does require some
+ * fixed maximum.
+ */
+#ifndef MAXPATHLEN
+#  ifdef PATH_MAX
+#    define MAXPATHLEN PATH_MAX
+#  else
+#    define MAXPATHLEN 2048
+#  endif
+#endif
+
+/* I've put this here so it doesn't get confused with the 
+ * file completion interface */
+typedef struct _HistoryCallbackArg HistoryCallbackArg;
+
+struct _HistoryCallbackArg
+{
+  gchar *directory;
+  GtkWidget *menu_item;
+};
+
+
+typedef struct _CompletionState    CompletionState;
+typedef struct _CompletionDir      CompletionDir;
+typedef struct _CompletionDirSent  CompletionDirSent;
+typedef struct _CompletionDirEntry CompletionDirEntry;
+typedef struct _CompletionUserDir  CompletionUserDir;
+typedef struct _PossibleCompletion PossibleCompletion;
+
+/* Non-external file completion decls and structures */
+
+/* A contant telling PRCS how many directories to cache.  Its actually
+ * kept in a list, so the geometry isn't important. */
+#define CMPL_DIRECTORY_CACHE_SIZE 10
+
+/* A constant used to determine whether a substring was an exact
+ * match by first_diff_index()
+ */
+#define PATTERN_MATCH -1
+/* The arguments used by all fnmatch() calls below
+ */
+#define FNMATCH_FLAGS (FNM_PATHNAME | FNM_PERIOD)
+
+#define CMPL_ERRNO_TOO_LONG ((1<<16)-1)
+
+/* This structure contains all the useful information about a directory
+ * for the purposes of filename completion.  These structures are cached
+ * in the CompletionState struct.  CompletionDir's are reference counted.
+ */
+struct _CompletionDirSent
+{
+  ino_t inode;
+  time_t mtime;
+  dev_t device;
+
+  gint entry_count;
+  gchar *name_buffer; /* memory segment containing names of all entries */
+
+  struct _CompletionDirEntry *entries;
+};
+
+struct _CompletionDir
+{
+  CompletionDirSent *sent;
+
+  gchar *fullname;
+  gint fullname_len;
+
+  struct _CompletionDir *cmpl_parent;
+  gint cmpl_index;
+  gchar *cmpl_text;
+};
+
+/* This structure contains pairs of directory entry names with a flag saying
+ * whether or not they are a valid directory.  NOTE: This information is used
+ * to provide the caller with information about whether to update its completions
+ * or try to open a file.  Since directories are cached by the directory mtime,
+ * a symlink which points to an invalid file (which will not be a directory),
+ * will not be reevaluated if that file is created, unless the containing
+ * directory is touched.  I consider this case to be worth ignoring (josh).
+ */
+struct _CompletionDirEntry
+{
+  gint is_dir;
+  gchar *entry_name;
+};
+
+struct _CompletionUserDir
+{
+  gchar *login;
+  gchar *homedir;
+};
+
+struct _PossibleCompletion
+{
+  /* accessible fields, all are accessed externally by functions
+   * declared above
+   */
+  gchar *text;
+  gint is_a_completion;
+  gint is_directory;
+
+  /* Private fields
+   */
+  gint text_alloc;
+};
+
+struct _CompletionState
+{
+  gint last_valid_char;
+  gchar *updated_text;
+  gint updated_text_len;
+  gint updated_text_alloc;
+  gint re_complete;
+
+  gchar *user_dir_name_buffer;
+  gint user_directories_len;
+
+  gchar *last_completion_text;
+
+  gint user_completion_index; /* if >= 0, currently completing ~user */
+
+  struct _CompletionDir *completion_dir; /* directory completing from */
+  struct _CompletionDir *active_completion_dir;
+
+  struct _PossibleCompletion the_completion;
+
+  struct _CompletionDir *reference_dir; /* initial directory */
+
+  GList* directory_storage;
+  GList* directory_sent_storage;
+
+  struct _CompletionUserDir *user_directories;
+};
+
+
+/* File completion functions which would be external, were they used
+ * outside of this file.
+ */
+
+static CompletionState*    cmpl_init_state        (void);
+static void                cmpl_free_state        (CompletionState *cmpl_state);
+static gint                cmpl_state_okay        (CompletionState* cmpl_state);
+static gchar*              cmpl_strerror          (gint);
+
+static PossibleCompletion* cmpl_completion_matches(gchar           *text_to_complete,
+						   gchar          **remaining_text,
+						   CompletionState *cmpl_state);
+
+/* Returns a name for consideration, possibly a completion, this name
+ * will be invalid after the next call to cmpl_next_completion.
+ */
+static char*               cmpl_this_completion   (PossibleCompletion*);
+
+/* True if this completion matches the given text.  Otherwise, this
+ * output can be used to have a list of non-completions.
+ */
+static gint                cmpl_is_a_completion   (PossibleCompletion*);
+
+/* True if the completion is a directory
+ */
+static gint                cmpl_is_directory      (PossibleCompletion*);
+
+/* Obtains the next completion, or NULL
+ */
+static PossibleCompletion* cmpl_next_completion   (CompletionState*);
+
+/* Updating completions: the return value of cmpl_updated_text() will
+ * be text_to_complete completed as much as possible after the most
+ * recent call to cmpl_completion_matches.  For the present
+ * application, this is the suggested replacement for the user's input
+ * string.  You must CALL THIS AFTER ALL cmpl_text_completions have
+ * been received.
+ */
+static gchar*              cmpl_updated_text       (CompletionState* cmpl_state);
+
+/* After updating, to see if the completion was a directory, call
+ * this.  If it was, you should consider re-calling completion_matches.
+ */
+static gint                cmpl_updated_dir        (CompletionState* cmpl_state);
+
+/* Current location: if using file completion, return the current
+ * directory, from which file completion begins.  More specifically,
+ * the cwd concatenated with all exact completions up to the last
+ * directory delimiter('/').
+ */
+static gchar*              cmpl_reference_position (CompletionState* cmpl_state);
+
+/* backing up: if cmpl_completion_matches returns NULL, you may query
+ * the index of the last completable character into cmpl_updated_text.
+ */
+static gint                cmpl_last_valid_char    (CompletionState* cmpl_state);
+
+/* When the user selects a non-directory, call cmpl_completion_fullname
+ * to get the full name of the selected file.
+ */
+static gchar*              cmpl_completion_fullname (gchar*, CompletionState* cmpl_state);
+
+
+/* Directory operations. */
+static CompletionDir* open_ref_dir         (gchar* text_to_complete,
+					    gchar** remaining_text,
+					    CompletionState* cmpl_state);
+static gboolean       check_dir            (gchar *dir_name, 
+					    struct stat *result, 
+					    gboolean *stat_subdirs);
+static CompletionDir* open_dir             (gchar* dir_name,
+					    CompletionState* cmpl_state);
+static CompletionDir* open_user_dir        (gchar* text_to_complete,
+					    CompletionState *cmpl_state);
+static CompletionDir* open_relative_dir    (gchar* dir_name, CompletionDir* dir,
+					    CompletionState *cmpl_state);
+static CompletionDirSent* open_new_dir     (gchar* dir_name, 
+					    struct stat* sbuf,
+					    gboolean stat_subdirs);
+static gint           correct_dir_fullname (CompletionDir* cmpl_dir);
+static gint           correct_parent       (CompletionDir* cmpl_dir,
+					    struct stat *sbuf);
+static gchar*         find_parent_dir_fullname    (gchar* dirname);
+static CompletionDir* attach_dir           (CompletionDirSent* sent,
+					    gchar* dir_name,
+					    CompletionState *cmpl_state);
+static void           free_dir_sent (CompletionDirSent* sent);
+static void           free_dir      (CompletionDir  *dir);
+static void           prune_memory_usage(CompletionState *cmpl_state);
+
+/* Completion operations */
+static PossibleCompletion* attempt_homedir_completion(gchar* text_to_complete,
+						      CompletionState *cmpl_state);
+static PossibleCompletion* attempt_file_completion(CompletionState *cmpl_state);
+static CompletionDir* find_completion_dir(gchar* text_to_complete,
+					  gchar** remaining_text,
+					  CompletionState* cmpl_state);
+static PossibleCompletion* append_completion_text(gchar* text,
+						  CompletionState* cmpl_state);
+static gint get_pwdb(CompletionState* cmpl_state);
+static gint first_diff_index(gchar* pat, gchar* text);
+static gint compare_user_dir(const void* a, const void* b);
+static gint compare_cmpl_dir(const void* a, const void* b);
+static void update_cmpl(PossibleCompletion* poss,
+			CompletionState* cmpl_state);
+
+static void gtk_file_selection_class_init    (GtkFileSelectionClass *klass);
+static void gtk_file_selection_init          (GtkFileSelection      *filesel);
+static void gtk_file_selection_destroy       (GtkObject             *object);
+static gint gtk_file_selection_key_press     (GtkWidget             *widget,
+					      GdkEventKey           *event,
+					      gpointer               user_data);
+
+static void gtk_file_selection_file_button (GtkWidget *widget,
+					    gint row, 
+					    gint column, 
+					    GdkEventButton *bevent,
+					    gpointer user_data);
+
+static void gtk_file_selection_dir_button (GtkWidget *widget,
+					   gint row, 
+					   gint column, 
+					   GdkEventButton *bevent,
+					   gpointer data);
+
+static void gtk_file_selection_populate      (GtkFileSelection      *fs,
+					      gchar                 *rel_path,
+					      gint                   try_complete);
+static void gtk_file_selection_abort         (GtkFileSelection      *fs);
+
+static void gtk_file_selection_update_history_menu (GtkFileSelection       *fs,
+						    gchar                  *current_dir);
+
+static void gtk_file_selection_create_dir (GtkWidget *widget, gpointer data);
+static void gtk_file_selection_delete_file (GtkWidget *widget, gpointer data);
+static void gtk_file_selection_rename_file (GtkWidget *widget, gpointer data);
+
+static void home_clicked (GtkWidget *widget, gpointer data);
+static void desktop_clicked (GtkWidget *widget, gpointer data);
+static void documents_clicked (GtkWidget *widget, gpointer data);
+
+
+static GtkWindowClass *parent_class = NULL;
+
+static char *last_dir = NULL;
+
+/* Saves errno when something cmpl does fails. */
+static gint cmpl_errno;
+
+GtkType
+gtk_file_selection_get_type (void)
+{
+  static GtkType file_selection_type = 0;
+
+  if (!file_selection_type)
+    {
+      static const GtkTypeInfo filesel_info =
+      {
+	"GtkFileSelection",
+	sizeof (GtkFileSelection),
+	sizeof (GtkFileSelectionClass),
+	(GtkClassInitFunc) gtk_file_selection_class_init,
+	(GtkObjectInitFunc) gtk_file_selection_init,
+	/* reserved_1 */ NULL,
+	/* reserved_2 */ NULL,
+        (GtkClassInitFunc) NULL,
+      };
+
+      file_selection_type = gtk_type_unique (GTK_TYPE_WINDOW, &filesel_info);
+    }
+
+  return file_selection_type;
+}
+
+static void
+gtk_file_selection_class_init (GtkFileSelectionClass *class)
+{
+  GtkObjectClass *object_class;
+
+  object_class = (GtkObjectClass*) class;
+
+  parent_class = gtk_type_class (GTK_TYPE_WINDOW);
+
+  object_class->destroy = gtk_file_selection_destroy;
+}
+
+static GtkWidget *
+create_pixmap_button (GtkFileSelection *filesel, 
+		      GtkWidget *parent_hbox,
+		      gchar **xpm_data,
+		      gchar *title)
+{
+  GtkWidget *btn;
+  GtkWidget *hbox;
+  GtkWidget *wpixmap;
+  GtkWidget *label;
+  GdkPixmap *pixmap;
+  GdkPixmap *mask;
+  
+  btn = gtk_button_new ();
+  gtk_box_pack_start (GTK_BOX (parent_hbox), btn, TRUE, FALSE, 5);
+  gtk_widget_realize (btn);
+
+  pixmap = gdk_pixmap_create_from_xpm_d (btn->window, &mask, 
+					 &btn->style->bg[GTK_STATE_NORMAL], 
+					 (gchar**)xpm_data);
+  
+  label = gtk_label_new (title);
+  
+  wpixmap = gtk_pixmap_new (pixmap, mask);
+  
+  hbox = gtk_vbox_new (FALSE, 5);
+
+  gtk_box_pack_start (GTK_BOX (hbox), wpixmap, FALSE, FALSE, 0);
+  gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
+
+  gtk_widget_show_all (hbox);
+
+  gtk_container_add (GTK_CONTAINER (btn), hbox);
+
+  return btn;
+}
+
+static void
+gtk_file_selection_init (GtkFileSelection *filesel)
+{
+  GtkWidget *entry_vbox;
+  GtkWidget *label;
+  GtkWidget *list_hbox;
+  GtkWidget *confirm_area;
+  GtkWidget *pulldown_hbox;
+  GtkWidget *scrolled_win;
+  GtkWidget *navigation_area;
+  GtkWidget *btn;
+
+  char *dirname;
+  char *dir_title [2];
+  char *file_title [2];
+  
+  filesel->cmpl_state = cmpl_init_state ();
+
+  /* The dialog-sized vertical box  */
+  filesel->main_vbox = gtk_vbox_new (FALSE, 10);
+  gtk_container_set_border_width (GTK_CONTAINER (filesel), 10);
+  gtk_container_add (GTK_CONTAINER (filesel), filesel->main_vbox);
+  gtk_widget_show (filesel->main_vbox);
+
+  /* hbox for pulldown menu */
+  pulldown_hbox = gtk_hbox_new (TRUE, 5);
+  gtk_box_pack_start (GTK_BOX (filesel->main_vbox), pulldown_hbox, FALSE, FALSE, 0);
+  gtk_widget_show (pulldown_hbox);
+  
+  /* Pulldown menu */
+  filesel->history_pulldown = gtk_option_menu_new ();
+  gtk_widget_show (filesel->history_pulldown);
+  gtk_box_pack_start (GTK_BOX (pulldown_hbox), filesel->history_pulldown, 
+		      TRUE, FALSE, 0);
+    
+  /*  The horizontal box containing the directory and file listboxes  */
+  list_hbox = gtk_hbox_new (FALSE, 5);
+  gtk_box_pack_start (GTK_BOX (filesel->main_vbox), list_hbox, TRUE, TRUE, 0);
+  gtk_widget_show (list_hbox);
+
+  /* The navigation buttons */
+  navigation_area = gtk_vbox_new (TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (list_hbox), navigation_area, FALSE, FALSE, 5);
+  gtk_widget_show (navigation_area);
+
+  if (g_get_home_dir () != NULL) 
+    {
+      struct stat sb;
+      btn = create_pixmap_button (filesel, navigation_area, 
+				  (gchar **)home_xpm, 
+				  _("Home"));
+      gtk_widget_show (btn);
+      gtk_signal_connect (GTK_OBJECT (btn), "clicked",
+			  home_clicked, filesel);
+
+      dirname = g_strdup_printf ("%s/.gnome-desktop/", g_get_home_dir ());
+      if (stat (dirname, &sb) == 0 && S_ISDIR(sb.st_mode))
+	{
+	  btn = create_pixmap_button (filesel, navigation_area, 
+				      (gchar **)desktop_xpm, 
+				      _("Desktop"));
+	  gtk_widget_show (btn);
+	  gtk_signal_connect (GTK_OBJECT (btn), "clicked",
+			      desktop_clicked, filesel);
+
+	  
+	}
+      g_free (dirname);
+      
+      dirname = g_strdup_printf ("%s/Documents/", g_get_home_dir ());
+      if (stat (dirname, &sb) == 0 && S_ISDIR(sb.st_mode))
+	{
+	  btn = create_pixmap_button (filesel, navigation_area, 
+				      (gchar **)documents_xpm, 
+				      _("Documents"));
+	  gtk_widget_show (btn);
+	  gtk_signal_connect (GTK_OBJECT (btn), "clicked",
+			      documents_clicked, filesel);
+	}
+      
+      g_free (dirname);
+    }
+
+  /* The directories clist */
+  dir_title[0] = _("Directories");
+  dir_title[1] = NULL;
+  filesel->dir_list = gtk_clist_new_with_titles (1, (gchar**) dir_title);
+  gtk_widget_set_usize (filesel->dir_list, DIR_LIST_WIDTH, DIR_LIST_HEIGHT);
+  gtk_signal_connect (GTK_OBJECT (filesel->dir_list), "select_row",
+		      (GtkSignalFunc) gtk_file_selection_dir_button, 
+		      (gpointer) filesel);
+  gtk_clist_column_titles_passive (GTK_CLIST (filesel->dir_list));
+
+  scrolled_win = gtk_scrolled_window_new (NULL, NULL);
+  gtk_container_add (GTK_CONTAINER (scrolled_win), filesel->dir_list);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_win),
+				  GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+  gtk_container_set_border_width (GTK_CONTAINER (scrolled_win), 5);
+  gtk_box_pack_start (GTK_BOX (list_hbox), scrolled_win, TRUE, TRUE, 0);
+  gtk_widget_show (filesel->dir_list);
+  gtk_widget_show (scrolled_win);
+
+  /* The files clist */
+  file_title[0] = _("Files");
+  file_title[1] = NULL;
+  filesel->file_list = gtk_clist_new_with_titles (1, (gchar**) file_title);
+  gtk_widget_set_usize (filesel->file_list, FILE_LIST_WIDTH, FILE_LIST_HEIGHT);
+  gtk_signal_connect (GTK_OBJECT (filesel->file_list), "select_row",
+		      (GtkSignalFunc) gtk_file_selection_file_button, 
+		      (gpointer) filesel);
+  gtk_clist_column_titles_passive (GTK_CLIST (filesel->file_list));
+
+  scrolled_win = gtk_scrolled_window_new (NULL, NULL);
+  gtk_container_add (GTK_CONTAINER (scrolled_win), filesel->file_list);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_win),
+				  GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+  gtk_container_set_border_width (GTK_CONTAINER (scrolled_win), 5);
+  gtk_box_pack_start (GTK_BOX (list_hbox), scrolled_win, TRUE, TRUE, 0);
+  gtk_widget_show (filesel->file_list);
+  gtk_widget_show (scrolled_win);
+
+  /* The horizontal box containing create, rename etc. buttons */
+  filesel->button_area = gtk_hbutton_box_new ();
+  gtk_button_box_set_layout(GTK_BUTTON_BOX(filesel->button_area), GTK_BUTTONBOX_END);
+  gtk_button_box_set_spacing(GTK_BUTTON_BOX(filesel->button_area), 0);
+  gtk_box_pack_start (GTK_BOX (filesel->main_vbox), filesel->button_area, 
+		      FALSE, FALSE, 0);
+  gtk_widget_show (filesel->button_area);
+  
+  gtk_file_selection_show_fileop_buttons(filesel);
+
+  /* action area for packing buttons into. */
+  filesel->action_area = gtk_hbox_new (TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (filesel->main_vbox), filesel->action_area, 
+		      FALSE, FALSE, 0);
+  gtk_widget_show (filesel->action_area);
+  
+  /*  The OK/Cancel button area */
+  confirm_area = gtk_hbutton_box_new ();
+  gtk_button_box_set_layout(GTK_BUTTON_BOX(confirm_area), GTK_BUTTONBOX_END);
+  gtk_button_box_set_spacing(GTK_BUTTON_BOX(confirm_area), 5);
+  gtk_box_pack_end (GTK_BOX (filesel->main_vbox), confirm_area, FALSE, FALSE, 0);
+  gtk_widget_show (confirm_area);
+
+  /*  The OK button  */
+  filesel->ok_button = gtk_button_new_with_label (_("OK"));
+  GTK_WIDGET_SET_FLAGS (filesel->ok_button, GTK_CAN_DEFAULT);
+  gtk_box_pack_start (GTK_BOX (confirm_area), filesel->ok_button, TRUE, TRUE, 0);
+  gtk_widget_grab_default (filesel->ok_button);
+  gtk_widget_show (filesel->ok_button);
+
+  /*  The Cancel button  */
+  filesel->cancel_button = gtk_button_new_with_label (_("Cancel"));
+  GTK_WIDGET_SET_FLAGS (filesel->cancel_button, GTK_CAN_DEFAULT);
+  gtk_box_pack_start (GTK_BOX (confirm_area), filesel->cancel_button, TRUE, TRUE, 0);
+  gtk_widget_show (filesel->cancel_button);
+
+  /*  The selection entry widget  */
+  entry_vbox = gtk_vbox_new (FALSE, 2);
+  gtk_box_pack_end (GTK_BOX (filesel->main_vbox), entry_vbox, FALSE, FALSE, 0);
+  gtk_widget_show (entry_vbox);
+
+  filesel->selection_text = label = gtk_label_new ("");
+  gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
+  gtk_box_pack_start (GTK_BOX (entry_vbox), label, FALSE, FALSE, 0);
+  gtk_widget_show (label);
+
+  filesel->selection_entry = gtk_entry_new ();
+  gtk_signal_connect (GTK_OBJECT (filesel->selection_entry), "key_press_event",
+		      (GtkSignalFunc) gtk_file_selection_key_press, filesel);
+  gtk_signal_connect_object (GTK_OBJECT (filesel->selection_entry), "focus_in_event",
+			     (GtkSignalFunc) gtk_widget_grab_default,
+			     GTK_OBJECT (filesel->ok_button));
+  gtk_signal_connect_object (GTK_OBJECT (filesel->selection_entry), "activate",
+                             (GtkSignalFunc) gtk_button_clicked,
+                             GTK_OBJECT (filesel->ok_button));
+  gtk_box_pack_start (GTK_BOX (entry_vbox), filesel->selection_entry, TRUE, TRUE, 0);
+  gtk_widget_show (filesel->selection_entry);
+
+  if (!cmpl_state_okay (filesel->cmpl_state))
+    {
+      gchar err_buf[256];
+
+      sprintf (err_buf, _("Directory unreadable: %s"), cmpl_strerror (cmpl_errno));
+
+      gtk_label_set_text (GTK_LABEL (filesel->selection_text), err_buf);
+    }
+  else
+    {
+      if (last_dir) 
+	{
+	  gtk_file_selection_populate (filesel, last_dir, FALSE);
+	}
+      else
+	{
+	  gtk_file_selection_populate (filesel, "", FALSE);
+	}
+    }
+
+  gtk_widget_grab_focus (filesel->selection_entry);
+}
+
+GtkWidget*
+gtk_file_selection_new (const gchar *title)
+{
+  GtkFileSelection *filesel;
+
+  filesel = gtk_type_new (GTK_TYPE_FILE_SELECTION);
+  gtk_window_set_title (GTK_WINDOW (filesel), title);
+
+  return GTK_WIDGET (filesel);
+}
+
+void
+gtk_file_selection_show_fileop_buttons (GtkFileSelection *filesel)
+{
+  g_return_if_fail (filesel != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (filesel));
+    
+  /* delete, create directory, and rename */
+  if (!filesel->fileop_c_dir) 
+    {
+      filesel->fileop_c_dir = gtk_button_new_with_label (_("Create Dir"));
+      gtk_signal_connect (GTK_OBJECT (filesel->fileop_c_dir), "clicked",
+			  (GtkSignalFunc) gtk_file_selection_create_dir, 
+			  (gpointer) filesel);
+      gtk_box_pack_start (GTK_BOX (filesel->button_area), 
+			  filesel->fileop_c_dir, TRUE, TRUE, 0);
+      gtk_widget_show (filesel->fileop_c_dir);
+    }
+	
+  if (!filesel->fileop_del_file) 
+    {
+      filesel->fileop_del_file = gtk_button_new_with_label (_("Delete File"));
+      gtk_signal_connect (GTK_OBJECT (filesel->fileop_del_file), "clicked",
+			  (GtkSignalFunc) gtk_file_selection_delete_file, 
+			  (gpointer) filesel);
+      gtk_box_pack_start (GTK_BOX (filesel->button_area), 
+			  filesel->fileop_del_file, TRUE, TRUE, 0);
+      gtk_widget_show (filesel->fileop_del_file);
+    }
+
+  if (!filesel->fileop_ren_file)
+    {
+      filesel->fileop_ren_file = gtk_button_new_with_label (_("Rename File"));
+      gtk_signal_connect (GTK_OBJECT (filesel->fileop_ren_file), "clicked",
+			  (GtkSignalFunc) gtk_file_selection_rename_file, 
+			  (gpointer) filesel);
+      gtk_box_pack_start (GTK_BOX (filesel->button_area), 
+			  filesel->fileop_ren_file, TRUE, TRUE, 0);
+      gtk_widget_show (filesel->fileop_ren_file);
+    }
+
+  gtk_widget_queue_resize(GTK_WIDGET(filesel));
+}
+
+void       
+gtk_file_selection_hide_fileop_buttons (GtkFileSelection *filesel)
+{
+  g_return_if_fail (filesel != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (filesel));
+    
+  if (filesel->fileop_ren_file) 
+    {
+      gtk_widget_destroy (filesel->fileop_ren_file);
+      filesel->fileop_ren_file = NULL;
+    }
+
+  if (filesel->fileop_del_file)
+    {
+      gtk_widget_destroy (filesel->fileop_del_file);
+      filesel->fileop_del_file = NULL;
+    }
+
+  if (filesel->fileop_c_dir)
+    {
+      gtk_widget_destroy (filesel->fileop_c_dir);
+      filesel->fileop_c_dir = NULL;
+    }
+}
+
+
+
+void
+gtk_file_selection_set_filename (GtkFileSelection *filesel,
+				 const gchar      *filename)
+{
+  char  buf[MAXPATHLEN];
+  const char *name, *last_slash;
+
+  g_return_if_fail (filesel != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (filesel));
+  g_return_if_fail (filename != NULL);
+
+  last_slash = strrchr (filename, '/');
+
+  if (!last_slash)
+    {
+      buf[0] = 0;
+      name = filename;
+    }
+  else
+    {
+      gint len = MIN (MAXPATHLEN - 1, last_slash - filename + 1);
+
+      strncpy (buf, filename, len);
+      buf[len] = 0;
+
+      name = last_slash + 1;
+    }
+
+  gtk_file_selection_populate (filesel, buf, FALSE);
+
+  if (filesel->selection_entry)
+    gtk_entry_set_text (GTK_ENTRY (filesel->selection_entry), name);
+}
+
+gchar*
+gtk_file_selection_get_filename (GtkFileSelection *filesel)
+{
+  static char nothing[2] = "";
+  char *text;
+  char *filename;
+
+  g_return_val_if_fail (filesel != NULL, nothing);
+  g_return_val_if_fail (GTK_IS_FILE_SELECTION (filesel), nothing);
+
+  text = gtk_entry_get_text (GTK_ENTRY (filesel->selection_entry));
+  if (text)
+    {
+      filename = cmpl_completion_fullname (text, filesel->cmpl_state);
+      return filename;
+    }
+
+  return nothing;
+}
+
+void
+gtk_file_selection_complete (GtkFileSelection *filesel,
+			     const gchar      *pattern)
+{
+  g_return_if_fail (filesel != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (filesel));
+  g_return_if_fail (pattern != NULL);
+
+  if (filesel->selection_entry)
+    gtk_entry_set_text (GTK_ENTRY (filesel->selection_entry), pattern);
+  gtk_file_selection_populate (filesel, (gchar*) pattern, TRUE);
+}
+
+static void
+gtk_file_selection_destroy (GtkObject *object)
+{
+  GtkFileSelection *filesel;
+  GList *list;
+  HistoryCallbackArg *callback_arg;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (object));
+
+  filesel = GTK_FILE_SELECTION (object);
+  
+  if (filesel->fileop_dialog)
+	  gtk_widget_destroy (filesel->fileop_dialog);
+  
+  if (filesel->history_list)
+    {
+      list = filesel->history_list;
+      while (list)
+	{
+	  callback_arg = list->data;
+	  g_free (callback_arg->directory);
+	  g_free (callback_arg);
+	  list = list->next;
+	}
+      g_list_free (filesel->history_list);
+      filesel->history_list = NULL;
+    }
+  
+  cmpl_free_state (filesel->cmpl_state);
+  filesel->cmpl_state = NULL;
+
+  if (GTK_OBJECT_CLASS (parent_class)->destroy)
+    (* GTK_OBJECT_CLASS (parent_class)->destroy) (object);
+}
+
+/* Begin file operations callbacks */
+
+static void
+gtk_file_selection_fileop_error (GtkFileSelection *fs, gchar *error_message)
+{
+  GtkWidget *label;
+  GtkWidget *vbox;
+  GtkWidget *button;
+  GtkWidget *dialog;
+  
+  g_return_if_fail (error_message != NULL);
+  
+  /* main dialog */
+  dialog = gtk_dialog_new ();
+  /*
+  gtk_signal_connect (GTK_OBJECT (dialog), "destroy",
+		      (GtkSignalFunc) gtk_file_selection_fileop_destroy, 
+		      (gpointer) fs);
+  */
+  gtk_window_set_title (GTK_WINDOW (dialog), _("Error"));
+  gtk_window_set_position (GTK_WINDOW (dialog), GTK_WIN_POS_MOUSE);
+  
+  /* If file dialog is grabbed, make this dialog modal too */
+  /* When error dialog is closed, file dialog will be grabbed again */
+  if (GTK_WINDOW(fs)->modal)
+      gtk_window_set_modal (GTK_WINDOW(dialog), TRUE);
+
+  vbox = gtk_vbox_new(FALSE, 0);
+  gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->vbox), vbox,
+		     FALSE, FALSE, 0);
+  gtk_widget_show(vbox);
+
+  label = gtk_label_new(error_message);
+  gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);
+  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+  gtk_widget_show(label);
+
+  /* yes, we free it */
+  g_free (error_message);
+  
+  /* close button */
+  button = gtk_button_new_with_label (_("Close"));
+  gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
+			     (GtkSignalFunc) gtk_widget_destroy, 
+			     (gpointer) dialog);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		     button, TRUE, TRUE, 0);
+  GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
+  gtk_widget_grab_default(button);
+  gtk_widget_show (button);
+
+  gtk_widget_show (dialog);
+}
+
+static void
+gtk_file_selection_fileop_destroy (GtkWidget *widget, gpointer data)
+{
+  GtkFileSelection *fs = data;
+
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+  
+  fs->fileop_dialog = NULL;
+}
+
+
+static void
+gtk_file_selection_create_dir_confirmed (GtkWidget *widget, gpointer data)
+{
+  GtkFileSelection *fs = data;
+  gchar *dirname;
+  gchar *path;
+  gchar *full_path;
+  gchar *buf;
+  CompletionState *cmpl_state;
+  
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+
+  dirname = gtk_entry_get_text (GTK_ENTRY (fs->fileop_entry));
+  cmpl_state = (CompletionState*) fs->cmpl_state;
+  path = cmpl_reference_position (cmpl_state);
+  
+  full_path = g_strconcat (path, "/", dirname, NULL);
+  if ( (mkdir (full_path, 0755) < 0) ) 
+    {
+      buf = g_strconcat ("Error creating directory \"", dirname, "\":  ", 
+			 g_strerror(errno), NULL);
+      gtk_file_selection_fileop_error (fs, buf);
+    }
+  g_free (full_path);
+  
+  gtk_widget_destroy (fs->fileop_dialog);
+  gtk_file_selection_populate (fs, "", FALSE);
+}
+  
+static void
+gtk_file_selection_create_dir (GtkWidget *widget, gpointer data)
+{
+  GtkFileSelection *fs = data;
+  GtkWidget *label;
+  GtkWidget *dialog;
+  GtkWidget *vbox;
+  GtkWidget *button;
+
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+
+  if (fs->fileop_dialog)
+	  return;
+  
+  /* main dialog */
+  fs->fileop_dialog = dialog = gtk_dialog_new ();
+  gtk_signal_connect (GTK_OBJECT (dialog), "destroy",
+		      (GtkSignalFunc) gtk_file_selection_fileop_destroy, 
+		      (gpointer) fs);
+  gtk_window_set_title (GTK_WINDOW (dialog), _("Create Directory"));
+  gtk_window_set_position (GTK_WINDOW (dialog), GTK_WIN_POS_MOUSE);
+
+  /* If file dialog is grabbed, grab option dialog */
+  /* When option dialog is closed, file dialog will be grabbed again */
+  if (GTK_WINDOW(fs)->modal)
+      gtk_window_set_modal (GTK_WINDOW(dialog), TRUE);
+
+  vbox = gtk_vbox_new(FALSE, 0);
+  gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->vbox), vbox,
+		     FALSE, FALSE, 0);
+  gtk_widget_show(vbox);
+  
+  label = gtk_label_new(_("Directory name:"));
+  gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);
+  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+  gtk_widget_show(label);
+
+  /*  The directory entry widget  */
+  fs->fileop_entry = gtk_entry_new ();
+  gtk_box_pack_start (GTK_BOX (vbox), fs->fileop_entry, 
+		      TRUE, TRUE, 5);
+  GTK_WIDGET_SET_FLAGS(fs->fileop_entry, GTK_CAN_DEFAULT);
+  gtk_widget_show (fs->fileop_entry);
+  
+  /* buttons */
+  button = gtk_button_new_with_label (_("Create"));
+  gtk_signal_connect (GTK_OBJECT (button), "clicked",
+		      (GtkSignalFunc) gtk_file_selection_create_dir_confirmed, 
+		      (gpointer) fs);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		     button, TRUE, TRUE, 0);
+  GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
+  gtk_widget_show(button);
+  
+  button = gtk_button_new_with_label (_("Cancel"));
+  gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
+			     (GtkSignalFunc) gtk_widget_destroy, 
+			     (gpointer) dialog);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		     button, TRUE, TRUE, 0);
+  GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
+  gtk_widget_grab_default(button);
+  gtk_widget_show (button);
+
+  gtk_widget_show (dialog);
+}
+
+static void
+gtk_file_selection_delete_file_confirmed (GtkWidget *widget, gpointer data)
+{
+  GtkFileSelection *fs = data;
+  CompletionState *cmpl_state;
+  gchar *path;
+  gchar *full_path;
+  gchar *buf;
+  
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+
+  cmpl_state = (CompletionState*) fs->cmpl_state;
+  path = cmpl_reference_position (cmpl_state);
+  
+  full_path = g_strconcat (path, "/", fs->fileop_file, NULL);
+  if ( (unlink (full_path) < 0) ) 
+    {
+      buf = g_strconcat ("Error deleting file \"", fs->fileop_file, "\":  ", 
+			 g_strerror(errno), NULL);
+      gtk_file_selection_fileop_error (fs, buf);
+    }
+  g_free (full_path);
+  
+  gtk_widget_destroy (fs->fileop_dialog);
+  gtk_file_selection_populate (fs, "", FALSE);
+}
+
+static void
+gtk_file_selection_delete_file (GtkWidget *widget, gpointer data)
+{
+  GtkFileSelection *fs = data;
+  GtkWidget *label;
+  GtkWidget *vbox;
+  GtkWidget *button;
+  GtkWidget *dialog;
+  gchar *filename;
+  gchar *buf;
+  
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+
+  if (fs->fileop_dialog)
+	  return;
+
+  filename = gtk_entry_get_text (GTK_ENTRY (fs->selection_entry));
+  if (strlen(filename) < 1)
+	  return;
+
+  fs->fileop_file = filename;
+  
+  /* main dialog */
+  fs->fileop_dialog = dialog = gtk_dialog_new ();
+  gtk_signal_connect (GTK_OBJECT (dialog), "destroy",
+		      (GtkSignalFunc) gtk_file_selection_fileop_destroy, 
+		      (gpointer) fs);
+  gtk_window_set_title (GTK_WINDOW (dialog), _("Delete File"));
+  gtk_window_set_position (GTK_WINDOW (dialog), GTK_WIN_POS_MOUSE);
+
+  /* If file dialog is grabbed, grab option dialog */
+  /* When option dialog is closed, file dialog will be grabbed again */
+  if (GTK_WINDOW(fs)->modal)
+      gtk_window_set_modal (GTK_WINDOW(dialog), TRUE);
+  
+  vbox = gtk_vbox_new(FALSE, 0);
+  gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->vbox), vbox,
+		     FALSE, FALSE, 0);
+  gtk_widget_show(vbox);
+
+  buf = g_strconcat ("Really delete file \"", filename, "\" ?", NULL);
+  label = gtk_label_new(buf);
+  gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);
+  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+  gtk_widget_show(label);
+  g_free(buf);
+  
+  /* buttons */
+  button = gtk_button_new_with_label (_("Delete"));
+  gtk_signal_connect (GTK_OBJECT (button), "clicked",
+		      (GtkSignalFunc) gtk_file_selection_delete_file_confirmed, 
+		      (gpointer) fs);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		     button, TRUE, TRUE, 0);
+  GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
+  gtk_widget_show(button);
+  
+  button = gtk_button_new_with_label (_("Cancel"));
+  gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
+			     (GtkSignalFunc) gtk_widget_destroy, 
+			     (gpointer) dialog);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		     button, TRUE, TRUE, 0);
+  GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
+  gtk_widget_grab_default(button);
+  gtk_widget_show (button);
+
+  gtk_widget_show (dialog);
+
+}
+
+static void
+gtk_file_selection_rename_file_confirmed (GtkWidget *widget, gpointer data)
+{
+  GtkFileSelection *fs = data;
+  gchar *buf;
+  gchar *file;
+  gchar *path;
+  gchar *new_filename;
+  gchar *old_filename;
+  CompletionState *cmpl_state;
+  
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+
+  file = gtk_entry_get_text (GTK_ENTRY (fs->fileop_entry));
+  cmpl_state = (CompletionState*) fs->cmpl_state;
+  path = cmpl_reference_position (cmpl_state);
+  
+  new_filename = g_strconcat (path, "/", file, NULL);
+  old_filename = g_strconcat (path, "/", fs->fileop_file, NULL);
+
+  if ( (rename (old_filename, new_filename)) < 0) 
+    {
+      buf = g_strconcat ("Error renaming file \"", file, "\":  ", 
+			 g_strerror(errno), NULL);
+      gtk_file_selection_fileop_error (fs, buf);
+    }
+  g_free (new_filename);
+  g_free (old_filename);
+  
+  gtk_widget_destroy (fs->fileop_dialog);
+  gtk_file_selection_populate (fs, "", FALSE);
+}
+  
+static void
+gtk_file_selection_rename_file (GtkWidget *widget, gpointer data)
+{
+  GtkFileSelection *fs = data;
+  GtkWidget *label;
+  GtkWidget *dialog;
+  GtkWidget *vbox;
+  GtkWidget *button;
+  gchar *buf;
+  
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+
+  if (fs->fileop_dialog)
+	  return;
+
+  fs->fileop_file = gtk_entry_get_text (GTK_ENTRY (fs->selection_entry));
+  if (strlen(fs->fileop_file) < 1)
+	  return;
+  
+  /* main dialog */
+  fs->fileop_dialog = dialog = gtk_dialog_new ();
+  gtk_signal_connect (GTK_OBJECT (dialog), "destroy",
+		      (GtkSignalFunc) gtk_file_selection_fileop_destroy, 
+		      (gpointer) fs);
+  gtk_window_set_title (GTK_WINDOW (dialog), _("Rename File"));
+  gtk_window_set_position (GTK_WINDOW (dialog), GTK_WIN_POS_MOUSE);
+
+  /* If file dialog is grabbed, grab option dialog */
+  /* When option dialog  closed, file dialog will be grabbed again */
+  if (GTK_WINDOW(fs)->modal)
+    gtk_window_set_modal (GTK_WINDOW(dialog), TRUE);
+  
+  vbox = gtk_vbox_new(FALSE, 0);
+  gtk_container_set_border_width (GTK_CONTAINER(vbox), 8);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->vbox), vbox,
+		     FALSE, FALSE, 0);
+  gtk_widget_show(vbox);
+  
+  buf = g_strconcat ("Rename file \"", fs->fileop_file, "\" to:", NULL);
+  label = gtk_label_new(buf);
+  gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);
+  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
+  gtk_widget_show(label);
+  g_free(buf);
+
+  /* New filename entry */
+  fs->fileop_entry = gtk_entry_new ();
+  gtk_box_pack_start (GTK_BOX (vbox), fs->fileop_entry, 
+		      TRUE, TRUE, 5);
+  GTK_WIDGET_SET_FLAGS(fs->fileop_entry, GTK_CAN_DEFAULT);
+  gtk_widget_show (fs->fileop_entry);
+  
+  gtk_entry_set_text (GTK_ENTRY (fs->fileop_entry), fs->fileop_file);
+  gtk_editable_select_region (GTK_EDITABLE (fs->fileop_entry),
+			      0, strlen (fs->fileop_file));
+
+  /* buttons */
+  button = gtk_button_new_with_label (_("Rename"));
+  gtk_signal_connect (GTK_OBJECT (button), "clicked",
+		      (GtkSignalFunc) gtk_file_selection_rename_file_confirmed, 
+		      (gpointer) fs);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		     button, TRUE, TRUE, 0);
+  GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
+  gtk_widget_show(button);
+  
+  button = gtk_button_new_with_label (_("Cancel"));
+  gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
+			     (GtkSignalFunc) gtk_widget_destroy, 
+			     (gpointer) dialog);
+  gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area),
+		     button, TRUE, TRUE, 0);
+  GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
+  gtk_widget_grab_default(button);
+  gtk_widget_show (button);
+
+  gtk_widget_show (dialog);
+}
+
+
+static void
+home_clicked (GtkWidget *widget, gpointer data)
+{
+  char *dir;
+  
+  dir = g_strdup_printf ("%s/", g_get_home_dir());
+  
+  gtk_file_selection_populate (GTK_FILE_SELECTION (data), 
+			       dir, FALSE);
+  g_free (dir);
+}
+
+static void
+desktop_clicked (GtkWidget *widget, gpointer data)
+{
+  char *dir;
+  
+  dir = g_strdup_printf ("%s/.gnome-desktop/", g_get_home_dir ());
+  
+  gtk_file_selection_populate (GTK_FILE_SELECTION (data), 
+			       dir, FALSE);
+  g_free (dir);
+}
+
+static void 
+documents_clicked (GtkWidget *widget, gpointer data)
+{
+  char *dir;
+  dir = g_strdup_printf ("%s/Documents/", g_get_home_dir ());
+  
+  gtk_file_selection_populate (GTK_FILE_SELECTION (data), dir, FALSE);
+  
+  g_free (dir);
+}
+
+static gint
+gtk_file_selection_key_press (GtkWidget   *widget,
+			      GdkEventKey *event,
+			      gpointer     user_data)
+{
+  GtkFileSelection *fs;
+  char *text;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  if (event->keyval == GDK_Tab)
+    {
+      fs = GTK_FILE_SELECTION (user_data);
+      text = gtk_entry_get_text (GTK_ENTRY (fs->selection_entry));
+
+      text = g_strdup (text);
+
+      gtk_file_selection_populate (fs, text, TRUE);
+
+      g_free (text);
+
+      gtk_signal_emit_stop_by_name (GTK_OBJECT (widget), "key_press_event");
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+static void
+gtk_file_selection_history_callback (GtkWidget *widget, gpointer data)
+{
+  GtkFileSelection *fs = data;
+  HistoryCallbackArg *callback_arg;
+  GList *list;
+
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+
+  list = fs->history_list;
+  
+  while (list) {
+    callback_arg = list->data;
+    
+    if (callback_arg->menu_item == widget)
+      {
+	gtk_file_selection_populate (fs, callback_arg->directory, FALSE);
+	break;
+      }
+    
+    list = list->next;
+  }
+}
+
+static void 
+gtk_file_selection_update_history_menu (GtkFileSelection *fs,
+					gchar *current_directory)
+{
+  HistoryCallbackArg *callback_arg;
+  GtkWidget *menu_item;
+  GList *list;
+  gchar *current_dir;
+  gint dir_len;
+  gint i;
+  
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+  g_return_if_fail (current_directory != NULL);
+  
+  list = fs->history_list;
+
+  if (fs->history_menu) 
+    {
+      while (list) {
+	callback_arg = list->data;
+	g_free (callback_arg->directory);
+	g_free (callback_arg);
+	list = list->next;
+      }
+      g_list_free (fs->history_list);
+      fs->history_list = NULL;
+      
+      gtk_widget_destroy (fs->history_menu);
+    }
+  
+  fs->history_menu = gtk_menu_new();
+
+  current_dir = g_strdup (current_directory);
+
+  dir_len = strlen (current_dir);
+
+  for (i = dir_len; i >= 0; i--)
+    {
+      /* the i == dir_len is to catch the full path for the first 
+       * entry. */
+      if ( (current_dir[i] == '/') || (i == dir_len))
+	{
+	  /* another small hack to catch the full path */
+	  if (i != dir_len) 
+		  current_dir[i + 1] = '\0';
+	  menu_item = gtk_menu_item_new_with_label (current_dir);
+	  
+	  callback_arg = g_new (HistoryCallbackArg, 1);
+	  callback_arg->menu_item = menu_item;
+	  
+	  /* since the autocompletion gets confused if you don't 
+	   * supply a trailing '/' on a dir entry, set the full
+	   * (current) path to "" which just refreshes the filesel */
+	  if (dir_len == i) {
+	    callback_arg->directory = g_strdup ("");
+	  } else {
+	    callback_arg->directory = g_strdup (current_dir);
+	  }
+	  
+	  fs->history_list = g_list_append (fs->history_list, callback_arg);
+	  
+	  gtk_signal_connect (GTK_OBJECT (menu_item), "activate",
+			      (GtkSignalFunc) gtk_file_selection_history_callback,
+			      (gpointer) fs);
+	  gtk_menu_append (GTK_MENU (fs->history_menu), menu_item);
+	  gtk_widget_show (menu_item);
+	}
+    }
+
+  gtk_option_menu_set_menu (GTK_OPTION_MENU (fs->history_pulldown), 
+			    fs->history_menu);
+  g_free (current_dir);
+}
+
+static void
+gtk_file_selection_file_button (GtkWidget *widget,
+			       gint row, 
+			       gint column, 
+			       GdkEventButton *bevent,
+			       gpointer user_data)
+{
+  GtkFileSelection *fs = NULL;
+  gchar *filename, *temp = NULL;
+  
+  g_return_if_fail (GTK_IS_CLIST (widget));
+
+  fs = user_data;
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+  
+  gtk_clist_get_text (GTK_CLIST (fs->file_list), row, 0, &temp);
+  filename = g_strdup (temp);
+
+  if (filename)
+    {
+      if (bevent)
+	switch (bevent->type)
+	  {
+	  case GDK_2BUTTON_PRESS:
+	    gtk_button_clicked (GTK_BUTTON (fs->ok_button));
+	    break;
+	    
+	  default:
+	    gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), filename);
+	    break;
+	  }
+      else
+	gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), filename);
+
+      g_free (filename);
+    }
+}
+
+static void
+gtk_file_selection_dir_button (GtkWidget *widget,
+			       gint row, 
+			       gint column, 
+			       GdkEventButton *bevent,
+			       gpointer user_data)
+{
+  GtkFileSelection *fs = NULL;
+  gchar *filename, *temp = NULL;
+
+  g_return_if_fail (GTK_IS_CLIST (widget));
+
+  fs = GTK_FILE_SELECTION (user_data);
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+
+  gtk_clist_get_text (GTK_CLIST (fs->dir_list), row, 0, &temp);
+  filename = g_strdup (temp);
+
+  if (filename)
+    {
+      if (bevent)
+	switch (bevent->type)
+	  {
+	  case GDK_2BUTTON_PRESS:
+	    gtk_file_selection_populate (fs, filename, FALSE);
+	    break;
+	  
+	  default:
+	    gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), filename);
+	    break;
+	  }
+      else
+	gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), filename);
+
+      g_free (filename);
+    }
+}
+
+static void
+gtk_file_selection_populate (GtkFileSelection *fs,
+			     gchar            *rel_path,
+			     gint              try_complete)
+{
+  CompletionState *cmpl_state;
+  PossibleCompletion* poss;
+  gchar* filename;
+  gint row;
+  gchar* rem_path = rel_path;
+  gchar* sel_text;
+  gchar* text[2];
+  gint did_recurse = FALSE;
+  gint possible_count = 0;
+  gint selection_index = -1;
+  gint file_list_width;
+  gint dir_list_width;
+  
+  g_return_if_fail (fs != NULL);
+  g_return_if_fail (GTK_IS_FILE_SELECTION (fs));
+  
+  cmpl_state = (CompletionState*) fs->cmpl_state;
+  poss = cmpl_completion_matches (rel_path, &rem_path, cmpl_state);
+
+  if (!cmpl_state_okay (cmpl_state))
+    {
+      /* Something went wrong. */
+      gtk_file_selection_abort (fs);
+      return;
+    }
+
+  g_assert (cmpl_state->reference_dir);
+
+  gtk_clist_freeze (GTK_CLIST (fs->dir_list));
+  gtk_clist_clear (GTK_CLIST (fs->dir_list));
+  gtk_clist_freeze (GTK_CLIST (fs->file_list));
+  gtk_clist_clear (GTK_CLIST (fs->file_list));
+
+  /* Set the dir_list to include ./ and ../ */
+  text[1] = NULL;
+  text[0] = "./";
+  row = gtk_clist_append (GTK_CLIST (fs->dir_list), text);
+
+  text[0] = "../";
+  row = gtk_clist_append (GTK_CLIST (fs->dir_list), text);
+
+  /*reset the max widths of the lists*/
+  dir_list_width = gdk_string_width(fs->dir_list->style->font,"../");
+  gtk_clist_set_column_width(GTK_CLIST(fs->dir_list),0,dir_list_width);
+  file_list_width = 1;
+  gtk_clist_set_column_width(GTK_CLIST(fs->file_list),0,file_list_width);
+
+  while (poss)
+    {
+      if (cmpl_is_a_completion (poss))
+        {
+          possible_count += 1;
+
+          filename = cmpl_this_completion (poss);
+
+	  text[0] = filename;
+	  
+          if (cmpl_is_directory (poss))
+            {
+              if (strcmp (filename, "./") != 0 &&
+                  strcmp (filename, "../") != 0)
+		{
+		  int width = gdk_string_width(fs->dir_list->style->font,
+					       filename);
+		  row = gtk_clist_append (GTK_CLIST (fs->dir_list), text);
+		  if(width > dir_list_width)
+		    {
+		      dir_list_width = width;
+		      gtk_clist_set_column_width(GTK_CLIST(fs->dir_list),0,
+						 width);
+		    }
+ 		}
+	    }
+          else
+	    {
+	      int width = gdk_string_width(fs->file_list->style->font,
+				           filename);
+	      row = gtk_clist_append (GTK_CLIST (fs->file_list), text);
+	      if(width > file_list_width)
+	        {
+	          file_list_width = width;
+	          gtk_clist_set_column_width(GTK_CLIST(fs->file_list),0,
+					     width);
+	        }
+            }
+	}
+
+      poss = cmpl_next_completion (cmpl_state);
+    }
+
+  gtk_clist_thaw (GTK_CLIST (fs->dir_list));
+  gtk_clist_thaw (GTK_CLIST (fs->file_list));
+
+  /* File lists are set. */
+
+  g_assert (cmpl_state->reference_dir);
+
+  if (try_complete)
+    {
+
+      /* User is trying to complete filenames, so advance the user's input
+       * string to the updated_text, which is the common leading substring
+       * of all possible completions, and if its a directory attempt
+       * attempt completions in it. */
+
+      if (cmpl_updated_text (cmpl_state)[0])
+        {
+
+          if (cmpl_updated_dir (cmpl_state))
+            {
+	      gchar* dir_name = g_strdup (cmpl_updated_text (cmpl_state));
+
+              did_recurse = TRUE;
+
+              gtk_file_selection_populate (fs, dir_name, TRUE);
+
+              g_free (dir_name);
+            }
+          else
+            {
+	      if (fs->selection_entry)
+		      gtk_entry_set_text (GTK_ENTRY (fs->selection_entry),
+					  cmpl_updated_text (cmpl_state));
+            }
+        }
+      else
+        {
+          selection_index = cmpl_last_valid_char (cmpl_state) -
+                            (strlen (rel_path) - strlen (rem_path));
+	  if (fs->selection_entry)
+	    gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), rem_path);
+        }
+    }
+  else
+    {
+      if (fs->selection_entry)
+	gtk_entry_set_text (GTK_ENTRY (fs->selection_entry), "");
+    }
+
+  if (!did_recurse)
+    {
+      char *dirname;
+      struct stat ent_sbuf;
+      if (fs->selection_entry)
+	gtk_entry_set_position (GTK_ENTRY (fs->selection_entry), selection_index);
+
+      if (fs->selection_entry)
+	{
+	  sel_text = g_strconcat (_("Selection: "),
+				  cmpl_reference_position (cmpl_state),
+				  NULL);
+
+	  gtk_label_set_text (GTK_LABEL (fs->selection_text), sel_text);
+	  g_free (sel_text);
+	}
+
+      if (fs->history_pulldown) 
+	{
+	  gtk_file_selection_update_history_menu (fs, cmpl_reference_position (cmpl_state));
+	}
+
+      dirname = cmpl_reference_position (cmpl_state);
+      if(dirname && stat(dirname, &ent_sbuf) >= 0 && S_ISDIR(ent_sbuf.st_mode))
+        {
+          if (last_dir) 
+            {
+              g_free (last_dir);
+            }
+
+
+          
+          last_dir = g_strdup_printf ("%s%c", dirname, G_DIR_SEPARATOR);
+        }
+    }
+}
+
+static void
+gtk_file_selection_abort (GtkFileSelection *fs)
+{
+  gchar err_buf[256];
+
+  sprintf (err_buf, _("Directory unreadable: %s"), cmpl_strerror (cmpl_errno));
+
+  /*  BEEP gdk_beep();  */
+
+  if (fs->selection_entry)
+    gtk_label_set_text (GTK_LABEL (fs->selection_text), err_buf);
+}
+
+/**********************************************************************/
+/*			  External Interface                          */
+/**********************************************************************/
+
+/* The four completion state selectors
+ */
+static gchar*
+cmpl_updated_text (CompletionState* cmpl_state)
+{
+  return cmpl_state->updated_text;
+}
+
+static gint
+cmpl_updated_dir (CompletionState* cmpl_state)
+{
+  return cmpl_state->re_complete;
+}
+
+static gchar*
+cmpl_reference_position (CompletionState* cmpl_state)
+{
+  return cmpl_state->reference_dir->fullname;
+}
+
+static gint
+cmpl_last_valid_char (CompletionState* cmpl_state)
+{
+  return cmpl_state->last_valid_char;
+}
+
+static gchar*
+cmpl_completion_fullname (gchar* text, CompletionState* cmpl_state)
+{
+  static char nothing[2] = "";
+
+  if (!cmpl_state_okay (cmpl_state))
+    {
+      return nothing;
+    }
+  else if (text[0] == '/')
+    {
+      strcpy (cmpl_state->updated_text, text);
+    }
+  else if (text[0] == '~')
+    {
+      CompletionDir* dir;
+      char* slash;
+
+      dir = open_user_dir (text, cmpl_state);
+
+      if (!dir)
+	{
+	  /* spencer says just return ~something, so
+	   * for now just do it. */
+	  strcpy (cmpl_state->updated_text, text);
+	}
+      else
+	{
+
+	  strcpy (cmpl_state->updated_text, dir->fullname);
+
+	  slash = strchr (text, '/');
+
+	  if (slash)
+	    strcat (cmpl_state->updated_text, slash);
+	}
+    }
+  else
+    {
+      strcpy (cmpl_state->updated_text, cmpl_state->reference_dir->fullname);
+      if (strcmp (cmpl_state->reference_dir->fullname, "/") != 0)
+	strcat (cmpl_state->updated_text, "/");
+      strcat (cmpl_state->updated_text, text);
+    }
+
+  return cmpl_state->updated_text;
+}
+
+/* The three completion selectors
+ */
+static gchar*
+cmpl_this_completion (PossibleCompletion* pc)
+{
+  return pc->text;
+}
+
+static gint
+cmpl_is_directory (PossibleCompletion* pc)
+{
+  return pc->is_directory;
+}
+
+static gint
+cmpl_is_a_completion (PossibleCompletion* pc)
+{
+  return pc->is_a_completion;
+}
+
+/**********************************************************************/
+/*	                 Construction, deletion                       */
+/**********************************************************************/
+
+static CompletionState*
+cmpl_init_state (void)
+{
+  gchar getcwd_buf[2*MAXPATHLEN];
+  CompletionState *new_state;
+
+  new_state = g_new (CompletionState, 1);
+
+  /* We don't use getcwd() on SUNOS, because, it does a popen("pwd")
+   * and, if that wasn't bad enough, hangs in doing so.
+   */
+#if defined(sun) && !defined(__SVR4)
+  if (!getwd (getcwd_buf))
+#else    
+  if (!getcwd (getcwd_buf, MAXPATHLEN))
+#endif    
+    {
+      /* Oh joy, we can't get the current directory. Um..., we should have
+       * a root directory, right? Right? (Probably not portable to non-Unix)
+       */
+      strcpy (getcwd_buf, "/");
+    }
+
+tryagain:
+
+  new_state->reference_dir = NULL;
+  new_state->completion_dir = NULL;
+  new_state->active_completion_dir = NULL;
+  new_state->directory_storage = NULL;
+  new_state->directory_sent_storage = NULL;
+  new_state->last_valid_char = 0;
+  new_state->updated_text = g_new (gchar, MAXPATHLEN);
+  new_state->updated_text_alloc = MAXPATHLEN;
+  new_state->the_completion.text = g_new (gchar, MAXPATHLEN);
+  new_state->the_completion.text_alloc = MAXPATHLEN;
+  new_state->user_dir_name_buffer = NULL;
+  new_state->user_directories = NULL;
+
+  new_state->reference_dir =  open_dir (getcwd_buf, new_state);
+
+  if (!new_state->reference_dir)
+    {
+      /* Directories changing from underneath us, grumble */
+      strcpy (getcwd_buf, "/");
+      goto tryagain;
+    }
+
+  return new_state;
+}
+
+static void
+cmpl_free_dir_list(GList* dp0)
+{
+  GList *dp = dp0;
+
+  while (dp) {
+    free_dir (dp->data);
+    dp = dp->next;
+  }
+
+  g_list_free(dp0);
+}
+
+static void
+cmpl_free_dir_sent_list(GList* dp0)
+{
+  GList *dp = dp0;
+
+  while (dp) {
+    free_dir_sent (dp->data);
+    dp = dp->next;
+  }
+
+  g_list_free(dp0);
+}
+
+static void
+cmpl_free_state (CompletionState* cmpl_state)
+{
+  cmpl_free_dir_list (cmpl_state->directory_storage);
+  cmpl_free_dir_sent_list (cmpl_state->directory_sent_storage);
+
+  if (cmpl_state->user_dir_name_buffer)
+    g_free (cmpl_state->user_dir_name_buffer);
+  if (cmpl_state->user_directories)
+    g_free (cmpl_state->user_directories);
+  if (cmpl_state->the_completion.text)
+    g_free (cmpl_state->the_completion.text);
+  if (cmpl_state->updated_text)
+    g_free (cmpl_state->updated_text);
+
+  g_free (cmpl_state);
+}
+
+static void
+free_dir(CompletionDir* dir)
+{
+  g_free(dir->fullname);
+  g_free(dir);
+}
+
+static void
+free_dir_sent(CompletionDirSent* sent)
+{
+  g_free(sent->name_buffer);
+  g_free(sent->entries);
+  g_free(sent);
+}
+
+static void
+prune_memory_usage(CompletionState *cmpl_state)
+{
+  GList* cdsl = cmpl_state->directory_sent_storage;
+  GList* cdl = cmpl_state->directory_storage;
+  GList* cdl0 = cdl;
+  gint len = 0;
+
+  for(; cdsl && len < CMPL_DIRECTORY_CACHE_SIZE; len += 1)
+    cdsl = cdsl->next;
+
+  if (cdsl) {
+    cmpl_free_dir_sent_list(cdsl->next);
+    cdsl->next = NULL;
+  }
+
+  cmpl_state->directory_storage = NULL;
+  while (cdl) {
+    if (cdl->data == cmpl_state->reference_dir)
+      cmpl_state->directory_storage = g_list_prepend(NULL, cdl->data);
+    else
+      free_dir (cdl->data);
+    cdl = cdl->next;
+  }
+
+  g_list_free(cdl0);
+}
+
+/**********************************************************************/
+/*                        The main entrances.                         */
+/**********************************************************************/
+
+static PossibleCompletion*
+cmpl_completion_matches (gchar* text_to_complete,
+			 gchar** remaining_text,
+			 CompletionState* cmpl_state)
+{
+  gchar* first_slash;
+  PossibleCompletion *poss;
+
+  prune_memory_usage(cmpl_state);
+
+  g_assert (text_to_complete != NULL);
+
+  cmpl_state->user_completion_index = -1;
+  cmpl_state->last_completion_text = text_to_complete;
+  cmpl_state->the_completion.text[0] = 0;
+  cmpl_state->last_valid_char = 0;
+  cmpl_state->updated_text_len = -1;
+  cmpl_state->updated_text[0] = 0;
+  cmpl_state->re_complete = FALSE;
+
+  first_slash = strchr (text_to_complete, '/');
+
+  if (text_to_complete[0] == '~' && !first_slash)
+    {
+      /* Text starts with ~ and there is no slash, show all the
+       * home directory completions.
+       */
+      poss = attempt_homedir_completion (text_to_complete, cmpl_state);
+
+      update_cmpl(poss, cmpl_state);
+
+      return poss;
+    }
+
+  cmpl_state->reference_dir =
+    open_ref_dir (text_to_complete, remaining_text, cmpl_state);
+
+  if(!cmpl_state->reference_dir)
+    return NULL;
+
+  cmpl_state->completion_dir =
+    find_completion_dir (*remaining_text, remaining_text, cmpl_state);
+
+  cmpl_state->last_valid_char = *remaining_text - text_to_complete;
+
+  if(!cmpl_state->completion_dir)
+    return NULL;
+
+  cmpl_state->completion_dir->cmpl_index = -1;
+  cmpl_state->completion_dir->cmpl_parent = NULL;
+  cmpl_state->completion_dir->cmpl_text = *remaining_text;
+
+  cmpl_state->active_completion_dir = cmpl_state->completion_dir;
+
+  cmpl_state->reference_dir = cmpl_state->completion_dir;
+
+  poss = attempt_file_completion(cmpl_state);
+
+  update_cmpl(poss, cmpl_state);
+
+  return poss;
+}
+
+static PossibleCompletion*
+cmpl_next_completion (CompletionState* cmpl_state)
+{
+  PossibleCompletion* poss = NULL;
+
+  cmpl_state->the_completion.text[0] = 0;
+
+  if(cmpl_state->user_completion_index >= 0)
+    poss = attempt_homedir_completion(cmpl_state->last_completion_text, cmpl_state);
+  else
+    poss = attempt_file_completion(cmpl_state);
+
+  update_cmpl(poss, cmpl_state);
+
+  return poss;
+}
+
+/**********************************************************************/
+/*			 Directory Operations                         */
+/**********************************************************************/
+
+/* Open the directory where completion will begin from, if possible. */
+static CompletionDir*
+open_ref_dir(gchar* text_to_complete,
+	     gchar** remaining_text,
+	     CompletionState* cmpl_state)
+{
+  gchar* first_slash;
+  CompletionDir *new_dir;
+
+  first_slash = strchr(text_to_complete, '/');
+
+  if (text_to_complete[0] == '~')
+    {
+      new_dir = open_user_dir(text_to_complete, cmpl_state);
+
+      if(new_dir)
+	{
+	  if(first_slash)
+	    *remaining_text = first_slash + 1;
+	  else
+	    *remaining_text = text_to_complete + strlen(text_to_complete);
+	}
+      else
+	{
+	  return NULL;
+	}
+    }
+  else if (text_to_complete[0] == '/' || !cmpl_state->reference_dir)
+    {
+      gchar *tmp = g_strdup(text_to_complete);
+      gchar *p;
+
+      p = tmp;
+      while (*p && *p != '*' && *p != '?')
+	p++;
+
+      *p = '\0';
+      p = strrchr(tmp, '/');
+      if (p)
+	{
+	  if (p == tmp)
+	    p++;
+      
+	  *p = '\0';
+
+	  new_dir = open_dir(tmp, cmpl_state);
+
+	  if(new_dir)
+	    *remaining_text = text_to_complete + 
+	      ((p == tmp + 1) ? (p - tmp) : (p + 1 - tmp));
+	}
+      else
+	{
+	  /* If no possible candidates, use the cwd */
+	  gchar *curdir = g_get_current_dir ();
+	  
+	  new_dir = open_dir(curdir, cmpl_state);
+
+	  if (new_dir)
+	    *remaining_text = text_to_complete;
+
+	  g_free (curdir);
+	}
+
+      g_free (tmp);
+    }
+  else
+    {
+      *remaining_text = text_to_complete;
+
+      new_dir = open_dir(cmpl_state->reference_dir->fullname, cmpl_state);
+    }
+
+  if(new_dir)
+    {
+      new_dir->cmpl_index = -1;
+      new_dir->cmpl_parent = NULL;
+    }
+
+  return new_dir;
+}
+
+/* open a directory by user name */
+static CompletionDir*
+open_user_dir(gchar* text_to_complete,
+	      CompletionState *cmpl_state)
+{
+  gchar *first_slash;
+  gint cmp_len;
+
+  g_assert(text_to_complete && text_to_complete[0] == '~');
+
+  first_slash = strchr(text_to_complete, '/');
+
+  if (first_slash)
+    cmp_len = first_slash - text_to_complete - 1;
+  else
+    cmp_len = strlen(text_to_complete + 1);
+
+  if(!cmp_len)
+    {
+      /* ~/ */
+      gchar *homedir = g_get_home_dir ();
+
+      if (homedir)
+	return open_dir(homedir, cmpl_state);
+      else
+	return NULL;
+    }
+  else
+    {
+      /* ~user/ */
+      char* copy = g_new(char, cmp_len + 1);
+      struct passwd *pwd;
+      strncpy(copy, text_to_complete + 1, cmp_len);
+      copy[cmp_len] = 0;
+      pwd = getpwnam(copy);
+      g_free(copy);
+      if (!pwd)
+	{
+	  cmpl_errno = errno;
+	  return NULL;
+	}
+
+      return open_dir(pwd->pw_dir, cmpl_state);
+    }
+}
+
+/* open a directory relative the the current relative directory */
+static CompletionDir*
+open_relative_dir(gchar* dir_name,
+		  CompletionDir* dir,
+		  CompletionState *cmpl_state)
+{
+  gchar path_buf[2*MAXPATHLEN];
+
+  if(dir->fullname_len + strlen(dir_name) + 2 >= MAXPATHLEN)
+    {
+      cmpl_errno = CMPL_ERRNO_TOO_LONG;
+      return NULL;
+    }
+
+  strcpy(path_buf, dir->fullname);
+
+  if(dir->fullname_len > 1)
+    {
+      path_buf[dir->fullname_len] = '/';
+      strcpy(path_buf + dir->fullname_len + 1, dir_name);
+    }
+  else
+    {
+      strcpy(path_buf + dir->fullname_len, dir_name);
+    }
+
+  return open_dir(path_buf, cmpl_state);
+}
+
+/* after the cache lookup fails, really open a new directory */
+static CompletionDirSent*
+open_new_dir(gchar* dir_name, struct stat* sbuf, gboolean stat_subdirs)
+{
+  CompletionDirSent* sent;
+  DIR* directory;
+  gchar *buffer_ptr;
+  struct dirent *dirent_ptr;
+  gint buffer_size = 0;
+  gint entry_count = 0;
+  gint i;
+  struct stat ent_sbuf;
+  char path_buf[MAXPATHLEN*2];
+  gint path_buf_len;
+
+  sent = g_new(CompletionDirSent, 1);
+  sent->mtime = sbuf->st_mtime;
+  sent->inode = sbuf->st_ino;
+  sent->device = sbuf->st_dev;
+
+  path_buf_len = strlen(dir_name);
+
+  if (path_buf_len > MAXPATHLEN)
+    {
+      cmpl_errno = CMPL_ERRNO_TOO_LONG;
+      return NULL;
+    }
+
+  strcpy(path_buf, dir_name);
+
+  directory = opendir(dir_name);
+
+  if(!directory)
+    {
+      cmpl_errno = errno;
+      return NULL;
+    }
+
+  while((dirent_ptr = readdir(directory)) != NULL)
+    {
+      int entry_len = strlen(dirent_ptr->d_name);
+      buffer_size += entry_len + 1;
+      entry_count += 1;
+
+      if(path_buf_len + entry_len + 2 >= MAXPATHLEN)
+	{
+	  cmpl_errno = CMPL_ERRNO_TOO_LONG;
+ 	  closedir(directory);
+	  return NULL;
+	}
+    }
+
+  sent->name_buffer = g_new(gchar, buffer_size);
+  sent->entries = g_new(CompletionDirEntry, entry_count);
+  sent->entry_count = entry_count;
+
+  buffer_ptr = sent->name_buffer;
+
+  rewinddir(directory);
+
+  for(i = 0; i < entry_count; i += 1)
+    {
+      dirent_ptr = readdir(directory);
+
+      if(!dirent_ptr)
+	{
+	  cmpl_errno = errno;
+	  closedir(directory);
+	  return NULL;
+	}
+
+      strcpy(buffer_ptr, dirent_ptr->d_name);
+      sent->entries[i].entry_name = buffer_ptr;
+      buffer_ptr += strlen(dirent_ptr->d_name);
+      *buffer_ptr = 0;
+      buffer_ptr += 1;
+
+      path_buf[path_buf_len] = '/';
+      strcpy(path_buf + path_buf_len + 1, dirent_ptr->d_name);
+
+      if (stat_subdirs)
+	{
+	  if(stat(path_buf, &ent_sbuf) >= 0 && S_ISDIR(ent_sbuf.st_mode))
+	    sent->entries[i].is_dir = 1;
+	  else
+	    /* stat may fail, and we don't mind, since it could be a
+	     * dangling symlink. */
+	    sent->entries[i].is_dir = 0;
+	}
+      else
+	sent->entries[i].is_dir = 1;
+    }
+
+  qsort(sent->entries, sent->entry_count, sizeof(CompletionDirEntry), compare_cmpl_dir);
+
+  closedir(directory);
+
+  return sent;
+}
+
+static gboolean
+check_dir(gchar *dir_name, struct stat *result, gboolean *stat_subdirs)
+{
+  /* A list of directories that we know only contain other directories.
+   * Trying to stat every file in these directories would be very
+   * expensive.
+   */
+
+  static struct {
+    gchar *name;
+    gboolean present;
+    struct stat statbuf;
+  } no_stat_dirs[] = {
+    { "/afs", FALSE, { 0 } },
+    { "/net", FALSE, { 0 } }
+  };
+
+  static const gint n_no_stat_dirs = sizeof(no_stat_dirs) / sizeof(no_stat_dirs[0]);
+  static gboolean initialized = FALSE;
+
+  gint i;
+
+  if (!initialized)
+    {
+      initialized = TRUE;
+      for (i = 0; i < n_no_stat_dirs; i++)
+	{
+	  if (stat (no_stat_dirs[i].name, &no_stat_dirs[i].statbuf) == 0)
+	    no_stat_dirs[i].present = TRUE;
+	}
+    }
+
+  if(stat(dir_name, result) < 0)
+    {
+      cmpl_errno = errno;
+      return FALSE;
+    }
+
+  *stat_subdirs = TRUE;
+  for (i=0; i<n_no_stat_dirs; i++)
+    {
+      if (no_stat_dirs[i].present &&
+	  (no_stat_dirs[i].statbuf.st_dev == result->st_dev) &&
+	  (no_stat_dirs[i].statbuf.st_ino == result->st_ino))
+	{
+	  *stat_subdirs = FALSE;
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* open a directory by absolute pathname */
+static CompletionDir*
+open_dir(gchar* dir_name, CompletionState* cmpl_state)
+{
+  struct stat sbuf;
+  gboolean stat_subdirs;
+  CompletionDirSent *sent;
+  GList* cdsl;
+
+  if (!check_dir (dir_name, &sbuf, &stat_subdirs))
+    return NULL;
+
+  cdsl = cmpl_state->directory_sent_storage;
+
+  while (cdsl)
+    {
+      sent = cdsl->data;
+
+      if(sent->inode == sbuf.st_ino &&
+	 sent->mtime == sbuf.st_mtime &&
+	 sent->device == sbuf.st_dev)
+	return attach_dir(sent, dir_name, cmpl_state);
+
+      cdsl = cdsl->next;
+    }
+
+  sent = open_new_dir(dir_name, &sbuf, stat_subdirs);
+
+  if (sent) {
+    cmpl_state->directory_sent_storage =
+      g_list_prepend(cmpl_state->directory_sent_storage, sent);
+
+    return attach_dir(sent, dir_name, cmpl_state);
+  }
+
+  return NULL;
+}
+
+static CompletionDir*
+attach_dir(CompletionDirSent* sent, gchar* dir_name, CompletionState *cmpl_state)
+{
+  CompletionDir* new_dir;
+
+  new_dir = g_new(CompletionDir, 1);
+
+  cmpl_state->directory_storage =
+    g_list_prepend(cmpl_state->directory_storage, new_dir);
+
+  new_dir->sent = sent;
+  new_dir->fullname = g_strdup(dir_name);
+  new_dir->fullname_len = strlen(dir_name);
+
+  return new_dir;
+}
+
+static gint
+correct_dir_fullname(CompletionDir* cmpl_dir)
+{
+  gint length = strlen(cmpl_dir->fullname);
+  struct stat sbuf;
+
+  if (strcmp(cmpl_dir->fullname + length - 2, "/.") == 0)
+    {
+      if (length == 2) 
+	{
+	  strcpy(cmpl_dir->fullname, "/");
+	  cmpl_dir->fullname_len = 1;
+	  return TRUE;
+	} else {
+	  cmpl_dir->fullname[length - 2] = 0;
+	}
+    }
+  else if (strcmp(cmpl_dir->fullname + length - 3, "/./") == 0)
+    cmpl_dir->fullname[length - 2] = 0;
+  else if (strcmp(cmpl_dir->fullname + length - 3, "/..") == 0)
+    {
+      if(length == 3)
+	{
+	  strcpy(cmpl_dir->fullname, "/");
+	  cmpl_dir->fullname_len = 1;
+	  return TRUE;
+	}
+
+      if(stat(cmpl_dir->fullname, &sbuf) < 0)
+	{
+	  cmpl_errno = errno;
+	  return FALSE;
+	}
+
+      cmpl_dir->fullname[length - 2] = 0;
+
+      if(!correct_parent(cmpl_dir, &sbuf))
+	return FALSE;
+    }
+  else if (strcmp(cmpl_dir->fullname + length - 4, "/../") == 0)
+    {
+      if(length == 4)
+	{
+	  strcpy(cmpl_dir->fullname, "/");
+	  cmpl_dir->fullname_len = 1;
+	  return TRUE;
+	}
+
+      if(stat(cmpl_dir->fullname, &sbuf) < 0)
+	{
+	  cmpl_errno = errno;
+	  return FALSE;
+	}
+
+      cmpl_dir->fullname[length - 3] = 0;
+
+      if(!correct_parent(cmpl_dir, &sbuf))
+	return FALSE;
+    }
+
+  cmpl_dir->fullname_len = strlen(cmpl_dir->fullname);
+
+  return TRUE;
+}
+
+static gint
+correct_parent(CompletionDir* cmpl_dir, struct stat *sbuf)
+{
+  struct stat parbuf;
+  gchar *last_slash;
+  gchar *new_name;
+  gchar c = 0;
+
+  last_slash = strrchr(cmpl_dir->fullname, '/');
+
+  g_assert(last_slash);
+
+  if(last_slash != cmpl_dir->fullname)
+    { /* last_slash[0] = 0; */ }
+  else
+    {
+      c = last_slash[1];
+      last_slash[1] = 0;
+    }
+
+  if (stat(cmpl_dir->fullname, &parbuf) < 0)
+    {
+      cmpl_errno = errno;
+      return FALSE;
+    }
+
+  if (parbuf.st_ino == sbuf->st_ino && parbuf.st_dev == sbuf->st_dev)
+    /* it wasn't a link */
+    return TRUE;
+
+  if(c)
+    last_slash[1] = c;
+  /* else
+    last_slash[0] = '/'; */
+
+  /* it was a link, have to figure it out the hard way */
+
+  new_name = find_parent_dir_fullname(cmpl_dir->fullname);
+
+  if (!new_name)
+    return FALSE;
+
+  g_free(cmpl_dir->fullname);
+
+  cmpl_dir->fullname = new_name;
+
+  return TRUE;
+}
+
+static gchar*
+find_parent_dir_fullname(gchar* dirname)
+{
+  gchar buffer[MAXPATHLEN];
+  gchar buffer2[MAXPATHLEN];
+
+#if defined(sun) && !defined(__SVR4)
+  if(!getwd(buffer))
+#else
+  if(!getcwd(buffer, MAXPATHLEN))
+#endif    
+    {
+      cmpl_errno = errno;
+      return NULL;
+    }
+
+  if(chdir(dirname) != 0 || chdir("..") != 0)
+    {
+      cmpl_errno = errno;
+      return NULL;
+    }
+
+#if defined(sun) && !defined(__SVR4)
+  if(!getwd(buffer2))
+#else
+  if(!getcwd(buffer2, MAXPATHLEN))
+#endif
+    {
+      chdir(buffer);
+      cmpl_errno = errno;
+
+      return NULL;
+    }
+
+  if(chdir(buffer) != 0)
+    {
+      cmpl_errno = errno;
+      return NULL;
+    }
+
+  return g_strdup(buffer2);
+}
+
+/**********************************************************************/
+/*                        Completion Operations                       */
+/**********************************************************************/
+
+static PossibleCompletion*
+attempt_homedir_completion(gchar* text_to_complete,
+			   CompletionState *cmpl_state)
+{
+  gint index, length;
+
+  if (!cmpl_state->user_dir_name_buffer &&
+      !get_pwdb(cmpl_state))
+    return NULL;
+  length = strlen(text_to_complete) - 1;
+
+  cmpl_state->user_completion_index += 1;
+
+  while(cmpl_state->user_completion_index < cmpl_state->user_directories_len)
+    {
+      index = first_diff_index(text_to_complete + 1,
+			       cmpl_state->user_directories
+			       [cmpl_state->user_completion_index].login);
+
+      switch(index)
+	{
+	case PATTERN_MATCH:
+	  break;
+	default:
+	  if(cmpl_state->last_valid_char < (index + 1))
+	    cmpl_state->last_valid_char = index + 1;
+	  cmpl_state->user_completion_index += 1;
+	  continue;
+	}
+
+      cmpl_state->the_completion.is_a_completion = 1;
+      cmpl_state->the_completion.is_directory = 1;
+
+      append_completion_text("~", cmpl_state);
+
+      append_completion_text(cmpl_state->
+			      user_directories[cmpl_state->user_completion_index].login,
+			     cmpl_state);
+
+      return append_completion_text("/", cmpl_state);
+    }
+
+  if(text_to_complete[1] ||
+     cmpl_state->user_completion_index > cmpl_state->user_directories_len)
+    {
+      cmpl_state->user_completion_index = -1;
+      return NULL;
+    }
+  else
+    {
+      cmpl_state->user_completion_index += 1;
+      cmpl_state->the_completion.is_a_completion = 1;
+      cmpl_state->the_completion.is_directory = 1;
+
+      return append_completion_text("~/", cmpl_state);
+    }
+}
+
+/* returns the index (>= 0) of the first differing character,
+ * PATTERN_MATCH if the completion matches */
+static gint
+first_diff_index(gchar* pat, gchar* text)
+{
+  gint diff = 0;
+
+  while(*pat && *text && *text == *pat)
+    {
+      pat += 1;
+      text += 1;
+      diff += 1;
+    }
+
+  if(*pat)
+    return diff;
+
+  return PATTERN_MATCH;
+}
+
+static PossibleCompletion*
+append_completion_text(gchar* text, CompletionState* cmpl_state)
+{
+  gint len, i = 1;
+
+  if(!cmpl_state->the_completion.text)
+    return NULL;
+
+  len = strlen(text) + strlen(cmpl_state->the_completion.text) + 1;
+
+  if(cmpl_state->the_completion.text_alloc > len)
+    {
+      strcat(cmpl_state->the_completion.text, text);
+      return &cmpl_state->the_completion;
+    }
+
+  while(i < len) { i <<= 1; }
+
+  cmpl_state->the_completion.text_alloc = i;
+
+  cmpl_state->the_completion.text = (gchar*)g_realloc(cmpl_state->the_completion.text, i);
+
+  if(!cmpl_state->the_completion.text)
+    return NULL;
+  else
+    {
+      strcat(cmpl_state->the_completion.text, text);
+      return &cmpl_state->the_completion;
+    }
+}
+
+static CompletionDir*
+find_completion_dir(gchar* text_to_complete,
+		    gchar** remaining_text,
+		    CompletionState* cmpl_state)
+{
+  gchar* first_slash = strchr(text_to_complete, '/');
+  CompletionDir* dir = cmpl_state->reference_dir;
+  CompletionDir* next;
+  *remaining_text = text_to_complete;
+
+  while(first_slash)
+    {
+      gint len = first_slash - *remaining_text;
+      gint found = 0;
+      gchar *found_name = NULL;         /* Quiet gcc */
+      gint i;
+      gchar* pat_buf = g_new (gchar, len + 1);
+
+      strncpy(pat_buf, *remaining_text, len);
+      pat_buf[len] = 0;
+
+      for(i = 0; i < dir->sent->entry_count; i += 1)
+	{
+	  if(dir->sent->entries[i].is_dir &&
+	     fnmatch(pat_buf, dir->sent->entries[i].entry_name,
+		     FNMATCH_FLAGS)!= FNM_NOMATCH)
+	    {
+	      if(found)
+		{
+		  g_free (pat_buf);
+		  return dir;
+		}
+	      else
+		{
+		  found = 1;
+		  found_name = dir->sent->entries[i].entry_name;
+		}
+	    }
+	}
+
+      if (!found)
+	{
+	  /* Perhaps we are trying to open an automount directory */
+	  found_name = pat_buf;
+	}
+
+      next = open_relative_dir(found_name, dir, cmpl_state);
+      
+      if(!next)
+	{
+	  g_free (pat_buf);
+	  return NULL;
+	}
+      
+      next->cmpl_parent = dir;
+      
+      dir = next;
+      
+      if(!correct_dir_fullname(dir))
+	{
+	  g_free(pat_buf);
+	  return NULL;
+	}
+      
+      *remaining_text = first_slash + 1;
+      first_slash = strchr(*remaining_text, '/');
+
+      g_free (pat_buf);
+    }
+
+  return dir;
+}
+
+static void
+update_cmpl(PossibleCompletion* poss, CompletionState* cmpl_state)
+{
+  gint cmpl_len;
+
+  if(!poss || !cmpl_is_a_completion(poss))
+    return;
+
+  cmpl_len = strlen(cmpl_this_completion(poss));
+
+  if(cmpl_state->updated_text_alloc < cmpl_len + 1)
+    {
+      cmpl_state->updated_text =
+	(gchar*)g_realloc(cmpl_state->updated_text,
+			  cmpl_state->updated_text_alloc);
+      cmpl_state->updated_text_alloc = 2*cmpl_len;
+    }
+
+  if(cmpl_state->updated_text_len < 0)
+    {
+      strcpy(cmpl_state->updated_text, cmpl_this_completion(poss));
+      cmpl_state->updated_text_len = cmpl_len;
+      cmpl_state->re_complete = cmpl_is_directory(poss);
+    }
+  else if(cmpl_state->updated_text_len == 0)
+    {
+      cmpl_state->re_complete = FALSE;
+    }
+  else
+    {
+      gint first_diff =
+	first_diff_index(cmpl_state->updated_text,
+			 cmpl_this_completion(poss));
+
+      cmpl_state->re_complete = FALSE;
+
+      if(first_diff == PATTERN_MATCH)
+	return;
+
+      if(first_diff > cmpl_state->updated_text_len)
+	strcpy(cmpl_state->updated_text, cmpl_this_completion(poss));
+
+      cmpl_state->updated_text_len = first_diff;
+      cmpl_state->updated_text[first_diff] = 0;
+    }
+}
+
+static PossibleCompletion*
+attempt_file_completion(CompletionState *cmpl_state)
+{
+  gchar *pat_buf, *first_slash;
+  CompletionDir *dir = cmpl_state->active_completion_dir;
+
+  dir->cmpl_index += 1;
+
+  if(dir->cmpl_index == dir->sent->entry_count)
+    {
+      if(dir->cmpl_parent == NULL)
+	{
+	  cmpl_state->active_completion_dir = NULL;
+
+	  return NULL;
+	}
+      else
+	{
+	  cmpl_state->active_completion_dir = dir->cmpl_parent;
+
+	  return attempt_file_completion(cmpl_state);
+	}
+    }
+
+  g_assert(dir->cmpl_text);
+
+  first_slash = strchr(dir->cmpl_text, '/');
+
+  if(first_slash)
+    {
+      gint len = first_slash - dir->cmpl_text;
+
+      pat_buf = g_new (gchar, len + 1);
+      strncpy(pat_buf, dir->cmpl_text, len);
+      pat_buf[len] = 0;
+    }
+  else
+    {
+      gint len = strlen(dir->cmpl_text);
+
+      pat_buf = g_new (gchar, len + 2);
+      strcpy(pat_buf, dir->cmpl_text);
+      strcpy(pat_buf + len, "*");
+    }
+
+  if(first_slash)
+    {
+      if(dir->sent->entries[dir->cmpl_index].is_dir)
+	{
+	  if(fnmatch(pat_buf, dir->sent->entries[dir->cmpl_index].entry_name,
+		     FNMATCH_FLAGS) != FNM_NOMATCH)
+	    {
+	      CompletionDir* new_dir;
+
+	      new_dir = open_relative_dir(dir->sent->entries[dir->cmpl_index].entry_name,
+					  dir, cmpl_state);
+
+	      if(!new_dir)
+		{
+		  g_free (pat_buf);
+		  return NULL;
+		}
+
+	      new_dir->cmpl_parent = dir;
+
+	      new_dir->cmpl_index = -1;
+	      new_dir->cmpl_text = first_slash + 1;
+
+	      cmpl_state->active_completion_dir = new_dir;
+
+	      g_free (pat_buf);
+	      return attempt_file_completion(cmpl_state);
+	    }
+	  else
+	    {
+	      g_free (pat_buf);
+	      return attempt_file_completion(cmpl_state);
+	    }
+	}
+      else
+	{
+	  g_free (pat_buf);
+	  return attempt_file_completion(cmpl_state);
+	}
+    }
+  else
+    {
+      if(dir->cmpl_parent != NULL)
+	{
+	  append_completion_text(dir->fullname +
+				 strlen(cmpl_state->completion_dir->fullname) + 1,
+				 cmpl_state);
+	  append_completion_text("/", cmpl_state);
+	}
+
+      append_completion_text(dir->sent->entries[dir->cmpl_index].entry_name, cmpl_state);
+
+      cmpl_state->the_completion.is_a_completion =
+	(fnmatch(pat_buf, dir->sent->entries[dir->cmpl_index].entry_name,
+		 FNMATCH_FLAGS) != FNM_NOMATCH);
+
+      cmpl_state->the_completion.is_directory = dir->sent->entries[dir->cmpl_index].is_dir;
+      if(dir->sent->entries[dir->cmpl_index].is_dir)
+	append_completion_text("/", cmpl_state);
+
+      g_free (pat_buf);
+      return &cmpl_state->the_completion;
+    }
+}
+
+
+static gint
+get_pwdb(CompletionState* cmpl_state)
+{
+  struct passwd *pwd_ptr;
+  gchar* buf_ptr;
+  gint len = 0, i, count = 0;
+
+  if(cmpl_state->user_dir_name_buffer)
+    return TRUE;
+  setpwent ();
+
+  while ((pwd_ptr = getpwent()) != NULL)
+    {
+      len += strlen(pwd_ptr->pw_name);
+      len += strlen(pwd_ptr->pw_dir);
+      len += 2;
+      count += 1;
+    }
+
+  setpwent ();
+
+  cmpl_state->user_dir_name_buffer = g_new(gchar, len);
+  cmpl_state->user_directories = g_new(CompletionUserDir, count);
+  cmpl_state->user_directories_len = count;
+
+  buf_ptr = cmpl_state->user_dir_name_buffer;
+
+  for(i = 0; i < count; i += 1)
+    {
+      pwd_ptr = getpwent();
+      if(!pwd_ptr)
+	{
+	  cmpl_errno = errno;
+	  goto error;
+	}
+
+      strcpy(buf_ptr, pwd_ptr->pw_name);
+      cmpl_state->user_directories[i].login = buf_ptr;
+      buf_ptr += strlen(buf_ptr);
+      buf_ptr += 1;
+      strcpy(buf_ptr, pwd_ptr->pw_dir);
+      cmpl_state->user_directories[i].homedir = buf_ptr;
+      buf_ptr += strlen(buf_ptr);
+      buf_ptr += 1;
+    }
+
+  qsort(cmpl_state->user_directories,
+	cmpl_state->user_directories_len,
+	sizeof(CompletionUserDir),
+	compare_user_dir);
+
+  endpwent();
+
+  return TRUE;
+
+error:
+
+  if(cmpl_state->user_dir_name_buffer)
+    g_free(cmpl_state->user_dir_name_buffer);
+  if(cmpl_state->user_directories)
+    g_free(cmpl_state->user_directories);
+
+  cmpl_state->user_dir_name_buffer = NULL;
+  cmpl_state->user_directories = NULL;
+
+  return FALSE;
+}
+
+static gint
+compare_user_dir(const void* a, const void* b)
+{
+  return strcmp((((CompletionUserDir*)a))->login,
+		(((CompletionUserDir*)b))->login);
+}
+
+static gint
+compare_cmpl_dir(const void* a, const void* b)
+{
+  return strcmp((((CompletionDirEntry*)a))->entry_name,
+		(((CompletionDirEntry*)b))->entry_name);
+}
+
+static gint
+cmpl_state_okay(CompletionState* cmpl_state)
+{
+  return  cmpl_state && cmpl_state->reference_dir;
+}
+
+static gchar*
+cmpl_strerror(gint err)
+{
+  if(err == CMPL_ERRNO_TOO_LONG)
+    return "Name too long";
+  else
+    return g_strerror (err);
+}
diff -uNr a/gtk/gtklabel.c b/gtk/gtklabel.c
--- a/gtk/gtklabel.c	Sun Apr  1 23:12:38 2001
+++ b/gtk/gtklabel.c	Mon May 27 17:48:50 2002
@@ -1004,7 +1004,7 @@
   *r = 0;
 
   result_str = gdk_wcstombs (string_wc);
-  if (string)
+  if (result_str)
     {
       gtk_label_set_text_internal (label, result_str, string_wc);
       gtk_label_set_pattern (label, pattern);
diff -uNr a/gtk/gtklist.c b/gtk/gtklist.c
--- a/gtk/gtklist.c	Wed Jan 31 16:19:29 2001
+++ b/gtk/gtklist.c	Mon May 27 17:48:50 2002
@@ -1299,7 +1299,7 @@
 	  if (start_list->prev)
 	    new_focus_child = start_list->prev->data;
 	  else if (list->children)
-	    new_focus_child = list->children->prev->data;
+	    new_focus_child = list->children->data;
 
 	  if (GTK_WIDGET_HAS_FOCUS (container->focus_child))
 	    grab_focus = TRUE;
@@ -1312,16 +1312,20 @@
       widget = tmp_list->data;
       tmp_list = tmp_list->next;
 
+      gtk_widget_ref (widget);
+
       if (widget->state == GTK_STATE_SELECTED)
 	gtk_list_unselect_child (list, widget);
 
+      gtk_signal_disconnect_by_data (GTK_OBJECT (widget), (gpointer) list);
+      gtk_widget_unparent (widget);
+      
       if (widget == list->undo_focus_child)
 	list->undo_focus_child = NULL;
       if (widget == list->last_focus_child)
 	list->last_focus_child = NULL;
 
-      gtk_signal_disconnect_by_data (GTK_OBJECT (widget), (gpointer) list);
-      gtk_widget_unparent (widget);
+      gtk_widget_unref (widget);
     }
 
   g_list_free (start_list);
@@ -1431,6 +1435,7 @@
       widget = tmp_list->data;
       tmp_list = tmp_list->next;
 
+      gtk_widget_ref (widget);
       if (no_unref)
 	gtk_widget_ref (widget);
 
@@ -1449,14 +1454,16 @@
 	    }
 	}
 
+      gtk_signal_disconnect_by_data (GTK_OBJECT (widget), (gpointer) list);
+      list->children = g_list_remove (list->children, widget);
+      gtk_widget_unparent (widget);
+
       if (widget == list->undo_focus_child)
 	list->undo_focus_child = NULL;
       if (widget == list->last_focus_child)
 	list->last_focus_child = NULL;
 
-      gtk_signal_disconnect_by_data (GTK_OBJECT (widget), (gpointer) list);
-      list->children = g_list_remove (list->children, widget);
-      gtk_widget_unparent (widget);
+      gtk_widget_unref (widget);
     }
   
   if (new_focus_child && new_focus_child != old_focus_child)
diff -uNr a/gtk/gtkmenu.h b/gtk/gtkmenu.h
--- a/gtk/gtkmenu.h	Sat Oct 21 14:22:22 2000
+++ b/gtk/gtkmenu.h	Mon May 27 17:48:50 2002
@@ -21,7 +21,7 @@
  * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
  * file for a list of people on the GTK+ Team.  See the ChangeLog
  * files for a list of changes.  These files are distributed with
- * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/.
  */
 
 #ifndef __GTK_MENU_H__
diff -uNr a/gtk/gtkmenubar.c b/gtk/gtkmenubar.c
--- a/gtk/gtkmenubar.c	Sat Oct 21 14:22:22 2000
+++ b/gtk/gtkmenubar.c	Mon May 27 17:47:20 2002
@@ -217,6 +217,8 @@
   GList *children;
   gint nchildren;
   GtkRequisition child_requisition;
+  gint xthickness;
+  gint ythickness;
 
   g_return_if_fail (widget != NULL);
   g_return_if_fail (GTK_IS_MENU_BAR (widget));
@@ -256,12 +258,21 @@
 	    }
 	}
 
+      if (menu_bar->shadow_type == GTK_SHADOW_NONE)
+	{
+	  xthickness = 0;
+	  ythickness = 0;
+	}
+      else
+	{
+	  xthickness = widget->style->klass->xthickness;
+	  ythickness = widget->style->klass->ythickness;
+	}
+      
       requisition->width += (GTK_CONTAINER (menu_bar)->border_width +
-			     widget->style->klass->xthickness +
-			     BORDER_SPACING) * 2;
+			     xthickness + BORDER_SPACING) * 2;
       requisition->height += (GTK_CONTAINER (menu_bar)->border_width +
-			      widget->style->klass->ythickness +
-			      BORDER_SPACING) * 2;
+			      ythickness + BORDER_SPACING) * 2;
 
       if (nchildren > 0)
 	requisition->width += 2 * CHILD_SPACING * (nchildren - 1);
@@ -279,6 +290,8 @@
   GtkAllocation child_allocation;
   GtkRequisition child_requisition;
   guint offset;
+  gint xthickness;
+  gint ythickness;
   
   g_return_if_fail (widget != NULL);
   g_return_if_fail (GTK_IS_MENU_BAR (widget));
@@ -295,14 +308,23 @@
 
   if (menu_shell->children)
     {
+      if (menu_bar->shadow_type == GTK_SHADOW_NONE)
+	{
+	  xthickness = 0;
+	  ythickness = 0;
+	}
+      else
+	{
+	  xthickness = widget->style->klass->xthickness;
+	  ythickness = widget->style->klass->ythickness;
+	}
+
       child_allocation.x = (GTK_CONTAINER (menu_bar)->border_width +
-			    widget->style->klass->xthickness +
-			    BORDER_SPACING);
+			    xthickness + BORDER_SPACING);
       offset = child_allocation.x; 	/* Window edge to menubar start */
 
       child_allocation.y = (GTK_CONTAINER (menu_bar)->border_width +
-			    widget->style->klass->ythickness +
-			    BORDER_SPACING);
+			    ythickness + BORDER_SPACING);
       child_allocation.height = MAX (1, (gint)allocation->height - child_allocation.y * 2);
 
       children = menu_shell->children;
diff -uNr a/gtk/gtkmenuitem.c b/gtk/gtkmenuitem.c
--- a/gtk/gtkmenuitem.c	Mon Jan 29 19:44:02 2001
+++ b/gtk/gtkmenuitem.c	Mon May 27 17:47:20 2002
@@ -34,7 +34,7 @@
 
 
 #define BORDER_SPACING  3
-#define SELECT_TIMEOUT  75
+#define SELECT_TIMEOUT  150
 
 #define MENU_ITEM_CLASS(w)  GTK_MENU_ITEM_CLASS (GTK_OBJECT (w)->klass)
 
diff -uNr a/gtk/gtkoptionmenu.c b/gtk/gtkoptionmenu.c
--- a/gtk/gtkoptionmenu.c	Mon Feb 12 15:36:37 2001
+++ b/gtk/gtkoptionmenu.c	Mon May 27 17:48:50 2002
@@ -342,30 +342,26 @@
   GtkWidget *child;
   GtkAllocation child_allocation;
   GtkOptionMenuProps props;
+  gint border_width;
     
-  g_return_if_fail (widget != NULL);
-  g_return_if_fail (GTK_IS_OPTION_MENU (widget));
-  g_return_if_fail (allocation != NULL);
-
   gtk_option_menu_get_props (GTK_OPTION_MENU (widget), &props);
+  border_width = GTK_CONTAINER (widget)->border_width;
 
   widget->allocation = *allocation;
   if (GTK_WIDGET_REALIZED (widget))
     gdk_window_move_resize (widget->window,
-			    allocation->x, allocation->y,
-			    allocation->width, allocation->height);
+			    allocation->x + border_width, allocation->y + border_width,
+			    allocation->width - 2 * border_width, allocation->height - 2 * border_width);
 
   child = GTK_BIN (widget)->child;
   if (child && GTK_WIDGET_VISIBLE (child))
     {
-      child_allocation.x = (GTK_CONTAINER (widget)->border_width +
-			    GTK_WIDGET (widget)->style->klass->xthickness) + 1;
-      child_allocation.y = (GTK_CONTAINER (widget)->border_width +
-			    GTK_WIDGET (widget)->style->klass->ythickness) + 1;
-      child_allocation.width = MAX (1, (gint)allocation->width - child_allocation.x * 2 -
+      child_allocation.x = GTK_WIDGET (widget)->style->klass->xthickness + 1;
+      child_allocation.y = GTK_WIDGET (widget)->style->klass->ythickness + 1;
+      child_allocation.width = MAX (1, (gint)allocation->width - child_allocation.x * 2 - border_width * 2 -
 				    props.indicator_width - props.indicator_left_spacing - props.indicator_right_spacing -
 				    CHILD_LEFT_SPACING - CHILD_RIGHT_SPACING - 2);
-      child_allocation.height = MAX (1, (gint)allocation->height - child_allocation.y * 2 -
+      child_allocation.height = MAX (1, (gint)allocation->height - child_allocation.y * 2 - border_width * 2 -
 				     CHILD_TOP_SPACING - CHILD_BOTTOM_SPACING - 2);
       child_allocation.x += CHILD_LEFT_SPACING;
       child_allocation.y += CHILD_TOP_SPACING;
@@ -380,6 +376,7 @@
 {
   GdkRectangle button_area;
   GtkOptionMenuProps props;
+  gint border_width;
 
   g_return_if_fail (widget != NULL);
   g_return_if_fail (GTK_IS_OPTION_MENU (widget));
@@ -388,11 +385,12 @@
   if (GTK_WIDGET_DRAWABLE (widget))
     {
       gtk_option_menu_get_props (GTK_OPTION_MENU (widget), &props);
+      border_width = GTK_CONTAINER (widget)->border_width;
 
-      button_area.x = GTK_CONTAINER (widget)->border_width + 1;
-      button_area.y = GTK_CONTAINER (widget)->border_width + 1;
-      button_area.width = widget->allocation.width - button_area.x * 2;
-      button_area.height = widget->allocation.height - button_area.y * 2;
+      button_area.x = 1;
+      button_area.y = 1;
+      button_area.width = widget->allocation.width - button_area.x * 2 - border_width * 2;
+      button_area.height = widget->allocation.height - button_area.y * 2 - border_width * 2;
 
       /* This is evil, and should be elimated here and in the button
        * code. The point is to clear the focus, and make it
diff -uNr a/gtk/gtkrange.c b/gtk/gtkrange.c
--- a/gtk/gtkrange.c	Mon Feb 19 20:14:13 2001
+++ b/gtk/gtkrange.c	Mon May 27 17:47:20 2002
@@ -161,8 +161,8 @@
   widget_class->focus_out_event = gtk_range_focus_out;
   widget_class->style_set = gtk_range_style_set;
 
-  class->slider_width = 11;
-  class->stepper_size = 11;
+  class->slider_width = 13;
+  class->stepper_size = 13;
   class->stepper_slider_spacing = 1;
   class->min_slider_size = 7;
   class->trough = 1;
diff -uNr a/gtk/gtkrange.c~ b/gtk/gtkrange.c~
--- a/gtk/gtkrange.c~	Wed Dec 31 19:00:00 1969
+++ b/gtk/gtkrange.c~	Mon Feb 19 20:14:13 2001
@@ -0,0 +1,1662 @@
+/* GTK - The GIMP Toolkit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-1999.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include <stdio.h>
+#include "gtkmain.h"
+#include "gtkrange.h"
+#include "gtksignal.h"
+
+
+#define SCROLL_TIMER_LENGTH  20
+#define SCROLL_INITIAL_DELAY 250  /* must hold button this long before ... */
+#define SCROLL_LATER_DELAY   100  /* ... it starts repeating at this rate  */
+#define SCROLL_DELAY_LENGTH  300
+
+#define RANGE_CLASS(w)  GTK_RANGE_CLASS (GTK_OBJECT (w)->klass)
+
+enum {
+  ARG_0,
+  ARG_UPDATE_POLICY
+};
+
+static void gtk_range_class_init               (GtkRangeClass    *klass);
+static void gtk_range_init                     (GtkRange         *range);
+static void gtk_range_set_arg		       (GtkObject        *object,
+						GtkArg           *arg,
+						guint             arg_id);
+static void gtk_range_get_arg		       (GtkObject        *object,
+						GtkArg           *arg,
+						guint             arg_id);
+static void gtk_range_destroy                  (GtkObject        *object);
+static void gtk_range_finalize                 (GtkObject        *object);
+static void gtk_range_draw                     (GtkWidget        *widget,
+						GdkRectangle     *area);
+static void gtk_range_draw_focus               (GtkWidget        *widget);
+static void gtk_range_unrealize                (GtkWidget        *widget);
+static gint gtk_range_expose                   (GtkWidget        *widget,
+						GdkEventExpose   *event);
+static gint gtk_range_button_press             (GtkWidget        *widget,
+						GdkEventButton   *event);
+static gint gtk_range_button_release           (GtkWidget        *widget,
+						GdkEventButton   *event);
+static gint gtk_range_motion_notify            (GtkWidget        *widget,
+						GdkEventMotion   *event);
+static gint gtk_range_key_press                (GtkWidget         *widget,
+						GdkEventKey       *event);
+static gint gtk_range_enter_notify             (GtkWidget        *widget,
+						GdkEventCrossing *event);
+static gint gtk_range_leave_notify             (GtkWidget        *widget,
+						GdkEventCrossing *event);
+static gint gtk_range_focus_in                 (GtkWidget        *widget,
+						GdkEventFocus    *event);
+static gint gtk_range_focus_out                (GtkWidget        *widget,
+						GdkEventFocus    *event);
+static void gtk_range_style_set                 (GtkWidget       *widget,
+						 GtkStyle        *previous_style);
+
+static void gtk_real_range_draw_trough         (GtkRange         *range);
+static void gtk_real_range_draw_slider         (GtkRange         *range);
+static gint gtk_real_range_timer               (GtkRange         *range);
+static gint gtk_range_scroll                   (GtkRange         *range,
+						gfloat            jump_perc);
+
+static void gtk_range_add_timer                (GtkRange         *range);
+static void gtk_range_remove_timer             (GtkRange         *range);
+
+static void gtk_range_adjustment_changed       (GtkAdjustment    *adjustment,
+						gpointer          data);
+static void gtk_range_adjustment_value_changed (GtkAdjustment    *adjustment,
+						gpointer          data);
+
+static void gtk_range_trough_hdims             (GtkRange         *range,
+						gint             *left,
+						gint             *right);
+static void gtk_range_trough_vdims             (GtkRange         *range,
+						gint             *top,
+						gint             *bottom);
+
+static GtkWidgetClass *parent_class = NULL;
+
+
+GtkType
+gtk_range_get_type (void)
+{
+  static GtkType range_type = 0;
+
+  if (!range_type)
+    {
+      static const GtkTypeInfo range_info =
+      {
+	"GtkRange",
+	sizeof (GtkRange),
+	sizeof (GtkRangeClass),
+	(GtkClassInitFunc) gtk_range_class_init,
+	(GtkObjectInitFunc) gtk_range_init,
+	/* reserved_1 */ NULL,
+        /* reserved_2 */ NULL,
+        (GtkClassInitFunc) NULL,
+      };
+
+      range_type = gtk_type_unique (GTK_TYPE_WIDGET, &range_info);
+    }
+
+  return range_type;
+}
+
+static void
+gtk_range_class_init (GtkRangeClass *class)
+{
+  GtkObjectClass *object_class;
+  GtkWidgetClass *widget_class;
+
+  object_class = (GtkObjectClass*) class;
+  widget_class = (GtkWidgetClass*) class;
+
+  parent_class = gtk_type_class (GTK_TYPE_WIDGET);
+
+  gtk_object_add_arg_type ("GtkRange::update_policy",
+			   GTK_TYPE_UPDATE_TYPE,
+			   GTK_ARG_READWRITE,
+			   ARG_UPDATE_POLICY);
+
+  object_class->set_arg = gtk_range_set_arg;
+  object_class->get_arg = gtk_range_get_arg;
+  object_class->destroy = gtk_range_destroy;
+  object_class->finalize = gtk_range_finalize;
+
+  widget_class->draw = gtk_range_draw;
+  widget_class->draw_focus = gtk_range_draw_focus;
+  widget_class->unrealize = gtk_range_unrealize;
+  widget_class->expose_event = gtk_range_expose;
+  widget_class->button_press_event = gtk_range_button_press;
+  widget_class->button_release_event = gtk_range_button_release;
+  widget_class->motion_notify_event = gtk_range_motion_notify;
+  widget_class->key_press_event = gtk_range_key_press;
+  widget_class->enter_notify_event = gtk_range_enter_notify;
+  widget_class->leave_notify_event = gtk_range_leave_notify;
+  widget_class->focus_in_event = gtk_range_focus_in;
+  widget_class->focus_out_event = gtk_range_focus_out;
+  widget_class->style_set = gtk_range_style_set;
+
+  class->slider_width = 11;
+  class->stepper_size = 11;
+  class->stepper_slider_spacing = 1;
+  class->min_slider_size = 7;
+  class->trough = 1;
+  class->slider = 2;
+  class->step_forw = 3;
+  class->step_back = 4;
+  class->draw_background = NULL;
+  class->clear_background = NULL;
+  class->draw_trough = gtk_real_range_draw_trough;
+  class->draw_slider = gtk_real_range_draw_slider;
+  class->draw_step_forw = NULL;
+  class->draw_step_back = NULL;
+  class->trough_click = NULL;
+  class->trough_keys = NULL;
+  class->motion = NULL;
+  class->timer = gtk_real_range_timer;
+}
+
+static void
+gtk_range_set_arg (GtkObject      *object,
+		   GtkArg         *arg,
+		   guint           arg_id)
+{
+  GtkRange *range;
+
+  range = GTK_RANGE (object);
+
+  switch (arg_id)
+    {
+    case ARG_UPDATE_POLICY:
+      gtk_range_set_update_policy (range, GTK_VALUE_ENUM (*arg));
+      break;
+    default:
+      break;
+    }
+}
+
+static void
+gtk_range_get_arg (GtkObject      *object,
+		   GtkArg         *arg,
+		   guint           arg_id)
+{
+  GtkRange *range;
+
+  range = GTK_RANGE (object);
+
+  switch (arg_id)
+    {
+    case ARG_UPDATE_POLICY:
+      GTK_VALUE_ENUM (*arg) = range->policy;
+      break;
+    default:
+      arg->type = GTK_TYPE_INVALID;
+      break;
+    }
+}
+
+static void
+gtk_range_init (GtkRange *range)
+{
+  range->trough = NULL;
+  range->slider = NULL;
+  range->step_forw = NULL;
+  range->step_back = NULL;
+
+  range->x_click_point = 0;
+  range->y_click_point = 0;
+  range->button = 0;
+  range->digits = -1;
+  range->policy = GTK_UPDATE_CONTINUOUS;
+  range->scroll_type = GTK_SCROLL_NONE;
+  range->in_child = 0;
+  range->click_child = 0;
+  range->need_timer = FALSE;
+  range->timer = 0;
+  range->old_value = 0.0;
+  range->old_lower = 0.0;
+  range->old_upper = 0.0;
+  range->old_page_size = 0.0;
+  range->adjustment = NULL;
+}
+
+GtkAdjustment*
+gtk_range_get_adjustment (GtkRange *range)
+{
+  g_return_val_if_fail (range != NULL, NULL);
+  g_return_val_if_fail (GTK_IS_RANGE (range), NULL);
+
+  return range->adjustment;
+}
+
+void
+gtk_range_set_update_policy (GtkRange      *range,
+			     GtkUpdateType  policy)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  range->policy = policy;
+}
+
+void
+gtk_range_set_adjustment (GtkRange      *range,
+			  GtkAdjustment *adjustment)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+  
+  if (!adjustment)
+    adjustment = (GtkAdjustment*) gtk_adjustment_new (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+  else
+    g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
+
+  if (range->adjustment != adjustment)
+    {
+      if (range->adjustment)
+	{
+	  gtk_signal_disconnect_by_data (GTK_OBJECT (range->adjustment),
+					 (gpointer) range);
+	  gtk_object_unref (GTK_OBJECT (range->adjustment));
+	}
+
+      range->adjustment = adjustment;
+      gtk_object_ref (GTK_OBJECT (adjustment));
+      gtk_object_sink (GTK_OBJECT (adjustment));
+      
+      gtk_signal_connect (GTK_OBJECT (adjustment), "changed",
+			  (GtkSignalFunc) gtk_range_adjustment_changed,
+			  (gpointer) range);
+      gtk_signal_connect (GTK_OBJECT (adjustment), "value_changed",
+			  (GtkSignalFunc) gtk_range_adjustment_value_changed,
+			  (gpointer) range);
+      
+      range->old_value = adjustment->value;
+      range->old_lower = adjustment->lower;
+      range->old_upper = adjustment->upper;
+      range->old_page_size = adjustment->page_size;
+      
+      gtk_range_adjustment_changed (adjustment, (gpointer) range);
+    }
+}
+
+void
+gtk_range_draw_background (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (range->trough && RANGE_CLASS (range)->draw_background)
+    (* RANGE_CLASS (range)->draw_background) (range);
+}
+
+void
+gtk_range_clear_background (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (range->trough && RANGE_CLASS (range)->clear_background)
+    (* RANGE_CLASS (range)->clear_background) (range);
+}
+
+void
+gtk_range_draw_trough (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (range->trough && RANGE_CLASS (range)->draw_trough)
+    (* RANGE_CLASS (range)->draw_trough) (range);
+}
+
+void
+gtk_range_draw_slider (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (range->slider && RANGE_CLASS (range)->draw_slider)
+    (* RANGE_CLASS (range)->draw_slider) (range);
+}
+
+void
+gtk_range_draw_step_forw (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (range->step_forw && RANGE_CLASS (range)->draw_step_forw)
+    (* RANGE_CLASS (range)->draw_step_forw) (range);
+}
+
+void
+gtk_range_draw_step_back (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (range->step_back && RANGE_CLASS (range)->draw_step_back)
+    (* RANGE_CLASS (range)->draw_step_back) (range);
+}
+
+void
+gtk_range_slider_update (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (RANGE_CLASS (range)->slider_update)
+    (* RANGE_CLASS (range)->slider_update) (range);
+}
+
+gint
+gtk_range_trough_click (GtkRange *range,
+			gint      x,
+			gint      y,
+			gfloat   *jump_perc)
+{
+  g_return_val_if_fail (range != NULL, GTK_TROUGH_NONE);
+  g_return_val_if_fail (GTK_IS_RANGE (range), GTK_TROUGH_NONE);
+
+  if (RANGE_CLASS (range)->trough_click)
+    return (* RANGE_CLASS (range)->trough_click) (range, x, y, jump_perc);
+
+  return GTK_TROUGH_NONE;
+}
+
+void
+gtk_range_default_hslider_update (GtkRange *range)
+{
+  gint left;
+  gint right;
+  gint x;
+  gint trough_border;
+
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  _gtk_range_get_props (range, NULL, &trough_border, NULL, NULL);
+
+  if (GTK_WIDGET_REALIZED (range))
+    {
+      gtk_range_trough_hdims (range, &left, &right);
+      x = left;
+
+      if (range->adjustment->value < range->adjustment->lower)
+	{
+	  range->adjustment->value = range->adjustment->lower;
+	  gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	}
+      else if (range->adjustment->value > range->adjustment->upper)
+	{
+	  range->adjustment->value = range->adjustment->upper;
+	  gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	}
+
+      if (range->adjustment->lower != (range->adjustment->upper - range->adjustment->page_size))
+	x += ((right - left) * (range->adjustment->value - range->adjustment->lower) /
+	      (range->adjustment->upper - range->adjustment->lower - range->adjustment->page_size));
+
+      if (x < left)
+	x = left;
+      else if (x > right)
+	x = right;
+
+      gdk_window_move (range->slider, x, trough_border);
+    }
+}
+
+void
+gtk_range_default_vslider_update (GtkRange *range)
+{
+  gint top;
+  gint bottom;
+  gint y;
+  gint trough_border;
+
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  _gtk_range_get_props (range, NULL, &trough_border, NULL, NULL);
+
+  if (GTK_WIDGET_REALIZED (range))
+    {
+      gtk_range_trough_vdims (range, &top, &bottom);
+      y = top;
+
+      if (range->adjustment->value < range->adjustment->lower)
+	{
+	  range->adjustment->value = range->adjustment->lower;
+	  gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	}
+      else if (range->adjustment->value > range->adjustment->upper)
+	{
+	  range->adjustment->value = range->adjustment->upper;
+	  gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	}
+
+      if (range->adjustment->lower != (range->adjustment->upper - range->adjustment->page_size))
+	y += ((bottom - top) * (range->adjustment->value - range->adjustment->lower) /
+	      (range->adjustment->upper - range->adjustment->lower - range->adjustment->page_size));
+
+      if (y < top)
+	y = top;
+      else if (y > bottom)
+	y = bottom;
+
+      gdk_window_move (range->slider, trough_border, y);
+    }
+}
+
+gint
+gtk_range_default_htrough_click (GtkRange *range,
+				 gint      x,
+				 gint      y,
+				 gfloat	  *jump_perc)
+{
+  gint trough_border;
+  gint trough_width;
+  gint trough_height;
+  gint slider_x;
+  gint slider_length;
+  gint left, right;
+
+  g_return_val_if_fail (range != NULL, GTK_TROUGH_NONE);
+  g_return_val_if_fail (GTK_IS_RANGE (range), GTK_TROUGH_NONE);
+
+  _gtk_range_get_props (range, NULL, &trough_border, NULL, NULL);
+
+  gtk_range_trough_hdims (range, &left, &right);
+  gdk_window_get_size (range->slider, &slider_length, NULL);
+  right += slider_length;
+	      
+  if ((x > left) && (y > trough_border))
+    {
+      gdk_window_get_size (range->trough, &trough_width, &trough_height);
+
+      if ((x < right) && (y < (trough_height - trough_border)))
+	{
+	  if (jump_perc)
+	    {
+	      *jump_perc = ((gdouble) (x - left)) / ((gdouble) (right - left));
+	      return GTK_TROUGH_JUMP;
+	    }
+	  
+	  gdk_window_get_position (range->slider, &slider_x, NULL);
+	  
+	  if (x < slider_x)
+	    return GTK_TROUGH_START;
+	  else
+	    return GTK_TROUGH_END;
+	}
+    }
+
+  return GTK_TROUGH_NONE;
+}
+
+gint
+gtk_range_default_vtrough_click (GtkRange *range,
+				 gint      x,
+				 gint      y,
+				 gfloat   *jump_perc)
+{
+  gint trough_width;
+  gint trough_height;
+  gint slider_y;
+  gint top, bottom;
+  gint slider_length;
+  gint trough_border;
+
+  g_return_val_if_fail (range != NULL, GTK_TROUGH_NONE);
+  g_return_val_if_fail (GTK_IS_RANGE (range), GTK_TROUGH_NONE);
+
+  _gtk_range_get_props (range, NULL, &trough_border, NULL, NULL);
+
+  gtk_range_trough_vdims (range, &top, &bottom);
+  gdk_window_get_size (range->slider, NULL, &slider_length);
+  bottom += slider_length;
+	      
+  if ((x > trough_border) && (y > top))
+    {
+      gdk_window_get_size (range->trough, &trough_width, &trough_height);
+
+      if ((x < (trough_width - trough_border) && (y < bottom)))
+	{
+	  if (jump_perc)
+	    {
+	      *jump_perc = ((gdouble) (y - top)) / ((gdouble) (bottom - top));
+
+	      return GTK_TROUGH_JUMP;
+	    }
+	  
+	  gdk_window_get_position (range->slider, NULL, &slider_y);
+	  
+	  if (y < slider_y)
+	    return GTK_TROUGH_START;
+	  else
+	    return GTK_TROUGH_END;
+	}
+    }
+
+  return GTK_TROUGH_NONE;
+}
+
+void
+gtk_range_default_hmotion (GtkRange *range,
+			   gint      xdelta,
+			   gint      ydelta)
+{
+  gdouble old_value;
+  gint left, right;
+  gint slider_x, slider_y;
+  gint new_pos;
+
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  range = GTK_RANGE (range);
+
+  gdk_window_get_position (range->slider, &slider_x, &slider_y);
+  gtk_range_trough_hdims (range, &left, &right);
+
+  if (left == right)
+    return;
+
+  new_pos = slider_x + xdelta;
+
+  if (new_pos < left)
+    new_pos = left;
+  else if (new_pos > right)
+    new_pos = right;
+
+  old_value = range->adjustment->value;
+  range->adjustment->value = ((range->adjustment->upper -
+			       range->adjustment->lower -
+			       range->adjustment->page_size) *
+			      (new_pos - left) / (right - left) +
+			      range->adjustment->lower);
+
+  if (range->digits >= 0)
+    {
+      char buffer[64];
+
+      sprintf (buffer, "%0.*f", range->digits, range->adjustment->value);
+      sscanf (buffer, "%f", &range->adjustment->value);
+    }
+
+  if (old_value != range->adjustment->value)
+    {
+      if (range->policy == GTK_UPDATE_CONTINUOUS)
+	{
+	  gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	}
+      else
+	{
+	  gtk_range_slider_update (range);
+	  gtk_range_clear_background (range);
+
+	  if (range->policy == GTK_UPDATE_DELAYED)
+	    {
+	      gtk_range_remove_timer (range);
+	      range->timer = gtk_timeout_add (SCROLL_DELAY_LENGTH,
+					      (GtkFunction) RANGE_CLASS (range)->timer,
+					      (gpointer) range);
+	    }
+	}
+    }
+}
+
+void
+gtk_range_default_vmotion (GtkRange *range,
+			   gint      xdelta,
+			   gint      ydelta)
+{
+  gdouble old_value;
+  gint top, bottom;
+  gint slider_x, slider_y;
+  gint new_pos;
+
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  range = GTK_RANGE (range);
+
+  gdk_window_get_position (range->slider, &slider_x, &slider_y);
+  gtk_range_trough_vdims (range, &top, &bottom);
+
+  if (bottom == top)
+    return;
+
+  new_pos = slider_y + ydelta;
+
+  if (new_pos < top)
+    new_pos = top;
+  else if (new_pos > bottom)
+    new_pos = bottom;
+
+  old_value = range->adjustment->value;
+  range->adjustment->value = ((range->adjustment->upper -
+			       range->adjustment->lower -
+			       range->adjustment->page_size) *
+			      (new_pos - top) / (bottom - top) +
+			      range->adjustment->lower);
+
+  if (range->digits >= 0)
+    {
+      char buffer[64];
+
+      sprintf (buffer, "%0.*f", range->digits, range->adjustment->value);
+      sscanf (buffer, "%f", &range->adjustment->value);
+    }
+
+  if (old_value != range->adjustment->value)
+    {
+      if (range->policy == GTK_UPDATE_CONTINUOUS)
+	{
+	  gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	}
+      else
+	{
+	  gtk_range_slider_update (range);
+	  gtk_range_clear_background (range);
+
+	  if (range->policy == GTK_UPDATE_DELAYED)
+	    {
+	      gtk_range_remove_timer (range);
+	      range->timer = gtk_timeout_add (SCROLL_DELAY_LENGTH,
+					      (GtkFunction) RANGE_CLASS (range)->timer,
+					      (gpointer) range);
+	    }
+	}
+    }
+}
+
+
+static void
+gtk_range_destroy (GtkObject *object)
+{
+  GtkRange *range;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (GTK_IS_RANGE (object));
+
+  range = GTK_RANGE (object);
+
+  if (range->adjustment)
+    gtk_signal_disconnect_by_data (GTK_OBJECT (range->adjustment),
+				   (gpointer) range);
+
+  (* GTK_OBJECT_CLASS (parent_class)->destroy) (object);
+}
+
+static void
+gtk_range_finalize (GtkObject *object)
+{
+  GtkRange *range;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (GTK_IS_RANGE (object));
+
+  range = GTK_RANGE (object);
+
+  if (range->adjustment)
+    gtk_object_unref (GTK_OBJECT (range->adjustment));
+
+  (* GTK_OBJECT_CLASS (parent_class)->finalize) (object);
+}
+
+static void
+gtk_range_draw (GtkWidget    *widget,
+		GdkRectangle *area)
+{
+  GtkRange *range;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_RANGE (widget));
+  g_return_if_fail (area != NULL);
+
+  if (GTK_WIDGET_VISIBLE (widget) && GTK_WIDGET_MAPPED (widget))
+    {
+      range = GTK_RANGE (widget);
+
+      gtk_range_draw_background (range);
+      gtk_range_draw_trough (range);
+      gtk_range_draw_slider (range);
+      gtk_range_draw_step_forw (range);
+      gtk_range_draw_step_back (range);
+    }
+}
+
+static void
+gtk_range_draw_focus (GtkWidget *widget)
+{
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_RANGE (widget));
+
+  if (GTK_WIDGET_DRAWABLE (widget))
+    gtk_range_draw_trough (GTK_RANGE (widget));
+}
+
+static void
+gtk_range_unrealize (GtkWidget *widget)
+{
+  GtkRange *range;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_RANGE (widget));
+
+  range = GTK_RANGE (widget);
+
+  if (range->slider)
+    {
+      gdk_window_set_user_data (range->slider, NULL);
+      gdk_window_destroy (range->slider);
+      range->slider = NULL;
+    }
+  if (range->trough)
+    {
+      gdk_window_set_user_data (range->trough, NULL);
+      gdk_window_destroy (range->trough);
+      range->trough = NULL;
+    }
+  if (range->step_forw)
+    {
+      gdk_window_set_user_data (range->step_forw, NULL);
+      gdk_window_destroy (range->step_forw);
+      range->step_forw = NULL;
+    }
+  if (range->step_back)
+    {
+      gdk_window_set_user_data (range->step_back, NULL);
+      gdk_window_destroy (range->step_back);
+      range->step_back = NULL;
+    }
+
+  if (GTK_WIDGET_CLASS (parent_class)->unrealize)
+    (* GTK_WIDGET_CLASS (parent_class)->unrealize) (widget);
+}
+
+static gint
+gtk_range_expose (GtkWidget      *widget,
+		  GdkEventExpose *event)
+{
+  GtkRange *range;
+  gint trough_border;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  range = GTK_RANGE (widget);
+
+  _gtk_range_get_props (range, NULL, &trough_border, NULL, NULL);
+
+  if (event->window == range->trough)
+    {
+      /* Don't redraw if we are only exposing the literal trough region.
+       * this may not work correctly if someone overrides the default
+       * trough-drawing handler. (Probably should really pass another
+       * argument - the redrawn area to all the drawing functions)
+       */
+      if (!((event->area.x >= trough_border) &&
+	    (event->area.y >= trough_border) &&
+	    (event->area.x + event->area.width <= 
+	     widget->allocation.width - trough_border) &&
+	    (event->area.y + event->area.height <= 
+	     widget->allocation.height - trough_border)))
+	gtk_range_draw_trough (range);
+    }
+  else if (event->window == widget->window)
+    {
+      gtk_range_draw_background (range); 
+    }
+  else if (event->window == range->slider)
+    {
+      gtk_range_draw_slider (range);
+    }
+  else if (event->window == range->step_forw)
+    {
+      gtk_range_draw_step_forw (range);
+    }
+  else if (event->window == range->step_back)
+    {
+      gtk_range_draw_step_back (range);
+    }
+  return FALSE;
+}
+
+static gint
+gtk_range_button_press (GtkWidget      *widget,
+			GdkEventButton *event)
+{
+  GtkRange *range;
+  gint trough_part;
+  gfloat jump_perc;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  if (!GTK_WIDGET_HAS_FOCUS (widget))
+    gtk_widget_grab_focus (widget);
+
+  jump_perc = -1;
+  range = GTK_RANGE (widget);
+  if (range->button == 0)
+    {
+      gtk_grab_add (widget);
+
+      range->button = event->button;
+      range->x_click_point = event->x;
+      range->y_click_point = event->y;
+
+      if (event->window == range->trough)
+	{
+	  range->click_child = RANGE_CLASS (range)->trough;
+	  
+	  if (range->button == 2)
+	    trough_part = gtk_range_trough_click (range, event->x, event->y, &jump_perc);
+	  else
+	    trough_part = gtk_range_trough_click (range, event->x, event->y, NULL);
+	  
+	  range->scroll_type = GTK_SCROLL_NONE;
+	  if (trough_part == GTK_TROUGH_START)
+	    range->scroll_type = GTK_SCROLL_PAGE_BACKWARD;
+	  else if (trough_part == GTK_TROUGH_END)
+	    range->scroll_type = GTK_SCROLL_PAGE_FORWARD;
+	  else if (trough_part == GTK_TROUGH_JUMP &&
+		   jump_perc >= 0 && jump_perc <= 1)
+	    range->scroll_type = GTK_SCROLL_JUMP;
+	  
+	  if (range->scroll_type != GTK_SCROLL_NONE)
+	    {
+	      gtk_range_scroll (range, jump_perc);
+	      gtk_range_add_timer (range);
+	    }
+	}
+      else if (event->window == range->slider)
+	{
+	  range->click_child = RANGE_CLASS (range)->slider;
+	  range->scroll_type = GTK_SCROLL_NONE;
+	}
+      else if (event->window == range->step_forw)
+	{
+	  range->click_child = RANGE_CLASS (range)->step_forw;
+	  range->scroll_type = GTK_SCROLL_STEP_FORWARD;
+
+	  gtk_range_scroll (range, -1);
+	  gtk_range_add_timer (range);
+	  gtk_range_draw_step_forw (range);
+	}
+      else if (event->window == range->step_back)
+	{
+	  range->click_child = RANGE_CLASS (range)->step_back;
+	  range->scroll_type = GTK_SCROLL_STEP_BACKWARD;
+
+	  gtk_range_scroll (range, -1);
+	  gtk_range_add_timer (range);
+	  gtk_range_draw_step_back (range);
+	}
+    }
+  
+  return TRUE;
+}
+
+static gint
+gtk_range_button_release (GtkWidget      *widget,
+			  GdkEventButton *event)
+{
+  GtkRange *range;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  range = GTK_RANGE (widget);
+
+  if (range->button == event->button)
+    {
+      gtk_grab_remove (widget);
+
+      range->button = 0;
+      range->x_click_point = -1;
+      range->y_click_point = -1;
+
+      if (range->click_child == RANGE_CLASS (range)->slider)
+	{
+	  if (range->policy == GTK_UPDATE_DELAYED)
+	    gtk_range_remove_timer (range);
+
+	  if ((range->policy != GTK_UPDATE_CONTINUOUS) &&
+	      (range->old_value != range->adjustment->value))
+	    gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	}
+      else if ((range->click_child == RANGE_CLASS (range)->trough) ||
+	       (range->click_child == RANGE_CLASS (range)->step_forw) ||
+	       (range->click_child == RANGE_CLASS (range)->step_back))
+	{
+	  gtk_range_remove_timer (range);
+
+	  if ((range->policy != GTK_UPDATE_CONTINUOUS) &&
+	      (range->old_value != range->adjustment->value))
+	    gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+
+	  if (range->click_child == RANGE_CLASS (range)->step_forw)
+	    {
+	      range->click_child = 0;
+	      gtk_range_draw_step_forw (range);
+	    }
+	  else if (range->click_child == RANGE_CLASS (range)->step_back)
+	    {
+	      range->click_child = 0;
+	      gtk_range_draw_step_back (range);
+	    }
+	}
+
+      range->click_child = 0;
+    }
+
+  return TRUE;
+}
+
+static gint
+gtk_range_motion_notify (GtkWidget      *widget,
+			 GdkEventMotion *event)
+{
+  GtkRange *range;
+  GdkModifierType mods;
+  gint x, y, mask;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  range = GTK_RANGE (widget);
+
+  if (range->click_child == RANGE_CLASS (range)->slider)
+    {
+      x = event->x;
+      y = event->y;
+
+      if (event->is_hint || (event->window != range->slider))
+	gdk_window_get_pointer (range->slider, &x, &y, &mods);
+
+      switch (range->button)
+	{
+	case 1:
+	  mask = GDK_BUTTON1_MASK;
+	  break;
+	case 2:
+	  mask = GDK_BUTTON2_MASK;
+	  break;
+	case 3:
+	  mask = GDK_BUTTON3_MASK;
+	  break;
+	default:
+	  mask = 0;
+	  break;
+	}
+
+      if (mods & mask)
+	{
+	  if (RANGE_CLASS (range)->motion)
+	    (* RANGE_CLASS (range)->motion) (range, x - range->x_click_point, y - range->y_click_point);
+	}
+    }
+
+  return TRUE;
+}
+
+static gint
+gtk_range_key_press (GtkWidget   *widget,
+		     GdkEventKey *event)
+{
+  GtkRange *range;
+  gint return_val;
+  GtkScrollType scroll = GTK_SCROLL_NONE;
+  GtkTroughType pos = GTK_TROUGH_NONE;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  range = GTK_RANGE (widget);
+  return_val = FALSE;
+
+  if (RANGE_CLASS (range)->trough_keys)
+    return_val = (* RANGE_CLASS (range)->trough_keys) (range, event, &scroll, &pos);
+
+  if (return_val)
+    {
+      if (scroll != GTK_SCROLL_NONE)
+	{
+	  range->scroll_type = scroll;
+	  gtk_range_scroll (range, -1);
+	  if (range->old_value != range->adjustment->value)
+	    {
+	      gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	      switch (range->scroll_type)
+		{
+		case GTK_SCROLL_STEP_BACKWARD:
+		  gtk_range_draw_step_back (range);
+		  break;
+		case GTK_SCROLL_STEP_FORWARD:
+		  gtk_range_draw_step_forw (range);
+		  break;
+		}
+	    }
+	}
+      if (pos != GTK_TROUGH_NONE)
+	{
+	  if (pos == GTK_TROUGH_START)
+	    range->adjustment->value = range->adjustment->lower;
+	  else if (pos == GTK_TROUGH_END)
+	    range->adjustment->value =
+	      range->adjustment->upper - range->adjustment->page_size;
+
+	  if (range->old_value != range->adjustment->value)
+	    {
+	      gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment),
+				       "value_changed");
+
+	      gtk_range_slider_update (range);
+	      gtk_range_clear_background (range);
+	    }
+	}
+    }
+  return return_val;
+}
+
+static gint
+gtk_range_enter_notify (GtkWidget        *widget,
+			GdkEventCrossing *event)
+{
+  GtkRange *range;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  range = GTK_RANGE (widget);
+
+  if (event->window == range->trough)
+    {
+      range->in_child = RANGE_CLASS (range)->trough;
+    }
+  else if (event->window == range->slider)
+    {
+      range->in_child = RANGE_CLASS (range)->slider;
+
+      if ((range->click_child == 0) ||
+	  (range->click_child == RANGE_CLASS (range)->trough))
+	gtk_range_draw_slider (range);
+    }
+  else if (event->window == range->step_forw)
+    {
+      range->in_child = RANGE_CLASS (range)->step_forw;
+
+      if ((range->click_child == 0) ||
+	  (range->click_child == RANGE_CLASS (range)->trough))
+	gtk_range_draw_step_forw (range);
+    }
+  else if (event->window == range->step_back)
+    {
+      range->in_child = RANGE_CLASS (range)->step_back;
+
+      if ((range->click_child == 0) ||
+	  (range->click_child == RANGE_CLASS (range)->trough))
+	gtk_range_draw_step_back (range);
+    }
+
+  return TRUE;
+}
+
+static gint
+gtk_range_leave_notify (GtkWidget        *widget,
+			GdkEventCrossing *event)
+{
+  GtkRange *range;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  range = GTK_RANGE (widget);
+
+  range->in_child = 0;
+
+  if (event->window == range->trough)
+    {
+    }
+  else if (event->window == range->slider)
+    {
+      if ((range->click_child == 0) ||
+	  (range->click_child == RANGE_CLASS (range)->trough))
+	gtk_range_draw_slider (range);
+    }
+  else if (event->window == range->step_forw)
+    {
+      if ((range->click_child == 0) ||
+	  (range->click_child == RANGE_CLASS (range)->trough))
+	gtk_range_draw_step_forw (range);
+    }
+  else if (event->window == range->step_back)
+    {
+      if ((range->click_child == 0) ||
+	  (range->click_child == RANGE_CLASS (range)->trough))
+	gtk_range_draw_step_back (range);
+    }
+
+  return TRUE;
+}
+
+static gint
+gtk_range_focus_in (GtkWidget     *widget,
+		    GdkEventFocus *event)
+{
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  GTK_WIDGET_SET_FLAGS (widget, GTK_HAS_FOCUS);
+  gtk_widget_draw_focus (widget);
+
+  return TRUE;
+}
+
+static gint
+gtk_range_focus_out (GtkWidget     *widget,
+		     GdkEventFocus *event)
+{
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (widget), FALSE);
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  GTK_WIDGET_UNSET_FLAGS (widget, GTK_HAS_FOCUS);
+  gtk_widget_draw_focus (widget);
+
+  return TRUE;
+}
+
+static void
+gtk_real_range_draw_trough (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (range->trough)
+     {
+	gtk_paint_box (GTK_WIDGET (range)->style, range->trough,
+		       GTK_STATE_ACTIVE, GTK_SHADOW_IN,
+		       NULL, GTK_WIDGET(range), "trough",
+		       0, 0, -1, -1);
+	if (GTK_WIDGET_HAS_FOCUS (range))
+	  gtk_paint_focus (GTK_WIDGET (range)->style,
+			  range->trough,
+			   NULL, GTK_WIDGET(range), "trough",
+			  0, 0, -1, -1);
+    }
+}
+
+static void
+gtk_real_range_draw_slider (GtkRange *range)
+{
+  GtkStateType state_type;
+   
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+   
+  if (range->slider)
+    {
+      if ((range->in_child == RANGE_CLASS (range)->slider) ||
+	  (range->click_child == RANGE_CLASS (range)->slider))
+	state_type = GTK_STATE_PRELIGHT;
+      else
+	state_type = GTK_STATE_NORMAL;
+      gtk_paint_box (GTK_WIDGET (range)->style, range->slider,
+		     state_type, GTK_SHADOW_OUT,
+		     NULL, GTK_WIDGET (range), "slider",
+		     0, 0, -1, -1);
+    }
+}
+
+static gint
+gtk_real_range_timer (GtkRange *range)
+{
+  gint return_val;
+
+  GDK_THREADS_ENTER ();
+
+  return_val = TRUE;
+  if (range->click_child == RANGE_CLASS (range)->slider)
+    {
+      if (range->policy == GTK_UPDATE_DELAYED)
+	gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+      return_val = FALSE;
+    }
+  else
+    {
+      GdkModifierType mods, mask;
+
+      if (!range->timer)
+	{
+	  return_val = FALSE;
+	  if (range->need_timer)
+	    range->timer = gtk_timeout_add (SCROLL_TIMER_LENGTH,
+					    (GtkFunction) RANGE_CLASS (range)->timer,
+					    (gpointer) range);
+	  else
+	    {
+	      GDK_THREADS_LEAVE ();
+	      return FALSE;
+	    }
+	  range->need_timer = FALSE;
+	}
+
+      switch (range->button)
+	{
+	case 1:
+	  mask = GDK_BUTTON1_MASK;
+	  break;
+	case 2:
+	  mask = GDK_BUTTON2_MASK;
+	  break;
+	case 3:
+	  mask = GDK_BUTTON3_MASK;
+	  break;
+	default:
+	  mask = 0;
+	  break;
+	}
+
+      gdk_window_get_pointer (range->slider, NULL, NULL, &mods);
+
+      if (mods & mask)
+	return_val = gtk_range_scroll (range, -1);
+    }
+
+  GDK_THREADS_LEAVE ();
+
+  return return_val;
+}
+
+static gint
+gtk_range_scroll (GtkRange *range,
+		  gfloat    jump_perc)
+{
+  gfloat new_value;
+  gint return_val;
+
+  g_return_val_if_fail (range != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_RANGE (range), FALSE);
+
+  new_value = range->adjustment->value;
+  return_val = TRUE;
+
+  switch (range->scroll_type)
+    {
+    case GTK_SCROLL_NONE:
+      break;
+      
+    case GTK_SCROLL_JUMP:
+      if (jump_perc >= 0 && jump_perc <= 1)
+	{
+	  new_value = (range->adjustment->lower +
+		       (range->adjustment->upper - range->adjustment->page_size -
+			range->adjustment->lower) * jump_perc);
+	}
+      break;
+      
+    case GTK_SCROLL_STEP_BACKWARD:
+      new_value -= range->adjustment->step_increment;
+      if (new_value <= range->adjustment->lower)
+	{
+	  new_value = range->adjustment->lower;
+	  return_val = FALSE;
+	  range->timer = 0;
+	}
+      break;
+
+    case GTK_SCROLL_STEP_FORWARD:
+      new_value += range->adjustment->step_increment;
+      if (new_value >= (range->adjustment->upper - range->adjustment->page_size))
+	{
+	  new_value = range->adjustment->upper - range->adjustment->page_size;
+	  return_val = FALSE;
+	  range->timer = 0;
+	}
+      break;
+
+    case GTK_SCROLL_PAGE_BACKWARD:
+      new_value -= range->adjustment->page_increment;
+      if (new_value <= range->adjustment->lower)
+	{
+	  new_value = range->adjustment->lower;
+	  return_val = FALSE;
+	  range->timer = 0;
+	}
+      break;
+
+    case GTK_SCROLL_PAGE_FORWARD:
+      new_value += range->adjustment->page_increment;
+      if (new_value >= (range->adjustment->upper - range->adjustment->page_size))
+	{
+	  new_value = range->adjustment->upper - range->adjustment->page_size;
+	  return_val = FALSE;
+	  range->timer = 0;
+	}
+      break;
+    }
+
+  if (new_value != range->adjustment->value)
+    {
+      range->adjustment->value = new_value;
+
+      if ((range->policy == GTK_UPDATE_CONTINUOUS) ||
+	  (!return_val && (range->policy == GTK_UPDATE_DELAYED)))
+	{
+	  gtk_signal_emit_by_name (GTK_OBJECT (range->adjustment), "value_changed");
+	}
+      else
+	{
+	  gtk_range_slider_update (range);
+	  gtk_range_clear_background (range);
+	}
+    }
+
+  return return_val;
+}
+
+
+static gboolean
+gtk_range_timer_1st_time (GtkRange *range)
+{
+  /*
+   * If the real timeout function succeeds and the timeout is still set,
+   * replace it with a quicker one so successive scrolling goes faster.
+   */
+  gtk_object_ref (GTK_OBJECT (range));
+
+  if (RANGE_CLASS (range)->timer (range))
+    {
+      if (range->timer)
+	{
+	  /* We explicitely remove ourselves here in the paranoia
+	   * that due to things happening above in the callback
+	   * above, we might have been removed, and another added.
+	   */
+	  g_source_remove (range->timer);
+	  range->timer = gtk_timeout_add (SCROLL_LATER_DELAY,
+					  (GtkFunction) RANGE_CLASS (range)->timer,
+					  range);
+	}
+    }
+  
+  gtk_object_unref (GTK_OBJECT (range));
+  
+  return FALSE;  /* don't keep calling this function */
+}
+
+static void
+gtk_range_add_timer (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (!range->timer)
+    {
+      range->need_timer = TRUE;
+      range->timer = gtk_timeout_add (SCROLL_INITIAL_DELAY,
+				      (GtkFunction) gtk_range_timer_1st_time,
+				      range);
+    }
+}
+
+static void
+gtk_range_remove_timer (GtkRange *range)
+{
+  g_return_if_fail (range != NULL);
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (range->timer)
+    {
+      gtk_timeout_remove (range->timer);
+      range->timer = 0;
+    }
+  range->need_timer = FALSE;
+}
+
+static void
+gtk_range_adjustment_changed (GtkAdjustment *adjustment,
+			      gpointer       data)
+{
+  GtkRange *range;
+
+  g_return_if_fail (adjustment != NULL);
+  g_return_if_fail (data != NULL);
+
+  range = GTK_RANGE (data);
+
+  if (((range->old_lower != adjustment->lower) ||
+       (range->old_upper != adjustment->upper) ||
+       (range->old_page_size != adjustment->page_size)) &&
+      (range->old_value == adjustment->value))
+    {
+      if ((adjustment->lower == adjustment->upper) ||
+	  (range->old_lower == (range->old_upper - range->old_page_size)))
+	{
+	  adjustment->value = adjustment->lower;
+	  gtk_signal_emit_by_name (GTK_OBJECT (adjustment), "value_changed");
+	}
+    }
+
+  if ((range->old_value != adjustment->value) ||
+      (range->old_lower != adjustment->lower) ||
+      (range->old_upper != adjustment->upper) ||
+      (range->old_page_size != adjustment->page_size))
+    {
+      gtk_range_slider_update (range);
+      gtk_range_clear_background (range);
+
+      range->old_value = adjustment->value;
+      range->old_lower = adjustment->lower;
+      range->old_upper = adjustment->upper;
+      range->old_page_size = adjustment->page_size;
+    }
+}
+
+static void
+gtk_range_adjustment_value_changed (GtkAdjustment *adjustment,
+				    gpointer       data)
+{
+  GtkRange *range;
+
+  g_return_if_fail (adjustment != NULL);
+  g_return_if_fail (data != NULL);
+
+  range = GTK_RANGE (data);
+
+  if (range->old_value != adjustment->value)
+    {
+      gtk_range_slider_update (range);
+      gtk_range_clear_background (range);
+
+      range->old_value = adjustment->value;
+    }
+}
+
+
+static void
+gtk_range_trough_hdims (GtkRange *range,
+			gint     *left,
+			gint     *right)
+{
+  gint trough_width;
+  gint slider_length;
+  gint tmp_width;
+  gint tleft;
+  gint tright;
+  gint stepper_spacing;
+  gint trough_border;
+
+  g_return_if_fail (range != NULL);
+
+  gdk_window_get_size (range->trough, &trough_width, NULL);
+  gdk_window_get_size (range->slider, &slider_length, NULL);
+
+  _gtk_range_get_props (range, NULL, &trough_border, NULL, &stepper_spacing);
+  
+  tleft = trough_border;
+  tright = trough_width - slider_length - trough_border;
+
+  if (range->step_back)
+    {
+      gdk_window_get_size (range->step_back, &tmp_width, NULL);
+      tleft += (tmp_width + stepper_spacing);
+    }
+
+  if (range->step_forw)
+    {
+      gdk_window_get_size (range->step_forw, &tmp_width, NULL);
+      tright -= (tmp_width + stepper_spacing);
+    }
+
+  if (left)
+    *left = tleft;
+  if (right)
+    *right = tright;
+}
+
+static void
+gtk_range_trough_vdims (GtkRange *range,
+			gint     *top,
+			gint     *bottom)
+{
+  gint trough_height;
+  gint slider_length;
+  gint tmp_height;
+  gint ttop;
+  gint tbottom;
+  gint trough_border;
+  gint stepper_spacing;
+
+  g_return_if_fail (range != NULL);
+
+  _gtk_range_get_props (range, NULL, &trough_border, NULL, &stepper_spacing);
+  
+  gdk_window_get_size (range->trough, NULL, &trough_height);
+  gdk_window_get_size (range->slider, NULL, &slider_length);
+
+  ttop = trough_border;
+  tbottom = trough_height - slider_length - trough_border;
+
+  if (range->step_back)
+    {
+      gdk_window_get_size (range->step_back, NULL, &tmp_height);
+      ttop += (tmp_height + stepper_spacing);
+    }
+
+  if (range->step_forw)
+    {
+      gdk_window_get_size (range->step_forw, NULL, &tmp_height);
+      tbottom -= (tmp_height + stepper_spacing);
+    }
+
+  if (top)
+    *top = ttop;
+  if (bottom)
+    *bottom = tbottom;
+}
+
+static void
+gtk_range_style_set (GtkWidget *widget,
+		      GtkStyle  *previous_style)
+{
+  GtkRange *range;
+
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_RANGE (widget));
+
+  range = GTK_RANGE (widget);
+
+  if (GTK_WIDGET_REALIZED (widget))
+    {
+      if (range->trough)
+	gtk_style_set_background (widget->style, range->trough, GTK_STATE_ACTIVE);
+
+      if (range->slider)
+	gtk_style_set_background (widget->style, range->slider, GTK_STATE_NORMAL);
+      
+      /* The backgrounds of the step_forw and step_back never actually
+       * get drawn in draw calls, so we call gdk_window_clear() here
+       * so they get the correct colors. This is a hack. OWT.
+       */
+
+      if (range->step_forw)
+	{
+	  gtk_style_set_background (widget->style, range->step_forw, GTK_STATE_ACTIVE);
+	  gdk_window_clear (range->step_forw);
+	}
+
+      if (range->step_back)
+	{
+	  gtk_style_set_background (widget->style, range->step_back, GTK_STATE_ACTIVE);
+	  gdk_window_clear (range->step_back);
+	}
+    }
+}
+
+void
+_gtk_range_get_props (GtkRange *range,
+		      gint     *slider_width,
+		      gint     *trough_border,
+		      gint     *stepper_size,
+		      gint     *stepper_spacing)
+{
+  GtkWidget *widget =  GTK_WIDGET (range);
+  
+
+  if (slider_width)
+    *slider_width = gtk_style_get_prop_experimental (widget->style,
+						     "GtkRange::slider_width",
+						     RANGE_CLASS (widget)->slider_width);
+  if (trough_border)
+    *trough_border = gtk_style_get_prop_experimental (widget->style,
+						      "GtkRange::trough_border",
+						      widget->style->klass->xthickness);
+  if (stepper_size)
+    *stepper_size = gtk_style_get_prop_experimental (widget->style,
+						     "GtkRange::stepper_size",
+						     RANGE_CLASS (widget)->stepper_size);
+  if (stepper_spacing)
+    *stepper_spacing = gtk_style_get_prop_experimental (widget->style,
+							"GtkRange::stepper_spacing",
+							RANGE_CLASS (widget)->stepper_slider_spacing);
+}
+
diff -uNr a/gtk/gtkrc.c b/gtk/gtkrc.c
--- a/gtk/gtkrc.c	Thu Mar 15 13:41:40 2001
+++ b/gtk/gtkrc.c	Mon May 27 17:48:50 2002
@@ -24,6 +24,7 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+#include <config.h>
 #include <X11/Xlocale.h>	/* so we get the right setlocale */
 #include <ctype.h>
 #include <unistd.h>
@@ -33,6 +34,9 @@
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef HAVE_CODESET
+#include <langinfo.h>
+#endif
 
 #include "gtkrc.h"
 #include "gtkbindings.h"
@@ -440,7 +444,7 @@
 void
 gtk_rc_init (void)
 {
-  static gchar *locale_suffixes[3];
+  static gchar *locale_suffixes[8];
   static gint n_locale_suffixes = 0;
 
   gint i, j;
@@ -449,8 +453,6 @@
 
   if (!initted)
     {
-      gint length;
-      
       char *locale = setlocale (LC_CTYPE, NULL);
       char *p;
       
@@ -470,38 +472,91 @@
 	   * We normalize the charset into a standard form,
 	   * which has all '-' and '_' characters removed,
 	   * and is lowercase.
+	   *
+	   * the search is done in that order:
+	   * gtkrc.ll_cc.lowercasecodeset
+	   * gtkrc.ll_cc.normalizedcodeset
+	   * gtkrc.ll.lowercasecodeset
+	   * gtkrc.ll.normalizedcodeset
+	   * gtkrc.lowercasecodeset
+	   * gtkrc.normalizedcodeset
+	   * gtkrc.ll_cc
+	   * gtkrc.ll
+	   * 
 	   */
-	  gchar *normalized_locale;
+	  char *codeset = NULL;
+	  char *normalized_codeset = NULL;
+	  char *cc = NULL;
+	  char *ll;
+	  char *tmp = NULL;
 
 	  p = strchr (locale, '@');
-	  length = p ? (p -locale) : strlen (locale);
+	  if (p)
+		  *p = '\0';
 
+#ifdef HAVE_CODESET
+	  codeset = nl_langinfo (CODESET);
+#endif
 	  p = strchr (locale, '.');
+	  if ((codeset==NULL) && (p))
+		  codeset = p+1;
 	  if (p)
-	    {
-	      gchar *tmp1 = g_strndup (locale, p - locale + 1);
-	      gchar *tmp2 = _gtk_normalize_codeset (p + 1, length - (p - locale + 1));
-	      
-	      normalized_locale = g_strconcat (tmp1, tmp2, NULL);
-	      g_free (tmp1);
-	      g_free (tmp2);
-						 
-	      locale_suffixes[n_locale_suffixes++] = g_strdup (normalized_locale);
-	      length = p - locale;
-	    }
-	  else
-	    normalized_locale = g_strndup (locale, length);
+		  *p = '\0';
 	  
-	  p = strchr (normalized_locale, '_');
-	  if (p)
+	  if (codeset)
 	    {
-	      locale_suffixes[n_locale_suffixes++] = g_strndup (normalized_locale, length);
-	      length = p - normalized_locale;
+		/* if codeset is the result of nl_langinfo() it is
+		 * read-only so we need to copy it to a rw place */
+		tmp = g_strdup(codeset);
+		p = tmp;
+		    
+	  	while (*p)
+	          {
+		      /* tolower not used, because some locales are not
+		       * compatible with C locale in lowercasing ascii */
+		      if (*p >= 'A' && *p <= 'Z')
+			      *p = (*p)-'A'+'a';
+		      p++;
+		  }
+		codeset = tmp;
+		normalized_codeset =
+		       	_gtk_normalize_codeset(codeset, strlen(codeset));
+		if (strcmp(normalized_codeset,codeset) == 0)
+			normalized_codeset = NULL;
 	    }
-	  
-	  locale_suffixes[n_locale_suffixes++] = g_strndup (normalized_locale, length);
 
-	  g_free (normalized_locale);
+	  p = strchr (locale, '_');
+	  if (p) {
+		  cc = p+1;
+		  *p = '\0';
+	  }
+
+	  ll = locale;	
+	
+	  if (cc && codeset)
+	    locale_suffixes[n_locale_suffixes++] =
+	        g_strdup ( g_strconcat(ll,"_",cc,".",codeset,NULL));
+          if (cc && normalized_codeset)
+	    locale_suffixes[n_locale_suffixes++] =
+	        g_strdup ( g_strconcat(ll,"_",cc,".",normalized_codeset,NULL));
+	  if (codeset)
+            locale_suffixes[n_locale_suffixes++] =
+                g_strdup ( g_strconcat(ll,".",codeset,NULL));
+          if (normalized_codeset)
+	    locale_suffixes[n_locale_suffixes++] =
+	        g_strdup ( g_strconcat(ll,".",normalized_codeset,NULL));
+	  if (codeset)
+	    locale_suffixes[n_locale_suffixes++] = 
+		g_strdup ( codeset );
+	  if (normalized_codeset)
+	    locale_suffixes[n_locale_suffixes++] =
+	        g_strdup ( normalized_codeset );
+	  if (cc)
+            locale_suffixes[n_locale_suffixes++] =
+	        g_strdup ( g_strconcat(ll,"_",cc,NULL));
+	  locale_suffixes[n_locale_suffixes++] = g_strdup ( ll );
+
+	  if (tmp) g_free (tmp);
 	}
     }
   
diff -uNr a/gtk/gtkstyle.c b/gtk/gtkstyle.c
--- a/gtk/gtkstyle.c	Tue Feb 20 11:46:58 2001
+++ b/gtk/gtkstyle.c	Mon May 27 17:47:20 2002
@@ -2255,8 +2255,7 @@
   else if (height == -1)
     gdk_window_get_size (window, NULL, &height);
   
-  if (!style->bg_pixmap[state_type] || 
-      gdk_window_get_type (window) == GDK_WINDOW_PIXMAP)
+  if (!style->bg_pixmap[state_type])
     {
       if (area)
 	gdk_gc_set_clip_rectangle (style->bg_gc[state_type], area);
@@ -2327,8 +2326,7 @@
   else
     gc1 = style->bg_gc[state_type];
   
-  if (!style->bg_pixmap[state_type] || gc1 != style->bg_gc[state_type] ||
-      gdk_window_get_type (window) == GDK_WINDOW_PIXMAP)
+  if (!style->bg_pixmap[state_type] || gc1 != style->bg_gc[state_type])
     {
       if (area)
 	gdk_gc_set_clip_rectangle (gc1, area);
diff -uNr a/gtk/gtktypeutils.h b/gtk/gtktypeutils.h
--- a/gtk/gtktypeutils.h	Fri Aug 18 17:36:34 2000
+++ b/gtk/gtktypeutils.h	Mon May 27 17:48:50 2002
@@ -191,6 +191,13 @@
   GtkTypeClass	*klass;
 };
 
+#ifdef __GNUC__
+struct _GtkTypeClassDummyAlign
+{
+  GtkType type;
+  guint *signals;
+};
+#endif /* __GNUC__ */
 
 /* A GtkTypeClass defines the minimum structure requirements for
  * a types class. Classes returned from gtk_type_class () and
@@ -203,7 +210,11 @@
    *  one unique identifier per class.
    */
   GtkType type;
-};
+}
+#ifdef __GNUC__
+__attribute__ ((aligned (__alignof (struct _GtkTypeClassDummyAlign))))
+#endif /* __GNUC__ */
+;
 
 
 struct _GtkArg
diff -uNr a/gtk/gtkwindow.c b/gtk/gtkwindow.c
--- a/gtk/gtkwindow.c	Fri Mar  9 18:39:16 2001
+++ b/gtk/gtkwindow.c	Mon May 27 17:48:50 2002
@@ -985,7 +985,13 @@
       break;
     case EnterNotify:
     case LeaveNotify:
-      if (xev->xcrossing.detail != NotifyInferior &&
+      /* We only track the actual destination of keyboard events for real
+       * toplevels, not for embedded toplevels such as GtkPlug. The reason for
+       * this is that GtkPlug redirects events so the widget may effectively not
+       * have the focus even if it actually has the focus.
+       */
+      if (gdk_window_get_parent (GTK_WIDGET (window)->window) == GDK_ROOT_PARENT () &&
+	  xev->xcrossing.detail != NotifyInferior &&
 	  xev->xcrossing.focus && !window->window_has_focus)
 	{
 	  window->window_has_pointer_focus = (xev->xany.type == EnterNotify) ? TRUE : FALSE;
diff -uNr a/gtk/testdnd.c b/gtk/testdnd.c
--- a/gtk/testdnd.c	Tue Apr  6 14:50:38 1999
+++ b/gtk/testdnd.c	Mon May 27 17:48:50 2002
@@ -312,6 +312,7 @@
       gtk_pixmap_set (GTK_PIXMAP (widget), trashcan_open, trashcan_open_mask);
     }
 
+
   source_widget = gtk_drag_get_source_widget (context);
   g_print("motion, source %s\n", source_widget ?
 	    gtk_type_name (GTK_OBJECT (source_widget)->klass->type) :
@@ -328,11 +329,20 @@
 			    gint                y,
 			    guint               time)
 {
+  GList *tmp_list;
+  
   g_print("drop\n");
   have_drag = FALSE;
 
   gtk_pixmap_set (GTK_PIXMAP (widget), trashcan_closed, trashcan_closed_mask);
 
+  tmp_list = context->targets;
+  while (tmp_list)
+    {
+      g_print ("%s\n", gdk_atom_name (GPOINTER_TO_UINT (tmp_list->data)));
+      tmp_list = tmp_list->next;
+    }
+
   if (context->targets)
     {
       gtk_drag_get_data (widget, context, 
diff -uNr a/po/ChangeLog b/po/ChangeLog
--- a/po/ChangeLog	Tue Mar 27 15:12:43 2001
+++ b/po/ChangeLog	Mon May 27 17:48:50 2002
@@ -1,3 +1,30 @@
+2001-08-14  Abel Cheung  <maddog@linux.org.hk>
+          
+	* zh_TW.Big5.po: Updated traditional Chinese translation.
+	* zh_CN.GB2312.po: Updated simplified Chinese translation,
+	  and added header.
+
+2001-08-09  Zbigniew Chyla  <cyba@gnome.pl>
+          
+	* pl.po: Updated Polish translation.
+
+2001-08-01  Peteris Krisjanis  <peterisk@apollo.lv>
+
+	* lv.po: Added Latvian translation.
+
+2001-07-24  Darin Adler  <darin@bentspoon.com>
+
+	* ta.po: Placeholder empty Tamil translation to make
+	things build until the real translation is committed.
+
+2001-07-18  Zbigniew Chyla  <cyba@gnome.pl>
+          
+	* pl.po: Updated Polish translation.
+
+2001-06-26  Fatih Demir <kabalak@gtranslator.org>
+
+	* ta.po: Added Tamil translation by Dinesh.
+
 2001-03-27  Ole Laursen  <olau@hardworking.dk>
 
 	* da.po: Updated and fixed some issues in the Danish translation.
diff -uNr a/po/ko.po b/po/ko.po
--- a/po/ko.po	Sun Apr  1 23:14:09 2001
+++ b/po/ko.po	Mon May 27 17:48:50 2002
@@ -3,10 +3,10 @@
 # Sung-Hyun Nam <namsh@lgic.co.kr>, 2000
 msgid ""
 msgstr ""
-"Project-Id-Version: gtk+ 1.2.9\n"
-"POT-Creation-Date: 2001-03-28 16:12-0500\n"
-"PO-Revision-Date: 2001-02-08 16:48+0900\n"
-"Last-Translator: Sung-Hyun Nam <namsh@kldp.org>\n"
+"Project-Id-Version: gtk+ 1.2.10\n"
+"POT-Creation-Date: 2001-04-02 15:33+0900\n"
+"PO-Revision-Date: 2001-04-12 09:52+0900\n"
+"Last-Translator: Nam SungHyun <namsh@kldp.org>\n"
 "Language-Team: Korean <ko@li.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=euc-kr\n"
diff -uNr a/po/pl.po b/po/pl.po
--- a/po/pl.po	Sun Apr  1 23:14:09 2001
+++ b/po/pl.po	Mon May 27 17:48:50 2002
@@ -1,83 +1,91 @@
+# Copyright (C) 2001 Free Software Foundation, Inc.
+# -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+# Aktualn wersj tego pliku moesz odnale w repozytorium cvs.gnome.pl
+# (:pserver:anonymous@cvs.gnome.pl:/home/cvs, puste haso)
+# Jeli masz jakiekolwiek uwagi odnoszce si do tumaczenia lub chcesz
+# pomc w jego rozwijaniu i pielgnowaniu, napisz do nas na adres:
+# translators@gnome.pl
+# -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 msgid ""
 msgstr ""
 "Project-Id-Version: gtk+\n"
-"POT-Creation-Date: 2001-03-28 16:12-0500\n"
-"PO-Revision-Date: 1999-07-23 14:45+CET\n"
-"Last-Translator: GNOME PL Team\n"
-"Language-Team: Polish <gnomepl@pandora.info.bielsko.pl>\n"
+"POT-Creation-Date: 2001-08-09 13:42+0200\n"
+"PO-Revision-Date: 2001-08-09 13:37+0200\n"
+"Last-Translator: GNOME PL Team <translators@gnome.pl>\n"
+"Language-Team: Polish <pl@li.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=iso-8859-2\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: gtk/gtkcolorsel.c:221
+#: gtk/gtkcolorsel.c:1
 msgid "Hue:"
 msgstr "Odcie:"
 
-#: gtk/gtkcolorsel.c:222
+#: gtk/gtkcolorsel.c:1
 msgid "Saturation:"
 msgstr "Nasycenie:"
 
-#: gtk/gtkcolorsel.c:223
+#: gtk/gtkcolorsel.c:1
 msgid "Value:"
 msgstr "Warto:"
 
-#: gtk/gtkcolorsel.c:224
+#: gtk/gtkcolorsel.c:1
 msgid "Red:"
 msgstr "Czerwony:"
 
-#: gtk/gtkcolorsel.c:225
+#: gtk/gtkcolorsel.c:1
 msgid "Green:"
 msgstr "Zielony:"
 
-#: gtk/gtkcolorsel.c:226
+#: gtk/gtkcolorsel.c:1
 msgid "Blue:"
 msgstr "Niebieski:"
 
-#: gtk/gtkcolorsel.c:227
+#: gtk/gtkcolorsel.c:1
 msgid "Opacity:"
-msgstr "Przeroczysto:"
+msgstr "Nieprzepuszczalno:"
 
 #. The OK button
-#: gtk/gtkcolorsel.c:1727 gtk/gtkfilesel.c:481 gtk/gtkfontsel.c:3501
-#: gtk/gtkgamma.c:416
+#: gtk/gtkcolorsel.c:1 gtk/gtkfilesel.c:1 gtk/gtkfontsel.c:1
+#: gtk/gtkgamma.c:1
 msgid "OK"
 msgstr "OK"
 
 #. The Cancel button
-#: gtk/gtkcolorsel.c:1733 gtk/gtkfilesel.c:488 gtk/gtkfilesel.c:868
-#: gtk/gtkfilesel.c:968 gtk/gtkfilesel.c:1083 gtk/gtkfontsel.c:3514
-#: gtk/gtkgamma.c:424
+#: gtk/gtkcolorsel.c:1 gtk/gtkfilesel.c:1 gtk/gtkfilesel.c:1
+#: gtk/gtkfilesel.c:1 gtk/gtkfilesel.c:1 gtk/gtkfontsel.c:1
+#: gtk/gtkgamma.c:1
 msgid "Cancel"
 msgstr "Anuluj"
 
-#: gtk/gtkcolorsel.c:1738
+#: gtk/gtkcolorsel.c:1
 msgid "Help"
 msgstr "Pomoc"
 
 #. The directories clist
-#: gtk/gtkfilesel.c:430
+#: gtk/gtkfilesel.c:1
 msgid "Directories"
 msgstr "Katalogi"
 
 #. The files clist
-#: gtk/gtkfilesel.c:449
+#: gtk/gtkfilesel.c:1
 msgid "Files"
 msgstr "Pliki"
 
-#: gtk/gtkfilesel.c:519 gtk/gtkfilesel.c:1478
+#: gtk/gtkfilesel.c:1 gtk/gtkfilesel.c:1
 #, c-format
 msgid "Directory unreadable: %s"
 msgstr "Nie mona odczyta katalogu: %s"
 
-#: gtk/gtkfilesel.c:551
+#: gtk/gtkfilesel.c:1
 msgid "Create Dir"
-msgstr "Utwrz katalog"
+msgstr "Stwrz katalog"
 
-#: gtk/gtkfilesel.c:562 gtk/gtkfilesel.c:937
+#: gtk/gtkfilesel.c:1 gtk/gtkfilesel.c:1
 msgid "Delete File"
 msgstr "Usu plik"
 
-#: gtk/gtkfilesel.c:573 gtk/gtkfilesel.c:1041
+#: gtk/gtkfilesel.c:1 gtk/gtkfilesel.c:1
 msgid "Rename File"
 msgstr "Zmie nazw"
 
@@ -86,377 +94,377 @@
 #. (GtkSignalFunc) gtk_file_selection_fileop_destroy,
 #. (gpointer) fs);
 #.
-#: gtk/gtkfilesel.c:734
+#: gtk/gtkfilesel.c:1
 msgid "Error"
 msgstr "Bd"
 
 #. close button
-#: gtk/gtkfilesel.c:757 gtk/gtkinputdialog.c:354
+#: gtk/gtkfilesel.c:1 gtk/gtkinputdialog.c:1
 msgid "Close"
 msgstr "Zamknij"
 
-#: gtk/gtkfilesel.c:832
+#: gtk/gtkfilesel.c:1
 msgid "Create Directory"
-msgstr "Utwrz katalog"
+msgstr "Nowy katalog"
 
-#: gtk/gtkfilesel.c:846
+#: gtk/gtkfilesel.c:1
 msgid "Directory name:"
 msgstr "Nazwa katalogu:"
 
 #. buttons
-#: gtk/gtkfilesel.c:859
+#: gtk/gtkfilesel.c:1
 msgid "Create"
 msgstr "Utwrz"
 
 #. buttons
-#: gtk/gtkfilesel.c:959
+#: gtk/gtkfilesel.c:1
 msgid "Delete"
 msgstr "Usu"
 
 #. buttons
-#: gtk/gtkfilesel.c:1074
+#: gtk/gtkfilesel.c:1
 msgid "Rename"
 msgstr "Zmie nazw"
 
-#: gtk/gtkfilesel.c:1457
+#: gtk/gtkfilesel.c:1
 msgid "Selection: "
 msgstr "Wybr: "
 
-#: gtk/gtkfontsel.c:210
+#: gtk/gtkfontsel.c:1
 msgid "Foundry:"
 msgstr "Druk:"
 
-#: gtk/gtkfontsel.c:211
+#: gtk/gtkfontsel.c:1
 msgid "Family:"
 msgstr "Rodzina:"
 
-#: gtk/gtkfontsel.c:212
+#: gtk/gtkfontsel.c:1
 msgid "Weight:"
 msgstr "Pogrubienie:"
 
-#: gtk/gtkfontsel.c:213
+#: gtk/gtkfontsel.c:1
 msgid "Slant:"
 msgstr "Nachylenie:"
 
-#: gtk/gtkfontsel.c:214
+#: gtk/gtkfontsel.c:1
 msgid "Set Width:"
 msgstr "Ustaw szeroko:"
 
-#: gtk/gtkfontsel.c:215
+#: gtk/gtkfontsel.c:1
 msgid "Add Style:"
 msgstr "Dodaj styl:"
 
-#: gtk/gtkfontsel.c:216
+#: gtk/gtkfontsel.c:1
 msgid "Pixel Size:"
 msgstr "Rozmiar w pikselach:"
 
-#: gtk/gtkfontsel.c:217
+#: gtk/gtkfontsel.c:1
 msgid "Point Size:"
 msgstr "Rozmiar w punktach:"
 
-#: gtk/gtkfontsel.c:218
+#: gtk/gtkfontsel.c:1
 msgid "Resolution X:"
 msgstr "Rozdzielczo pozioma:"
 
-#: gtk/gtkfontsel.c:219
+#: gtk/gtkfontsel.c:1
 msgid "Resolution Y:"
 msgstr "Rozdzielczo pionowa:"
 
-#: gtk/gtkfontsel.c:220
+#: gtk/gtkfontsel.c:1
 msgid "Spacing:"
 msgstr "Odstpy:"
 
-#: gtk/gtkfontsel.c:221
+#: gtk/gtkfontsel.c:1
 msgid "Average Width:"
 msgstr "rednia szeroko:"
 
-#: gtk/gtkfontsel.c:222
+#: gtk/gtkfontsel.c:1
 msgid "Charset:"
 msgstr "Kodowanie:"
 
 #. Number of internationalized titles here must match number
 #. of NULL initializers above
-#: gtk/gtkfontsel.c:459
+#: gtk/gtkfontsel.c:1
 msgid "Font Property"
 msgstr "Waciwo czcionki"
 
-#: gtk/gtkfontsel.c:460
+#: gtk/gtkfontsel.c:1
 msgid "Requested Value"
 msgstr "dana warto"
 
-#: gtk/gtkfontsel.c:461
+#: gtk/gtkfontsel.c:1
 msgid "Actual Value"
 msgstr "Rzeczywista warto"
 
-#: gtk/gtkfontsel.c:494
+#: gtk/gtkfontsel.c:1
 msgid "Font"
 msgstr "Czcionka"
 
-#: gtk/gtkfontsel.c:504 gtk/gtkfontsel.c:2180 gtk/gtkfontsel.c:2410
+#: gtk/gtkfontsel.c:1 gtk/gtkfontsel.c:1 gtk/gtkfontsel.c:1
 msgid "Font:"
 msgstr "Czcionka:"
 
-#: gtk/gtkfontsel.c:509
+#: gtk/gtkfontsel.c:1
 msgid "Font Style:"
 msgstr "Styl czcionki:"
 
-#: gtk/gtkfontsel.c:514
+#: gtk/gtkfontsel.c:1
 msgid "Size:"
 msgstr "Rozmiar:"
 
-#: gtk/gtkfontsel.c:646 gtk/gtkfontsel.c:868
+#: gtk/gtkfontsel.c:1 gtk/gtkfontsel.c:1
 msgid "Reset Filter"
 msgstr "Wyczy filtr"
 
-#: gtk/gtkfontsel.c:660
+#: gtk/gtkfontsel.c:1
 msgid "Metric:"
 msgstr "Jednostki:"
 
-#: gtk/gtkfontsel.c:664
+#: gtk/gtkfontsel.c:1
 msgid "Points"
 msgstr "Punkty"
 
-#: gtk/gtkfontsel.c:671
+#: gtk/gtkfontsel.c:1
 msgid "Pixels"
 msgstr "Piksele"
 
 #. create the text entry widget
-#: gtk/gtkfontsel.c:687
+#: gtk/gtkfontsel.c:1
 msgid "Preview:"
 msgstr "Podgld"
 
-#: gtk/gtkfontsel.c:716
+#: gtk/gtkfontsel.c:1
 msgid "Font Information"
 msgstr "Informacje o czcionce"
 
-#: gtk/gtkfontsel.c:749
+#: gtk/gtkfontsel.c:1
 msgid "Requested Font Name:"
 msgstr "dana nazwa czcionki:"
 
-#: gtk/gtkfontsel.c:760
+#: gtk/gtkfontsel.c:1
 msgid "Actual Font Name:"
 msgstr "Rzeczywista nazwa czcionki:"
 
-#: gtk/gtkfontsel.c:771
+#: gtk/gtkfontsel.c:1
 #, c-format
 msgid "%i fonts available with a total of %i styles."
 msgstr "dostpnych czcionek: %i, liczba stylw : %i."
 
-#: gtk/gtkfontsel.c:786
+#: gtk/gtkfontsel.c:1
 msgid "Filter"
 msgstr "Filtr"
 
-#: gtk/gtkfontsel.c:799
+#: gtk/gtkfontsel.c:1
 msgid "Font Types:"
 msgstr "Typy czcionek:"
 
-#: gtk/gtkfontsel.c:807
+#: gtk/gtkfontsel.c:1
 msgid "Bitmap"
 msgstr "Bitmapowe"
 
-#: gtk/gtkfontsel.c:813
+#: gtk/gtkfontsel.c:1
 msgid "Scalable"
 msgstr "Skalowalne"
 
-#: gtk/gtkfontsel.c:819
+#: gtk/gtkfontsel.c:1
 msgid "Scaled Bitmap"
 msgstr "Skalowane bitmapy"
 
-#: gtk/gtkfontsel.c:890
+#: gtk/gtkfontsel.c:1
 msgid "*"
 msgstr "*"
 
 #. Convert '(nil)' weights to 'regular', since it looks nicer.
-#: gtk/gtkfontsel.c:1215
+#: gtk/gtkfontsel.c:1
 msgid "(nil)"
 msgstr "(pusty)"
 
-#: gtk/gtkfontsel.c:1215
+#: gtk/gtkfontsel.c:1
 msgid "regular"
 msgstr "zwyke"
 
-#: gtk/gtkfontsel.c:1220 gtk/gtkfontsel.c:1972
+#: gtk/gtkfontsel.c:1 gtk/gtkfontsel.c:1
 msgid "italic"
 msgstr "italic"
 
-#: gtk/gtkfontsel.c:1221 gtk/gtkfontsel.c:1973
+#: gtk/gtkfontsel.c:1 gtk/gtkfontsel.c:1
 msgid "oblique"
 msgstr "pochylona"
 
-#: gtk/gtkfontsel.c:1222 gtk/gtkfontsel.c:1974
+#: gtk/gtkfontsel.c:1 gtk/gtkfontsel.c:1
 msgid "reverse italic"
 msgstr "odwrcony italic"
 
-#: gtk/gtkfontsel.c:1223 gtk/gtkfontsel.c:1975
+#: gtk/gtkfontsel.c:1 gtk/gtkfontsel.c:1
 msgid "reverse oblique"
 msgstr "odwrotnie pochylona"
 
-#: gtk/gtkfontsel.c:1224 gtk/gtkfontsel.c:1976
+#: gtk/gtkfontsel.c:1 gtk/gtkfontsel.c:1
 msgid "other"
 msgstr "inne"
 
-#: gtk/gtkfontsel.c:1231
+#: gtk/gtkfontsel.c:1
 msgid "[M]"
 msgstr "[M]"
 
-#: gtk/gtkfontsel.c:1232
+#: gtk/gtkfontsel.c:1
 msgid "[C]"
 msgstr "[C]"
 
-#: gtk/gtkfontsel.c:1792
+#: gtk/gtkfontsel.c:1
 msgid "The selected font is not available."
 msgstr "Wybrana czcionka nie jest dostpna."
 
-#: gtk/gtkfontsel.c:1798
+#: gtk/gtkfontsel.c:1
 msgid "The selected font is not a valid font."
 msgstr "Wybrana czcionka nie jest poprawna."
 
-#: gtk/gtkfontsel.c:1856
+#: gtk/gtkfontsel.c:1
 msgid "This is a 2-byte font and may not be displayed correctly."
 msgstr "Ta 2-bajtowa czcionka moe nie by wywietlana poprawnie."
 
-#: gtk/gtkfontsel.c:1960 gtk/gtkinputdialog.c:607
+#: gtk/gtkfontsel.c:1 gtk/gtkinputdialog.c:1
 msgid "(unknown)"
 msgstr "(nieznane)"
 
-#: gtk/gtkfontsel.c:1971
+#: gtk/gtkfontsel.c:1
 msgid "roman"
 msgstr "roman"
 
-#: gtk/gtkfontsel.c:1983
+#: gtk/gtkfontsel.c:1
 msgid "proportional"
 msgstr "proporcjonalne"
 
-#: gtk/gtkfontsel.c:1984
+#: gtk/gtkfontsel.c:1
 msgid "monospaced"
 msgstr "rwnomierne"
 
-#: gtk/gtkfontsel.c:1985
+#: gtk/gtkfontsel.c:1
 msgid "char cell"
 msgstr "rozmiaru znaku"
 
-#: gtk/gtkfontsel.c:2185
+#: gtk/gtkfontsel.c:1
 msgid "Font: (Filter Applied)"
 msgstr "Czcionka: (z zastosowaniem filtra)"
 
-#: gtk/gtkfontsel.c:2661
+#: gtk/gtkfontsel.c:1
 msgid "MAX_FONTS exceeded. Some fonts may be missing."
 msgstr "Przekroczono warto MAX_FONTS. Moe brakowa pewnych czcionek."
 
-#: gtk/gtkfontsel.c:3508
+#: gtk/gtkfontsel.c:1
 msgid "Apply"
 msgstr "Zastosuj"
 
-#: gtk/gtkfontsel.c:3530
+#: gtk/gtkfontsel.c:1
 msgid "Font Selection"
 msgstr "Wybr czcionki"
 
-#: gtk/gtkgamma.c:396
+#: gtk/gtkgamma.c:1
 msgid "Gamma"
 msgstr "Gamma"
 
-#: gtk/gtkgamma.c:403
+#: gtk/gtkgamma.c:1
 msgid "Gamma value"
 msgstr "Warto gamma"
 
 #. shell and main vbox
-#: gtk/gtkinputdialog.c:200
+#: gtk/gtkinputdialog.c:1
 msgid "Input"
 msgstr "Wejcie"
 
-#: gtk/gtkinputdialog.c:208
+#: gtk/gtkinputdialog.c:1
 msgid "No input devices"
 msgstr "Brak urzdze wejciowych"
 
-#: gtk/gtkinputdialog.c:237
+#: gtk/gtkinputdialog.c:1
 msgid "Device:"
 msgstr "Urzdzenie:"
 
-#: gtk/gtkinputdialog.c:253
+#: gtk/gtkinputdialog.c:1
 msgid "Disabled"
 msgstr "Wyczone"
 
-#: gtk/gtkinputdialog.c:261
+#: gtk/gtkinputdialog.c:1
 msgid "Screen"
 msgstr "Ekran"
 
-#: gtk/gtkinputdialog.c:269
+#: gtk/gtkinputdialog.c:1
 msgid "Window"
 msgstr "Okno"
 
-#: gtk/gtkinputdialog.c:277
+#: gtk/gtkinputdialog.c:1
 msgid "Mode: "
 msgstr "Tryb: "
 
 #. The axis listbox
-#: gtk/gtkinputdialog.c:307
+#: gtk/gtkinputdialog.c:1
 msgid "Axes"
 msgstr "Osie"
 
 #. Keys listbox
-#: gtk/gtkinputdialog.c:323
+#: gtk/gtkinputdialog.c:1
 msgid "Keys"
 msgstr "Klawisze"
 
 #. We create the save button in any case, so that clients can
 #. connect to it, without paying attention to whether it exits
-#: gtk/gtkinputdialog.c:345
+#: gtk/gtkinputdialog.c:1
 msgid "Save"
 msgstr "Zapisz"
 
-#: gtk/gtkinputdialog.c:500
+#: gtk/gtkinputdialog.c:1
 msgid "X"
 msgstr "X"
 
-#: gtk/gtkinputdialog.c:501
+#: gtk/gtkinputdialog.c:1
 msgid "Y"
 msgstr "Y"
 
-#: gtk/gtkinputdialog.c:502
+#: gtk/gtkinputdialog.c:1
 msgid "Pressure"
 msgstr "Nacisk"
 
-#: gtk/gtkinputdialog.c:503
+#: gtk/gtkinputdialog.c:1
 msgid "X Tilt"
 msgstr "Nachylenie poziome"
 
-#: gtk/gtkinputdialog.c:504
+#: gtk/gtkinputdialog.c:1
 msgid "Y Tilt"
 msgstr "Nachylenie pionowe"
 
-#: gtk/gtkinputdialog.c:544
+#: gtk/gtkinputdialog.c:1
 msgid "none"
 msgstr "brak"
 
-#: gtk/gtkinputdialog.c:578 gtk/gtkinputdialog.c:614
+#: gtk/gtkinputdialog.c:1 gtk/gtkinputdialog.c:1
 msgid "(disabled)"
-msgstr "(wyczone)"
+msgstr "(nieaktywne)"
 
 #. and clear button
-#: gtk/gtkinputdialog.c:692
+#: gtk/gtkinputdialog.c:1
 msgid "clear"
 msgstr "wyczy"
 
-#: gtk/gtknotebook.c:2059 gtk/gtknotebook.c:4131
+#: gtk/gtknotebook.c:1 gtk/gtknotebook.c:1
 #, c-format
 msgid "Page %u"
 msgstr "Strona %u"
 
-#: gtk/gtkrc.c:1703
+#: gtk/gtkrc.c:1
 #, c-format
 msgid "Unable to locate image file in pixmap_path: \"%s\" line %d"
-msgstr "Nie mona odnale pliku z obrazem na ciece: \"%s\" wiersz %d"
+msgstr "Nie mona odnale pliku z obrazem pod pixmap_path: \"%s\" wiersz %d"
 
-#: gtk/gtkrc.c:1706
+#: gtk/gtkrc.c:1
 #, c-format
 msgid "Unable to locate image file in pixmap_path: \"%s\""
-msgstr "Nie mona odnale pliku z obrazem na ciece: \"%s\""
+msgstr "Nie mona odnale pliku z obrazem pod pixmap_path: \"%s\""
 
-#: gtk/gtkthemes.c:79
+#: gtk/gtkthemes.c:1
 #, c-format
 msgid "Unable to locate loadable module in module_path: \"%s\","
-msgstr "Nie mona odnale moduu adowalnego na ciece: \"%s\","
+msgstr "Nie mona odnale moduu adowalnego pod module_path: \"%s\","
 
-#: gtk/gtktipsquery.c:180
+#: gtk/gtktipsquery.c:1
 msgid "--- No Tip ---"
 msgstr "--- Brak podpowiedzi ---"
diff -uNr a/po/sl.po b/po/sl.po
--- a/po/sl.po	Sun Apr  1 23:14:09 2001
+++ b/po/sl.po	Mon May 27 17:48:50 2002
@@ -4,7 +4,7 @@
 msgid ""
 msgstr ""
 "Project-Id-Version: GTK+ 1.2.8\n"
-"POT-Creation-Date: 2001-03-28 16:12-0500\n"
+"POT-Creation-Date: 2000-05-19 07:11+0200\n"
 "PO-Revision-Date: 2000-06-21 19:45+0200\n"
 "Last-Translator: Miha Tomi <miha.tomsic@guest.arnes.si>\n"
 "Language-Team: slovenian <sl@li.org>\n"
@@ -41,14 +41,14 @@
 msgstr "Neprosojnost:"
 
 #. The OK button
-#: gtk/gtkcolorsel.c:1727 gtk/gtkfilesel.c:481 gtk/gtkfontsel.c:3501
+#: gtk/gtkcolorsel.c:1727 gtk/gtkfilesel.c:469 gtk/gtkfontsel.c:3492
 #: gtk/gtkgamma.c:416
 msgid "OK"
 msgstr "Potrdi"
 
 #. The Cancel button
-#: gtk/gtkcolorsel.c:1733 gtk/gtkfilesel.c:488 gtk/gtkfilesel.c:868
-#: gtk/gtkfilesel.c:968 gtk/gtkfilesel.c:1083 gtk/gtkfontsel.c:3514
+#: gtk/gtkcolorsel.c:1733 gtk/gtkfilesel.c:476 gtk/gtkfilesel.c:856
+#: gtk/gtkfilesel.c:956 gtk/gtkfilesel.c:1071 gtk/gtkfontsel.c:3505
 #: gtk/gtkgamma.c:424
 msgid "Cancel"
 msgstr "Preklii"
@@ -58,29 +58,29 @@
 msgstr "Pomo"
 
 #. The directories clist
-#: gtk/gtkfilesel.c:430
+#: gtk/gtkfilesel.c:418
 msgid "Directories"
 msgstr "Imeniki"
 
 #. The files clist
-#: gtk/gtkfilesel.c:449
+#: gtk/gtkfilesel.c:437
 msgid "Files"
 msgstr "Datoteke"
 
-#: gtk/gtkfilesel.c:519 gtk/gtkfilesel.c:1478
+#: gtk/gtkfilesel.c:507 gtk/gtkfilesel.c:1466
 #, c-format
 msgid "Directory unreadable: %s"
 msgstr "Neberljiv imenik: %s"
 
-#: gtk/gtkfilesel.c:551
+#: gtk/gtkfilesel.c:539
 msgid "Create Dir"
 msgstr "Ustvari imenik"
 
-#: gtk/gtkfilesel.c:562 gtk/gtkfilesel.c:937
+#: gtk/gtkfilesel.c:550 gtk/gtkfilesel.c:925
 msgid "Delete File"
 msgstr "Zbrii datoteko"
 
-#: gtk/gtkfilesel.c:573 gtk/gtkfilesel.c:1041
+#: gtk/gtkfilesel.c:561 gtk/gtkfilesel.c:1029
 msgid "Rename File"
 msgstr "Preimenuj datoteko"
 
@@ -89,39 +89,39 @@
 #. (GtkSignalFunc) gtk_file_selection_fileop_destroy,
 #. (gpointer) fs);
 #.
-#: gtk/gtkfilesel.c:734
+#: gtk/gtkfilesel.c:722
 msgid "Error"
 msgstr "Napaka"
 
 #. close button
-#: gtk/gtkfilesel.c:757 gtk/gtkinputdialog.c:354
+#: gtk/gtkfilesel.c:745 gtk/gtkinputdialog.c:354
 msgid "Close"
 msgstr "Zapri"
 
-#: gtk/gtkfilesel.c:832
+#: gtk/gtkfilesel.c:820
 msgid "Create Directory"
 msgstr "Ustvari imenik"
 
-#: gtk/gtkfilesel.c:846
+#: gtk/gtkfilesel.c:834
 msgid "Directory name:"
 msgstr "Ime imenika:"
 
 #. buttons
-#: gtk/gtkfilesel.c:859
+#: gtk/gtkfilesel.c:847
 msgid "Create"
 msgstr "Ustvari"
 
 #. buttons
-#: gtk/gtkfilesel.c:959
+#: gtk/gtkfilesel.c:947
 msgid "Delete"
 msgstr "Zbrii"
 
 #. buttons
-#: gtk/gtkfilesel.c:1074
+#: gtk/gtkfilesel.c:1062
 msgid "Rename"
 msgstr "Preimenuj"
 
-#: gtk/gtkfilesel.c:1457
+#: gtk/gtkfilesel.c:1445
 msgid "Selection: "
 msgstr "Izbira: "
 
@@ -195,7 +195,7 @@
 msgid "Font"
 msgstr "Pisava"
 
-#: gtk/gtkfontsel.c:504 gtk/gtkfontsel.c:2180 gtk/gtkfontsel.c:2410
+#: gtk/gtkfontsel.c:504 gtk/gtkfontsel.c:2181 gtk/gtkfontsel.c:2411
 msgid "Font:"
 msgstr "Pisava:"
 
@@ -278,23 +278,23 @@
 msgid "regular"
 msgstr "navadno"
 
-#: gtk/gtkfontsel.c:1220 gtk/gtkfontsel.c:1972
+#: gtk/gtkfontsel.c:1220 gtk/gtkfontsel.c:1973
 msgid "italic"
 msgstr "kurzivna"
 
-#: gtk/gtkfontsel.c:1221 gtk/gtkfontsel.c:1973
+#: gtk/gtkfontsel.c:1221 gtk/gtkfontsel.c:1974
 msgid "oblique"
 msgstr "nagnjena"
 
-#: gtk/gtkfontsel.c:1222 gtk/gtkfontsel.c:1974
+#: gtk/gtkfontsel.c:1222 gtk/gtkfontsel.c:1975
 msgid "reverse italic"
 msgstr "obratno kurzivna"
 
-#: gtk/gtkfontsel.c:1223 gtk/gtkfontsel.c:1975
+#: gtk/gtkfontsel.c:1223 gtk/gtkfontsel.c:1976
 msgid "reverse oblique"
 msgstr "obratno nagnjena"
 
-#: gtk/gtkfontsel.c:1224 gtk/gtkfontsel.c:1976
+#: gtk/gtkfontsel.c:1224 gtk/gtkfontsel.c:1977
 msgid "other"
 msgstr "ostalo"
 
@@ -306,51 +306,51 @@
 msgid "[C]"
 msgstr "[C]"
 
-#: gtk/gtkfontsel.c:1792
+#: gtk/gtkfontsel.c:1793
 msgid "The selected font is not available."
 msgstr "Izbrana pisava ni dostopna."
 
-#: gtk/gtkfontsel.c:1798
+#: gtk/gtkfontsel.c:1799
 msgid "The selected font is not a valid font."
 msgstr "Izbrana pisava je popaena."
 
-#: gtk/gtkfontsel.c:1856
+#: gtk/gtkfontsel.c:1857
 msgid "This is a 2-byte font and may not be displayed correctly."
 msgstr "Ta pisava uporablja dvobajtni zapis in morda ne bo prikazana pravilno."
 
-#: gtk/gtkfontsel.c:1960 gtk/gtkinputdialog.c:607
+#: gtk/gtkfontsel.c:1961 gtk/gtkinputdialog.c:607
 msgid "(unknown)"
 msgstr "(neznano)"
 
-#: gtk/gtkfontsel.c:1971
+#: gtk/gtkfontsel.c:1972
 msgid "roman"
 msgstr "pokonna"
 
-#: gtk/gtkfontsel.c:1983
+#: gtk/gtkfontsel.c:1984
 msgid "proportional"
 msgstr "proporcionalen"
 
-#: gtk/gtkfontsel.c:1984
+#: gtk/gtkfontsel.c:1985
 msgid "monospaced"
 msgstr "enakokoraen"
 
-#: gtk/gtkfontsel.c:1985
+#: gtk/gtkfontsel.c:1986
 msgid "char cell"
 msgstr "celica znaka"
 
-#: gtk/gtkfontsel.c:2185
+#: gtk/gtkfontsel.c:2186
 msgid "Font: (Filter Applied)"
 msgstr "Pisava: (z uporabo filtra)"
 
-#: gtk/gtkfontsel.c:2661
+#: gtk/gtkfontsel.c:2662
 msgid "MAX_FONTS exceeded. Some fonts may be missing."
 msgstr "MAX_FONTS preseen. Nekatere pisave utegnejo manjkati."
 
-#: gtk/gtkfontsel.c:3508
+#: gtk/gtkfontsel.c:3499
 msgid "Apply"
 msgstr "Uporabi"
 
-#: gtk/gtkfontsel.c:3530
+#: gtk/gtkfontsel.c:3521
 msgid "Font Selection"
 msgstr "Izbor pisav"
 
@@ -445,12 +445,12 @@
 msgid "Page %u"
 msgstr "%u. stran"
 
-#: gtk/gtkrc.c:1703
+#: gtk/gtkrc.c:1702
 #, c-format
 msgid "Unable to locate image file in pixmap_path: \"%s\" line %d"
 msgstr "Ne najdem datoteke s sliko v poti pixmap_path: \"%s\" vrstica %d"
 
-#: gtk/gtkrc.c:1706
+#: gtk/gtkrc.c:1705
 #, c-format
 msgid "Unable to locate image file in pixmap_path: \"%s\""
 msgstr "Ne najdem datoteke s sliko v poti pixmap_path: \"%s\""
diff -uNr a/po/zh_CN.GB2312.po b/po/zh_CN.GB2312.po
--- a/po/zh_CN.GB2312.po	Sun Apr  1 23:14:09 2001
+++ b/po/zh_CN.GB2312.po	Mon May 27 17:48:50 2002
@@ -1,8 +1,12 @@
+# simplified Chinese translation for gtk+
+# Copyright (C) 1999-2001 Free Software Foundation, Inc.
+# Wu Yulun <migr@operamail.com>, 1999.
+# 
 msgid ""
 msgstr ""
-"Project-Id-Version: gtk+ 1.1.7 \n"
+"Project-Id-Version: gtk+ 1.2.10 \n"
 "POT-Creation-Date: 2001-03-28 16:12-0500\n"
-"PO-Revision-Date: 1999-01-31\n"
+"PO-Revision-Date: 2001-08-14 15:59+0800\n"
 "Last-Translator: Wu Yulun <migr@operamail.com>\n"
 "Language-Team: Chinese <zh@li.org>\n"
 "MIME-Version: 1.0\n"
@@ -269,7 +273,7 @@
 #. Convert '(nil)' weights to 'regular', since it looks nicer.
 #: gtk/gtkfontsel.c:1215
 msgid "(nil)"
-msgstr ""
+msgstr "()"
 
 #: gtk/gtkfontsel.c:1215
 msgid "regular"
@@ -297,11 +301,11 @@
 
 #: gtk/gtkfontsel.c:1231
 msgid "[M]"
-msgstr ""
+msgstr "[M]"
 
 #: gtk/gtkfontsel.c:1232
 msgid "[C]"
-msgstr ""
+msgstr "[C]"
 
 #: gtk/gtkfontsel.c:1792
 msgid "The selected font is not available."
@@ -406,11 +410,11 @@
 
 #: gtk/gtkinputdialog.c:500
 msgid "X"
-msgstr ""
+msgstr "X"
 
 #: gtk/gtkinputdialog.c:501
 msgid "Y"
-msgstr ""
+msgstr "Y"
 
 #: gtk/gtkinputdialog.c:502
 msgid "Pressure"
diff -uNr a/po/zh_TW.Big5.po b/po/zh_TW.Big5.po
--- a/po/zh_TW.Big5.po	Sun Apr  1 23:14:09 2001
+++ b/po/zh_TW.Big5.po	Mon May 27 17:48:50 2002
@@ -1,44 +1,45 @@
-# SOME DESCRIPTIVE TITLE.
-# Copyright (C) YEAR Free Software Foundation, Inc.
+# traditional Chinese translation for gtk+
+# Copyright (C) 1999-2001 Free Software Foundation, Inc.
 #  <hsin@med.cgu.edu.tw>, 1999.
+#
 msgid ""
 msgstr ""
-"Project-Id-Version: gtk+ 1.1.7 \n"
-"POT-Creation-Date: 2001-03-28 16:12-0500\n"
-"PO-Revision-Date: 1999-01-31 19:33+0800\n"
-"Last-Translator:  <hsin@med.cgu.edu.tw>\n"
-"Language-Team: Chinese <zh@li.org>\n"
+"Project-Id-Version: gtk+ 1.2.10 \n"
+"POT-Creation-Date: 2001-08-14 15:40+0800\n"
+"PO-Revision-Date: 2001-08-14 15:53+0800\n"
+"Last-Translator: Abel Cheung <maddog@linux.org.hk>\n"
+"Language-Team: traditional Chinese <zh-l10n@linux.org.hk>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=big5\n"
 "Content-Transfer-Encoding: 8bit\n"
 
 #: gtk/gtkcolorsel.c:221
 msgid "Hue:"
-msgstr ":"
+msgstr "G"
 
 #: gtk/gtkcolorsel.c:222
 msgid "Saturation:"
-msgstr "m:"
+msgstr "mG"
 
 #: gtk/gtkcolorsel.c:223
 msgid "Value:"
-msgstr ":"
+msgstr "G"
 
 #: gtk/gtkcolorsel.c:224
 msgid "Red:"
-msgstr ":"
+msgstr "G"
 
 #: gtk/gtkcolorsel.c:225
 msgid "Green:"
-msgstr ":"
+msgstr "G"
 
 #: gtk/gtkcolorsel.c:226
 msgid "Blue:"
-msgstr ":"
+msgstr "G"
 
 #: gtk/gtkcolorsel.c:227
 msgid "Opacity:"
-msgstr "z:"
+msgstr "zG"
 
 #. The OK button
 #: gtk/gtkcolorsel.c:1727 gtk/gtkfilesel.c:481 gtk/gtkfontsel.c:3501
@@ -55,7 +56,7 @@
 
 #: gtk/gtkcolorsel.c:1738
 msgid "Help"
-msgstr "DU"
+msgstr ""
 
 #. The directories clist
 #: gtk/gtkfilesel.c:430
@@ -70,11 +71,11 @@
 #: gtk/gtkfilesel.c:519 gtk/gtkfilesel.c:1478
 #, c-format
 msgid "Directory unreadable: %s"
-msgstr "Lk: %s"
+msgstr "LkG%s"
 
 #: gtk/gtkfilesel.c:551
 msgid "Create Dir"
-msgstr "sW"
+msgstr ""
 
 #: gtk/gtkfilesel.c:562 gtk/gtkfilesel.c:937
 msgid "Delete File"
@@ -82,7 +83,7 @@
 
 #: gtk/gtkfilesel.c:573 gtk/gtkfilesel.c:1041
 msgid "Rename File"
-msgstr "sRW"
+msgstr "W"
 
 #.
 #. gtk_signal_connect (GTK_OBJECT (dialog), "destroy",
@@ -100,16 +101,16 @@
 
 #: gtk/gtkfilesel.c:832
 msgid "Create Directory"
-msgstr "sW"
+msgstr ""
 
 #: gtk/gtkfilesel.c:846
 msgid "Directory name:"
-msgstr "W:"
+msgstr "WG"
 
 #. buttons
 #: gtk/gtkfilesel.c:859
 msgid "Create"
-msgstr "sW"
+msgstr ""
 
 #. buttons
 #: gtk/gtkfilesel.c:959
@@ -119,69 +120,69 @@
 #. buttons
 #: gtk/gtkfilesel.c:1074
 msgid "Rename"
-msgstr "s"
+msgstr "W"
 
 #: gtk/gtkfilesel.c:1457
 msgid "Selection: "
-msgstr "r: "
+msgstr "G"
 
 #: gtk/gtkfontsel.c:210
 msgid "Foundry:"
-msgstr ":"
+msgstr "G"
 
 #: gtk/gtkfontsel.c:211
 msgid "Family:"
-msgstr "r:"
+msgstr "rG"
 
 #: gtk/gtkfontsel.c:212
 msgid "Weight:"
-msgstr "jp:"
+msgstr "jpG"
 
 #: gtk/gtkfontsel.c:213
 msgid "Slant:"
-msgstr ":"
+msgstr "G"
 
 #: gtk/gtkfontsel.c:214
 msgid "Set Width:"
-msgstr "e:"
+msgstr "eG"
 
 #: gtk/gtkfontsel.c:215
 msgid "Add Style:"
-msgstr "W[:"
+msgstr "W[G"
 
 #: gtk/gtkfontsel.c:216
 msgid "Pixel Size:"
-msgstr "jp:"
+msgstr "jpG"
 
 #: gtk/gtkfontsel.c:217
 msgid "Point Size:"
-msgstr "I}jp:"
+msgstr "I}jpG"
 
 #: gtk/gtkfontsel.c:218
 msgid "Resolution X:"
-msgstr "X R:"
+msgstr "X RG"
 
 #: gtk/gtkfontsel.c:219
 msgid "Resolution Y:"
-msgstr "Y R:"
+msgstr "Y RG"
 
 #: gtk/gtkfontsel.c:220
 msgid "Spacing:"
-msgstr "Z:"
+msgstr "ZG"
 
 #: gtk/gtkfontsel.c:221
 msgid "Average Width:"
-msgstr "e:"
+msgstr "eG"
 
 #: gtk/gtkfontsel.c:222
 msgid "Charset:"
-msgstr "r:"
+msgstr "rG"
 
 #. Number of internationalized titles here must match number
 #. of NULL initializers above
 #: gtk/gtkfontsel.c:459
 msgid "Font Property"
-msgstr "r"
+msgstr "rS"
 
 #: gtk/gtkfontsel.c:460
 msgid "Requested Value"
@@ -197,15 +198,15 @@
 
 #: gtk/gtkfontsel.c:504 gtk/gtkfontsel.c:2180 gtk/gtkfontsel.c:2410
 msgid "Font:"
-msgstr "r:"
+msgstr "rG"
 
 #: gtk/gtkfontsel.c:509
 msgid "Font Style:"
-msgstr "r:"
+msgstr "rG"
 
 #: gtk/gtkfontsel.c:514
 msgid "Size:"
-msgstr "jp:"
+msgstr "jpG"
 
 #: gtk/gtkfontsel.c:646 gtk/gtkfontsel.c:868
 msgid "Reset Filter"
@@ -213,7 +214,7 @@
 
 #: gtk/gtkfontsel.c:660
 msgid "Metric:"
-msgstr "q:"
+msgstr "qG"
 
 #: gtk/gtkfontsel.c:664
 msgid "Points"
@@ -226,7 +227,7 @@
 #. create the text entry widget
 #: gtk/gtkfontsel.c:687
 msgid "Preview:"
-msgstr "w:"
+msgstr "wG"
 
 #: gtk/gtkfontsel.c:716
 msgid "Font Information"
@@ -234,16 +235,16 @@
 
 #: gtk/gtkfontsel.c:749
 msgid "Requested Font Name:"
-msgstr "nDrW:"
+msgstr "nDrWG"
 
 #: gtk/gtkfontsel.c:760
 msgid "Actual Font Name:"
-msgstr "rW:"
+msgstr "rWG"
 
 #: gtk/gtkfontsel.c:771
 #, c-format
 msgid "%i fonts available with a total of %i styles."
-msgstr " %i r(@ %i )"
+msgstr " %i riA@ %i C"
 
 #: gtk/gtkfontsel.c:786
 msgid "Filter"
@@ -251,7 +252,7 @@
 
 #: gtk/gtkfontsel.c:799
 msgid "Font Types:"
-msgstr "r:"
+msgstr "rG"
 
 #: gtk/gtkfontsel.c:807
 msgid "Bitmap"
@@ -272,7 +273,7 @@
 #. Convert '(nil)' weights to 'regular', since it looks nicer.
 #: gtk/gtkfontsel.c:1215
 msgid "(nil)"
-msgstr ""
+msgstr "(L)"
 
 #: gtk/gtkfontsel.c:1215
 msgid "regular"
@@ -300,11 +301,11 @@
 
 #: gtk/gtkfontsel.c:1231
 msgid "[M]"
-msgstr ""
+msgstr "[M]"
 
 #: gtk/gtkfontsel.c:1232
 msgid "[C]"
-msgstr ""
+msgstr "[C]"
 
 #: gtk/gtkfontsel.c:1792
 msgid "The selected font is not available."
@@ -328,11 +329,11 @@
 
 #: gtk/gtkfontsel.c:1983
 msgid "proportional"
-msgstr ""
+msgstr ""
 
 #: gtk/gtkfontsel.c:1984
 msgid "monospaced"
-msgstr "we"
+msgstr "Twe"
 
 #: gtk/gtkfontsel.c:1985
 msgid "char cell"
@@ -340,11 +341,11 @@
 
 #: gtk/gtkfontsel.c:2185
 msgid "Font: (Filter Applied)"
-msgstr "r: (Lo)"
+msgstr "rG(MLo)"
 
 #: gtk/gtkfontsel.c:2661
 msgid "MAX_FONTS exceeded. Some fonts may be missing."
-msgstr "wWX MAX_FONTS ,iYrC"
+msgstr "wWX MAX_FONTSAiYrC"
 
 #: gtk/gtkfontsel.c:3508
 msgid "Apply"
@@ -369,11 +370,11 @@
 
 #: gtk/gtkinputdialog.c:208
 msgid "No input devices"
-msgstr "Jm"
+msgstr "SJm"
 
 #: gtk/gtkinputdialog.c:237
 msgid "Device:"
-msgstr "m:"
+msgstr "mG"
 
 #: gtk/gtkinputdialog.c:253
 msgid "Disabled"
@@ -389,7 +390,7 @@
 
 #: gtk/gtkinputdialog.c:277
 msgid "Mode: "
-msgstr ":"
+msgstr "G"
 
 #. The axis listbox
 #: gtk/gtkinputdialog.c:307
@@ -399,7 +400,7 @@
 #. Keys listbox
 #: gtk/gtkinputdialog.c:323
 msgid "Keys"
-msgstr "s"
+msgstr ""
 
 #. We create the save button in any case, so that clients can
 #. connect to it, without paying attention to whether it exits
@@ -409,11 +410,11 @@
 
 #: gtk/gtkinputdialog.c:500
 msgid "X"
-msgstr ""
+msgstr "X"
 
 #: gtk/gtkinputdialog.c:501
 msgid "Y"
-msgstr ""
+msgstr "Y"
 
 #: gtk/gtkinputdialog.c:502
 msgid "Pressure"
@@ -445,21 +446,21 @@
 msgid "Page %u"
 msgstr " %u "
 
-#: gtk/gtkrc.c:1703
+#: gtk/gtkrc.c:1758
 #, c-format
 msgid "Unable to locate image file in pixmap_path: \"%s\" line %d"
-msgstr "Lk pixmap_path : \"%s\"  %d "
+msgstr "Lk pixmap_path G\"%s\"  %d "
 
-#: gtk/gtkrc.c:1706
+#: gtk/gtkrc.c:1761
 #, c-format
 msgid "Unable to locate image file in pixmap_path: \"%s\""
-msgstr "Lk pixmap_path : \"%s\""
+msgstr "Lk pixmap_path G\"%s\""
 
 #: gtk/gtkthemes.c:79
 #, c-format
 msgid "Unable to locate loadable module in module_path: \"%s\","
-msgstr "Lk module_path iJ: \"%s\","
+msgstr "Lk module_path iJG\"%s\"A"
 
 #: gtk/gtktipsquery.c:180
 msgid "--- No Tip ---"
-msgstr "--- wL ---"
+msgstr "--- L ---"
