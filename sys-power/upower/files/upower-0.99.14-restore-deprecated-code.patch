diff -urN a/Makefile.am b/Makefile.am
--- a/Makefile.am	2013-10-29 06:37:01.000000000 -0400
+++ b/Makefile.am	2015-05-18 11:32:17.178249882 -0400
@@ -2,7 +2,7 @@
 
 ACLOCAL_AMFLAGS = -I m4 ${ACLOCAL_FLAGS}
 
-SUBDIRS = etc libupower-glib src doc tools po
+SUBDIRS = etc libupower-glib src doc tools policy po
 
 if BACKEND_TYPE_LINUX
 SUBDIRS += rules
diff -urN a/configure.ac b/configure.ac
--- a/configure.ac	2014-12-18 04:31:57.000000000 -0500
+++ b/configure.ac	2015-05-18 11:32:17.178249882 -0400
@@ -155,6 +155,7 @@
 PKG_CHECK_MODULES(GLIB, [glib-2.0 >= 2.34.0])
 PKG_CHECK_MODULES(DBUS, [dbus-1 >= 1.0])
 PKG_CHECK_MODULES(DBUS_GLIB, [dbus-glib-1 >= 0.76])
+PKG_CHECK_MODULES(POLKIT, polkit-gobject-1 >= 0.97)
 PKG_CHECK_MODULES(GIO, [gio-2.0 >= 2.16.1])
 PKG_CHECK_MODULES(GIO_UNIX, [gio-unix-2.0])
 
@@ -254,6 +255,7 @@
 doc/version.xml
 doc/man/Makefile
 doc/dbus/Makefile
+policy/Makefile
 rules/Makefile
 libupower-glib/Makefile
 libupower-glib/up-version.h
diff -urN a/doc/man/UPower.xml b/doc/man/UPower.xml
--- a/doc/man/UPower.xml	2014-07-17 03:46:15.000000000 -0400
+++ b/doc/man/UPower.xml	2015-05-18 11:32:17.178249882 -0400
@@ -22,7 +22,8 @@
       on the system and control system-wide power management. Any
       application can access
       the <emphasis>org.freedesktop.UPower</emphasis> service
-      on the system message bus.
+      on the system message bus. Some operations (such as suspending
+      the system) is restricted using PolicyKit.
     </para>
   </refsect1>
 
diff -urN a/etc/UPower.conf b/etc/UPower.conf
--- a/etc/UPower.conf	2014-05-08 03:27:51.000000000 -0400
+++ b/etc/UPower.conf	2015-05-18 11:32:17.178249882 -0400
@@ -3,6 +3,29 @@
 
 [UPower]
 
+# This is the smallest amount of time that UPower gives to session and system
+# processes after the suspend or hibernate request is given.
+# If the session power management component uses AboutToSuspend() then the
+# session process can only make this time larger than the value below, never
+# smaller.
+#
+# Reducing this time means the suspend happens quicker, but might also not give
+# some processes enough time to save state.
+#
+# default=1000
+SleepTimeout=1000
+
+# This controls whether hibernate is allowed when using encrypted swap.
+#
+# default=true
+AllowHibernateEncryptedSwap=true
+
+# This controls whether we want the powersave commands to be run when running
+# on battery or plugging AC.
+#
+# default=true
+RunPowersaveCommand=true
+
 # Enable the Watts Up Pro device.
 #
 # The Watts Up Pro contains a generic FTDI USB device without a specific
diff -urN a/libupower-glib/Makefile.am b/libupower-glib/Makefile.am
--- a/libupower-glib/Makefile.am	2013-10-29 06:37:01.000000000 -0400
+++ b/libupower-glib/Makefile.am	2015-05-18 11:32:17.178249882 -0400
@@ -1,5 +1,6 @@
 AM_CPPFLAGS = \
 	$(GLIB_CFLAGS)						\
+	$(DBUS_GLIB_CFLAGS)					\
 	$(GIO_UNIX_CFLAGS)					\
 	-I$(top_builddir)					\
 	-I$(top_srcdir)						\
@@ -82,6 +83,7 @@
 libupower_glib_la_LIBADD =					\
 	$(INTLLIBS)						\
 	$(GLIB_LIBS)						\
+	$(DBUS_GLIB_LIBS)					\
 	$(GIO_UNIX_LIBS)
 
 libupower_glib_la_LDFLAGS =					\
diff -urN a/libupower-glib/up-client.c b/libupower-glib/up-client.c
--- a/libupower-glib/up-client.c	2014-05-08 03:27:51.000000000 -0400
+++ b/libupower-glib/up-client.c	2015-05-18 11:32:17.179249876 -0400
@@ -35,6 +35,11 @@
 #include <stdio.h>
 #include <glib-object.h>
 
+#ifdef ENABLE_DEPRECATED
+#include <glib.h>
+#include <dbus/dbus-glib.h>
+#endif /* ENABLE_DEPRECATED */
+
 #include "up-client.h"
 #include "up-client-glue.h"
 #include "up-device.h"
@@ -53,20 +58,40 @@
 struct _UpClientPrivate
 {
 	UpClientGlue		*proxy;
+#ifdef ENABLE_DEPRECATED
+	DBusGConnection		*bus;
+	DBusGProxy		*old_proxy;
+	DBusGProxy		*prop_proxy;
+	gboolean		 have_properties;
+	gboolean		 can_suspend;
+	gboolean		 can_hibernate;
+	gboolean		 lid_force_sleep;
+#endif /* ENABLE_DEPRECATED */
 };
 
 enum {
 	UP_CLIENT_DEVICE_ADDED,
 	UP_CLIENT_DEVICE_REMOVED,
+#ifdef ENABLE_DEPRECATED
+	UP_CLIENT_NOTIFY_SLEEP,
+	UP_CLIENT_NOTIFY_RESUME,
+#endif /* ENABLE_DEPRECATED */
 	UP_CLIENT_LAST_SIGNAL
 };
 
 enum {
 	PROP_0,
 	PROP_DAEMON_VERSION,
+#ifdef ENABLE_DEPRECATED
+	PROP_CAN_SUSPEND,
+	PROP_CAN_HIBERNATE,
+#endif /* ENABLE_DEPRECATED */
 	PROP_ON_BATTERY,
 	PROP_LID_IS_CLOSED,
 	PROP_LID_IS_PRESENT,
+#ifdef ENABLE_DEPRECATED
+	PROP_LID_FORCE_SLEEP,
+#endif /* ENABLE_DEPRECATED */
 	PROP_LAST
 };
 
@@ -174,6 +199,233 @@
 	return action;
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_client_suspend_sync:
+ * @client: a #UpClient instance.
+ * @cancellable: a #GCancellable or %NULL
+ * @error: a #GError, or %NULL.
+ *
+ * Puts the computer into a low power state, but state is not preserved if the
+ * power is lost.
+ *
+ * NOTE: The system is still consuming a small amount of power
+ *
+ * Return value: TRUE if system suspended okay, FALSE other wise.
+ *
+ * Since: 0.9.0
+ **/
+gboolean
+up_client_suspend_sync (UpClient *client, GCancellable *cancellable, GError **error)
+{
+	gboolean ret;
+	GError *error_local = NULL;
+
+	g_return_val_if_fail (UP_IS_CLIENT (client), FALSE);
+	g_return_val_if_fail (client->priv->old_proxy != NULL, FALSE);
+
+	ret = dbus_g_proxy_call (client->priv->old_proxy, "Suspend", &error_local,
+				 G_TYPE_INVALID, G_TYPE_INVALID);
+	if (!ret) {
+		/* DBus might time out, which is okay */
+		if (g_error_matches (error_local, DBUS_GERROR, DBUS_GERROR_NO_REPLY)) {
+			g_debug ("DBUS timed out, but recovering");
+			ret = TRUE;
+			goto out;
+		}
+
+		/* an actual error */
+		g_warning ("Couldn't suspend: %s", error_local->message);
+		g_set_error (error, 1, 0, "%s", error_local->message);
+	}
+out:
+	if (error_local != NULL)
+		g_error_free (error_local);
+	return ret;
+}
+
+/**
+ * up_client_hibernate_sync:
+ * @client: a #UpClient instance.
+ * @cancellable: a #GCancellable or %NULL
+ * @error: a #GError.
+ *
+ * Puts the computer into a low power state, where state is preserved if the
+ * power is lost.
+ *
+ * Return value: TRUE if system suspended okay, FALSE other wise.
+ *
+ * Since: 0.9.0
+ **/
+gboolean
+up_client_hibernate_sync (UpClient *client, GCancellable *cancellable, GError **error)
+{
+	gboolean ret;
+	GError *error_local = NULL;
+
+	g_return_val_if_fail (UP_IS_CLIENT (client), FALSE);
+	g_return_val_if_fail (client->priv->old_proxy != NULL, FALSE);
+
+	ret = dbus_g_proxy_call (client->priv->old_proxy, "Hibernate", &error_local,
+				 G_TYPE_INVALID, G_TYPE_INVALID);
+	if (!ret) {
+		/* DBus might time out, which is okay */
+		if (g_error_matches (error_local, DBUS_GERROR, DBUS_GERROR_NO_REPLY)) {
+			g_debug ("DBUS timed out, but recovering");
+			ret = TRUE;
+			goto out;
+		}
+
+		/* an actual error */
+		g_warning ("Couldn't hibernate: %s", error_local->message);
+		g_set_error (error, 1, 0, "%s", error_local->message);
+	}
+out:
+	if (error_local != NULL)
+		g_error_free (error_local);
+	return ret;
+}
+
+/**
+ * up_client_about_to_sleep_sync:
+ * @client: a #UpClient instance.
+ * @sleep_kind: a sleep type, e.g. %UP_SLEEP_KIND_SUSPEND
+ * @cancellable: a #GCancellable or %NULL
+ * @error: a #GError, or %NULL.
+ *
+ * Tells UPower that we are soon to reqest either Suspend() or Hibernate()
+ * and that session and system components should be notified of this.
+ *
+ * Return value: TRUE if system suspended okay, FALSE other wise.
+ *
+ * Since: 0.9.11
+ **/
+gboolean
+up_client_about_to_sleep_sync (UpClient *client,
+			       UpSleepKind sleep_kind,
+			       GCancellable *cancellable,
+			       GError **error)
+{
+	gboolean ret;
+	GError *error_local = NULL;
+
+	g_return_val_if_fail (UP_IS_CLIENT (client), FALSE);
+	g_return_val_if_fail (client->priv->old_proxy != NULL, FALSE);
+
+	ret = dbus_g_proxy_call (client->priv->old_proxy, "AboutToSleep", &error_local,
+				 G_TYPE_STRING, up_sleep_kind_to_string (sleep_kind),
+				 G_TYPE_INVALID,
+				 G_TYPE_INVALID);
+	if (!ret) {
+		/* DBus might time out, which is okay */
+		if (g_error_matches (error_local, DBUS_GERROR, DBUS_GERROR_NO_REPLY)) {
+			g_debug ("DBUS timed out, but recovering");
+			ret = TRUE;
+			goto out;
+		}
+
+		/* an actual error */
+		g_warning ("Couldn't sent that we were about to sleep: %s", error_local->message);
+		g_set_error (error, 1, 0, "%s", error_local->message);
+	}
+out:
+	if (error_local != NULL)
+		g_error_free (error_local);
+	return ret;
+}
+
+/**
+ * up_client_get_properties_sync:
+ * @client: a #UpClient instance.
+ * @cancellable: a #GCancellable or %NULL
+ * @error: a #GError, or %NULL.
+ *
+ * Get all the properties from UPower daemon.
+ *
+ * Return value: %TRUE for success, else %FALSE.
+ *
+ * Since: 0.9.0
+ **/
+gboolean
+up_client_get_properties_sync (UpClient *client, GCancellable *cancellable, GError **error)
+{
+	gboolean ret = TRUE;
+	gboolean prop_val;
+	GHashTable *props;
+	GValue *value;
+	gboolean allowed = FALSE;
+
+	props = NULL;
+
+	if (client->priv->have_properties)
+		goto out;
+	if (!client->priv->prop_proxy)
+		goto out;
+
+	if (error != NULL)
+		*error = NULL;
+	ret = dbus_g_proxy_call (client->priv->prop_proxy, "GetAll", error,
+				 G_TYPE_STRING, "org.freedesktop.UPower",
+				 G_TYPE_INVALID,
+				 dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &props,
+				 G_TYPE_INVALID);
+	if (!ret)
+		goto out;
+
+	value = g_hash_table_lookup (props, "CanSuspend");
+	if (value == NULL) {
+		g_warning ("No 'CanSuspend' property");
+		goto out;
+	}
+
+	ret = dbus_g_proxy_call (client->priv->old_proxy, "SuspendAllowed", error,
+		G_TYPE_INVALID, G_TYPE_BOOLEAN, &allowed, G_TYPE_INVALID);
+	if (!ret)
+		goto out;
+
+	prop_val = g_value_get_boolean (value) && allowed;
+	if (prop_val != client->priv->can_suspend) {
+		client->priv->can_suspend = prop_val;
+		g_object_notify (G_OBJECT(client), "can-suspend");
+	}
+
+	value = g_hash_table_lookup (props, "CanHibernate");
+	if (value == NULL) {
+		g_warning ("No 'CanHibernate' property");
+		goto out;
+	}
+	ret = dbus_g_proxy_call (client->priv->old_proxy, "HibernateAllowed", error,
+		G_TYPE_INVALID, G_TYPE_BOOLEAN, &allowed, G_TYPE_INVALID);
+	if (!ret)
+		goto out;
+
+	prop_val = g_value_get_boolean (value) && allowed;
+	if (prop_val != client->priv->can_hibernate) {
+		client->priv->can_hibernate = prop_val;
+		g_object_notify (G_OBJECT(client), "can-hibernate");
+	}
+
+	value = g_hash_table_lookup (props, "LidForceSleep");
+	if (value == NULL) {
+		g_warning ("No 'LidForceSleep' property");
+		goto out;
+	}
+	prop_val = g_value_get_boolean (value);
+	if (prop_val != client->priv->lid_force_sleep) {
+		client->priv->lid_force_sleep = prop_val;
+		g_object_notify (G_OBJECT(client), "lid-force-sleep");
+	}
+
+	/* cached */
+	client->priv->have_properties = TRUE;
+
+out:
+	if (props != NULL)
+		g_hash_table_unref (props);
+	return ret;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_client_get_daemon_version:
  * @client: a #UpClient instance.
@@ -191,6 +443,26 @@
 	return up_client_glue_get_daemon_version (client->priv->proxy);
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_client_get_can_hibernate:
+ * @client: a #UpClient instance.
+ *
+ * Get whether the system is able to hibernate.
+ *
+ * Return value: TRUE if system can hibernate, FALSE other wise.
+ *
+ * Since: 0.9.0
+ **/
+gboolean
+up_client_get_can_hibernate (UpClient *client)
+{
+	g_return_val_if_fail (UP_IS_CLIENT (client), FALSE);
+	up_client_get_properties_sync (client, NULL, NULL);
+	return client->priv->can_hibernate;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_client_get_lid_is_closed:
  * @client: a #UpClient instance.
@@ -225,6 +497,44 @@
 	return up_client_glue_get_lid_is_present (client->priv->proxy);
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_client_get_lid_force_sleep:
+ * @client: a #UpClient instance.
+ *
+ * Get whether the laptop has to sleep when the lid is closed.
+ *
+ * Return value: %TRUE if the session has to suspend
+ *
+ * Since: 0.9.9
+ */
+gboolean
+up_client_get_lid_force_sleep (UpClient *client)
+{
+	g_return_val_if_fail (UP_IS_CLIENT (client), FALSE);
+	up_client_get_properties_sync (client, NULL, NULL);
+	return client->priv->lid_force_sleep;
+}
+
+/**
+ * up_client_get_can_suspend:
+ * @client: a #UpClient instance.
+ *
+ * Get whether the system is able to suspend.
+ *
+ * Return value: TRUE if system can suspend, FALSE other wise.
+ *
+ * Since: 0.9.0
+ **/
+gboolean
+up_client_get_can_suspend (UpClient *client)
+{
+	g_return_val_if_fail (UP_IS_CLIENT (client), FALSE);
+	up_client_get_properties_sync (client, NULL, NULL);
+	return client->priv->can_suspend;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_client_get_on_battery:
  * @client: a #UpClient instance.
@@ -286,6 +596,28 @@
 	up_client_add (client, object_path);
 }
 
+#ifdef ENABLE_DEPRECATED
+/*
+ * up_client_notify_sleep_cb:
+ */
+static void
+up_client_notify_sleep_cb (DBusGProxy *old_proxy, const gchar *sleep_kind, UpClient *client)
+{
+	g_signal_emit (client, signals [UP_CLIENT_NOTIFY_SLEEP], 0,
+		       up_sleep_kind_from_string (sleep_kind));
+}
+
+/*
+ * up_client_notify_resume_cb:
+ */
+static void
+up_client_notify_resume_cb (DBusGProxy *old_proxy, const gchar *sleep_kind, UpClient *client)
+{
+	g_signal_emit (client, signals [UP_CLIENT_NOTIFY_RESUME], 0,
+		       up_sleep_kind_from_string (sleep_kind));
+}
+#endif /* ENABLE_DEPRECATED */
+
 /*
  * up_client_removed_cb:
  */
@@ -307,10 +639,22 @@
 	if (client->priv->proxy == NULL)
                 return;
 
+#ifdef ENABLE_DEPRECATED
+	up_client_get_properties_sync (client, NULL, NULL);
+#endif /* ENABLE_DEPRECATED */
+
 	switch (prop_id) {
 	case PROP_DAEMON_VERSION:
 		g_value_set_string (value, up_client_glue_get_daemon_version (client->priv->proxy));
 		break;
+#ifdef ENABLE_DEPRECATED
+	case PROP_CAN_SUSPEND:
+		g_value_set_boolean (value, client->priv->can_suspend);
+		break;
+	case PROP_CAN_HIBERNATE:
+		g_value_set_boolean (value, client->priv->can_hibernate);
+		break;
+#endif /* ENABLE_DEPRECATED */
 	case PROP_ON_BATTERY:
 		g_value_set_boolean (value, up_client_glue_get_on_battery (client->priv->proxy));
 		break;
@@ -320,6 +664,11 @@
 	case PROP_LID_IS_PRESENT:
 		g_value_set_boolean (value, up_client_glue_get_lid_is_present (client->priv->proxy));
 		break;
+#ifdef ENABLE_DEPRECATED
+	case PROP_LID_FORCE_SLEEP:
+		g_value_set_boolean (value, client->priv->lid_force_sleep);
+		break;
+#endif /* ENABLE_DEPRECATED */
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -352,6 +701,38 @@
 							      NULL,
 							      NULL,
 							      G_PARAM_READABLE));
+
+#ifdef ENABLE_DEPRECATED
+	/**
+	 * UpClient:can-suspend:
+	 *
+	 * If the computer can suspend.
+	 *
+	 * Since: 0.9.0
+	 */
+	g_object_class_install_property (object_class,
+					 PROP_CAN_SUSPEND,
+					 g_param_spec_boolean ("can-suspend",
+							       "If the computer can suspend",
+							       NULL,
+							       FALSE,
+							       G_PARAM_READABLE));
+	/**
+	 * UpClient:can-hibernate:
+	 *
+	 * If the computer can hibernate.
+	 *
+	 * Since: 0.9.0
+	 */
+	g_object_class_install_property (object_class,
+					 PROP_CAN_HIBERNATE,
+					 g_param_spec_boolean ("can-hibernate",
+							       "If the computer can hibernate",
+							       NULL,
+							       FALSE,
+							       G_PARAM_READABLE));
+#endif /* ENABLE_DEPRECATED */
+
 	/**
 	 * UpClient:on-battery:
 	 *
@@ -395,6 +776,23 @@
 							       FALSE,
 							       G_PARAM_READABLE));
 
+#ifdef ENABLE_DEPRECATED
+	/**
+	 * UpClient:lid-force-sleep:
+	 *
+	 * If a laptop has to sleep if the lid is closed.
+	 *
+	 * Since: 0.9.9
+	 */
+	g_object_class_install_property (object_class,
+					 PROP_LID_FORCE_SLEEP,
+					 g_param_spec_boolean ("lid-force-sleep",
+							       "If a laptop has to sleep on lid close",
+							       NULL,
+							       FALSE,
+							       G_PARAM_READABLE));
+#endif /* ENABLE_DEPRECATED */
+
 	/**
 	 * UpClient::device-added:
 	 * @client: the #UpClient instance that emitted the signal
@@ -427,6 +825,44 @@
 			      NULL, NULL, g_cclosure_marshal_VOID__STRING,
 			      G_TYPE_NONE, 1, G_TYPE_STRING);
 
+#ifdef ENABLE_DEPRECATED
+	/**
+	 * UpClient::notify-sleep:
+	 * @client: the #UpClient instance that emitted the signal
+	 * @sleep_kind: the #UpSleepKind
+	 *
+	 * The ::notify-sleep signal is emitted when system sleep is
+	 * about to occur. Applications have about 1 second to do
+	 * anything they need to do. There is no way to stop the sleep
+	 * process.
+	 *
+	 * Since: 0.9.11
+	 **/
+	signals [UP_CLIENT_NOTIFY_SLEEP] =
+		g_signal_new ("notify-sleep",
+			      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (UpClientClass, notify_sleep),
+			      NULL, NULL, g_cclosure_marshal_VOID__UINT,
+			      G_TYPE_NONE, 1, G_TYPE_UINT);
+
+	/**
+	 * UpClient::notify-resume:
+	 * @client: the #UpClient instance that emitted the signal
+	 * @sleep_kind: the #UpSleepKind
+	 *
+	 * The ::notify-resume signal is emitted when the system has
+	 * resumed.
+	 *
+	 * Since: 0.9.11
+	 **/
+	signals [UP_CLIENT_NOTIFY_RESUME] =
+		g_signal_new ("notify-resume",
+			      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (UpClientClass, notify_resume),
+			      NULL, NULL, g_cclosure_marshal_VOID__UINT,
+			      G_TYPE_NONE, 1, G_TYPE_UINT);
+#endif /* ENABLE_DEPRECATED */
+
 	g_type_class_add_private (klass, sizeof (UpClientPrivate));
 }
 
@@ -454,6 +890,41 @@
 		return;
 	}
 
+#ifdef ENABLE_DEPRECATED
+	/* get on the bus */
+	client->priv->bus = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+	if (client->priv->bus == NULL) {
+		g_warning ("Couldn't connect to system bus: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+
+	/* connect to old main interface */
+	client->priv->old_proxy = dbus_g_proxy_new_for_name (client->priv->bus,
+							 "org.freedesktop.UPower",
+							 "/org/freedesktop/UPower",
+							 "org.freedesktop.UPower");
+	if (client->priv->old_proxy == NULL) {
+		g_warning ("Couldn't connect to proxy: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+
+	/* connect to properties interface */
+	client->priv->prop_proxy = dbus_g_proxy_new_for_name (client->priv->bus,
+							      "org.freedesktop.UPower",
+							      "/org/freedesktop/UPower",
+							      "org.freedesktop.DBus.Properties");
+	if (client->priv->prop_proxy == NULL) {
+		g_warning ("Couldn't connect to proxy: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+
+	dbus_g_proxy_add_signal (client->priv->old_proxy, "NotifySleep", G_TYPE_STRING, G_TYPE_INVALID);
+	dbus_g_proxy_add_signal (client->priv->old_proxy, "NotifyResume", G_TYPE_STRING, G_TYPE_INVALID);
+#endif /* ENABLE_DEPRECATED */
+
 	/* all callbacks */
 	g_signal_connect (client->priv->proxy, "device-added",
 			  G_CALLBACK (up_device_added_cb), client);
@@ -461,6 +932,12 @@
 			  G_CALLBACK (up_device_removed_cb), client);
 	g_signal_connect (client->priv->proxy, "notify",
 			  G_CALLBACK (up_client_notify_cb), client);
+#ifdef ENABLE_DEPRECATED
+	dbus_g_proxy_connect_signal (client->priv->old_proxy, "NotifySleep",
+				     G_CALLBACK (up_client_notify_sleep_cb), client, NULL);
+	dbus_g_proxy_connect_signal (client->priv->old_proxy, "NotifyResume",
+				     G_CALLBACK (up_client_notify_resume_cb), client, NULL);
+#endif /* ENABLE_DEPRECATED */
 }
 
 /*
@@ -478,6 +955,17 @@
 	if (client->priv->proxy != NULL)
 		g_object_unref (client->priv->proxy);
 
+#ifdef ENABLE_DEPRECATED
+	if (client->priv->bus)
+		dbus_g_connection_unref (client->priv->bus);
+
+	if (client->priv->old_proxy != NULL)
+		g_object_unref (client->priv->old_proxy);
+
+	if (client->priv->prop_proxy != NULL)
+		g_object_unref (client->priv->prop_proxy);
+#endif /* ENABLE_DEPRECATED */
+
 	G_OBJECT_CLASS (up_client_parent_class)->finalize (object);
 }
 
diff -urN a/libupower-glib/up-client.h b/libupower-glib/up-client.h
--- a/libupower-glib/up-client.h	2014-05-08 03:27:51.000000000 -0400
+++ b/libupower-glib/up-client.h	2015-05-18 11:32:17.179249876 -0400
@@ -57,6 +57,12 @@
 							 UpDevice		*device);
 	void			(*device_removed)	(UpClient		*client,
 							 const gchar		*object_path);
+	/* FIXME: remove when we next break API */
+	void			(*notify_sleep)		(UpClient		*client,
+							 UpSleepKind		 sleep_kind);
+	/* FIXME: remove when we next break API */
+	void			(*notify_resume)	(UpClient		*client,
+							 UpSleepKind		 sleep_kind);
 	/*< private >*/
 	/* Padding for future expansion */
 	void (*_up_client_reserved1) (void);
@@ -76,12 +82,28 @@
 /* sync versions */
 UpDevice *	 up_client_get_display_device		(UpClient *client);
 char *		 up_client_get_critical_action		(UpClient *client);
+gboolean	 up_client_get_properties_sync		(UpClient		*client,
+							 GCancellable		*cancellable,
+							 GError			**error);
+gboolean	 up_client_suspend_sync			(UpClient		*client,
+							 GCancellable		*cancellable,
+							 GError			**error);
+gboolean	 up_client_about_to_sleep_sync		(UpClient		*client,
+							 UpSleepKind		 sleep_kind,
+							 GCancellable		*cancellable,
+							 GError			**error);
+gboolean	 up_client_hibernate_sync		(UpClient		*client,
+							 GCancellable		*cancellable,
+							 GError			**error);
 
 /* accessors */
 GPtrArray	*up_client_get_devices			(UpClient		*client);
 const gchar	*up_client_get_daemon_version		(UpClient		*client);
+gboolean	 up_client_get_can_hibernate		(UpClient		*client);
 gboolean	 up_client_get_lid_is_closed		(UpClient		*client);
 gboolean	 up_client_get_lid_is_present		(UpClient		*client);
+gboolean	 up_client_get_lid_force_sleep		(UpClient		*client);
+gboolean	 up_client_get_can_suspend		(UpClient		*client);
 gboolean	 up_client_get_on_battery		(UpClient		*client);
 
 G_END_DECLS
diff -urN a/libupower-glib/up-types.c b/libupower-glib/up-types.c
--- a/libupower-glib/up-types.c	2013-10-29 06:37:01.000000000 -0400
+++ b/libupower-glib/up-types.c	2015-05-18 11:32:17.179249876 -0400
@@ -292,3 +292,58 @@
 		return UP_DEVICE_LEVEL_ACTION;
 	return UP_DEVICE_LEVEL_UNKNOWN;
 }
+
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_sleep_kind_to_string:
+ *
+ * Converts a #UpSleepKind to a string.
+ *
+ * Return value: identifier string
+ *
+ * Since: 0.9.10
+ **/
+const gchar *
+up_sleep_kind_to_string (UpSleepKind sleep_kind_enum)
+{
+	const gchar *sleep_kind = NULL;
+	switch (sleep_kind_enum) {
+	case UP_SLEEP_KIND_SUSPEND:
+		sleep_kind = "suspend";
+		break;
+	case UP_SLEEP_KIND_HIBERNATE:
+		sleep_kind = "hibernate";
+		break;
+	case UP_SLEEP_KIND_HYBRID:
+		sleep_kind = "hybrid";
+		break;
+	default:
+		sleep_kind = "unknown";
+		break;
+	}
+	return sleep_kind;
+}
+
+/**
+ * up_sleep_kind_from_string:
+ *
+ * Converts a string to a #UpSleepKind.
+ *
+ * Return value: enumerated value
+ *
+ * Since: 0.9.10
+ **/
+UpSleepKind
+up_sleep_kind_from_string (const gchar *sleep_kind)
+{
+	if (sleep_kind == NULL)
+		return UP_SLEEP_KIND_UNKNOWN;
+	if (g_strcmp0 (sleep_kind, "suspend") == 0)
+		return UP_SLEEP_KIND_SUSPEND;
+	if (g_strcmp0 (sleep_kind, "hibernate") == 0)
+		return UP_SLEEP_KIND_HIBERNATE;
+	if (g_strcmp0 (sleep_kind, "hybrid") == 0)
+		return UP_SLEEP_KIND_HYBRID;
+	return UP_SLEEP_KIND_UNKNOWN;
+}
+#endif /* ENABLE_DEPRECATED */
diff -urN a/libupower-glib/up-types.h b/libupower-glib/up-types.h
--- a/libupower-glib/up-types.h	2013-10-29 06:37:01.000000000 -0400
+++ b/libupower-glib/up-types.h	2015-05-18 11:32:17.179249876 -0400
@@ -98,6 +98,19 @@
 	UP_DEVICE_LEVEL_LAST
 } UpDeviceLevel;
 
+/**
+ * UpSleepKind:
+ *
+ * The type of QOS request.
+ **/
+typedef enum {
+	UP_SLEEP_KIND_UNKNOWN,
+	UP_SLEEP_KIND_SUSPEND,
+	UP_SLEEP_KIND_HIBERNATE,
+	UP_SLEEP_KIND_HYBRID,
+	UP_SLEEP_KIND_LAST
+} UpSleepKind;
+
 const gchar	*up_device_kind_to_string		(UpDeviceKind		 type_enum);
 const gchar	*up_device_state_to_string		(UpDeviceState		 state_enum);
 const gchar	*up_device_technology_to_string		(UpDeviceTechnology	 technology_enum);
@@ -106,6 +119,8 @@
 UpDeviceState	 up_device_state_from_string		(const gchar		*state);
 UpDeviceTechnology up_device_technology_from_string	(const gchar		*technology);
 UpDeviceLevel	 up_device_level_from_string		(const gchar		*level);
+const gchar	*up_sleep_kind_to_string		(UpSleepKind		 sleep_kind_enum);
+UpSleepKind	 up_sleep_kind_from_string		(const gchar		*sleep_kind);
 
 G_END_DECLS
 
diff -urN a/policy/Makefile.am b/policy/Makefile.am
--- a/policy/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ b/policy/Makefile.am	2015-05-18 11:32:17.179249876 -0400
@@ -0,0 +1,18 @@
+polkit_policydir = $(datadir)/polkit-1/actions
+polkit_policy_DATA =					\
+	org.freedesktop.upower.policy
+
+# You will need a recent intltool or the patch from this bug
+# http://bugzilla.gnome.org/show_bug.cgi?id=462312
+@INTLTOOL_POLICY_RULE@
+
+EXTRA_DIST =						\
+	org.freedesktop.upower.policy.in
+
+DISTCLEANFILES =					\
+	org.freedesktop.upower.policy
+
+clean-local :
+	rm -f *~
+
+-include $(top_srcdir)/git.mk
diff -urN a/policy/org.freedesktop.upower.policy.in b/policy/org.freedesktop.upower.policy.in
--- a/policy/org.freedesktop.upower.policy.in	1969-12-31 19:00:00.000000000 -0500
+++ b/policy/org.freedesktop.upower.policy.in	2015-05-18 11:32:17.179249876 -0400
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!DOCTYPE policyconfig PUBLIC
+ "-//freedesktop//DTD PolicyKit Policy Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/PolicyKit/1.0/policyconfig.dtd">
+
+<!--
+Policy definitions for UPower
+
+Copyright (c) 2008 David Zeuthen <david@fubar.dk>
+Copyright (c) 2008-2010 Richard Hughes <richard@hughsie.com>
+
+NOTE: If you make changes to this file, make sure to validate the file
+using the polkit-policy-file-validate(1) tool. Changes made to this
+file are instantly applied.
+-->
+
+<policyconfig>
+  <vendor>The UPower Project</vendor>
+  <vendor_url>http://upower.freedesktop.org/</vendor_url>
+  <icon_name>system-suspend</icon_name>
+
+  <action id="org.freedesktop.upower.suspend">
+    <_description>Suspend the system</_description>
+    <_message>Authentication is required to suspend the system</_message>
+    <defaults>
+      <allow_inactive>no</allow_inactive>
+      <allow_active>yes</allow_active>
+    </defaults>
+  </action>
+
+  <action id="org.freedesktop.upower.hibernate">
+    <_description>Hibernate the system</_description>
+    <_message>Authentication is required to hibernate the system</_message>
+    <defaults>
+      <allow_inactive>no</allow_inactive>
+      <allow_active>yes</allow_active>
+    </defaults>
+  </action>
+
+</policyconfig>
diff -urN a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am	2014-07-17 03:46:15.000000000 -0400
+++ b/src/Makefile.am	2015-05-18 11:32:17.179249876 -0400
@@ -21,6 +21,7 @@
 	$(GIO_CFLAGS)						\
 	$(DBUS_GLIB_CFLAGS)					\
 	$(GUDEV_CFLAGS)						\
+	$(POLKIT_CFLAGS)					\
 	$(GLIB_CFLAGS)
 
 UPOWER_LIBS = $(top_builddir)/libupower-glib/libupower-glib.la
@@ -61,6 +62,8 @@
 	org.freedesktop.UPower.Wakeups.xml
 
 upowerd_SOURCES =						\
+	up-polkit.h						\
+	up-polkit.c						\
 	up-daemon.h						\
 	up-daemon.c						\
 	up-device.h						\
@@ -89,6 +92,7 @@
 	$(USB_LIBS)						\
 	$(GIO_LIBS)						\
 	$(DBUS_GLIB_LIBS)					\
+	$(POLKIT_LIBS)						\
 	$(UPOWER_LIBS)
 
 if BACKEND_TYPE_DUMMY
@@ -118,6 +122,11 @@
 	$(PIE_LDFLAGS)						\
 	$(RELRO_LDFLAGS)
 
+if HAVE_SYSTEMDUTILDIR
+systemsleepdir = $(systemdutildir)/system-sleep
+systemsleep_SCRIPTS = notify-upower.sh
+endif
+
 if UP_BUILD_TESTS
 check-local: upowerd
 	env GI_TYPELIB_PATH=$(top_builddir)/libupower-glib:$(GI_TYPELIB_PATH) LD_LIBRARY_PATH=$(top_builddir)/libupower-glib/.libs:$(LD_LIBRARY_PATH) top_builddir=$(top_builddir) $(srcdir)/linux/integration-test -v
@@ -136,6 +145,8 @@
 
 up_self_test_SOURCES =						\
 	up-self-test.c						\
+	up-polkit.h						\
+	up-polkit.c						\
 	up-config.h						\
 	up-config.c						\
 	up-daemon.h						\
@@ -211,6 +222,7 @@
 	org.freedesktop.UPower.KbdBacklight.xml			\
 	org.freedesktop.UPower.Wakeups.xml			\
 	up-marshal.list						\
+	$(systemsleep_SCRIPTS)					\
 	$(systemdservice_in_files)				\
 	$(dbusservice_in_files)					\
 	$(dbusconf_in_files)
diff -urN a/src/dummy/up-backend.c b/src/dummy/up-backend.c
--- a/src/dummy/up-backend.c	2014-11-26 06:56:16.000000000 -0500
+++ b/src/dummy/up-backend.c	2015-05-18 11:32:17.180249869 -0400
@@ -271,3 +271,76 @@
 {
 	return g_object_new (UP_TYPE_BACKEND, NULL);
 }
+
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_backend_kernel_can_suspend:
+ **/
+gboolean
+up_backend_kernel_can_suspend (UpBackend *backend)
+{
+	return FALSE;
+}
+
+/**
+ * up_backend_kernel_can_hibernate:
+ **/
+gboolean
+up_backend_kernel_can_hibernate (UpBackend *backend)
+{
+	return FALSE;
+}
+
+/**
+ * up_backend_has_encrypted_swap:
+ **/
+gboolean
+up_backend_has_encrypted_swap (UpBackend *backend)
+{
+	return FALSE;
+}
+
+/**
+ * up_backend_get_used_swap:
+ *
+ * Return value: a percentage value
+ **/
+gfloat
+up_backend_get_used_swap (UpBackend *backend)
+{
+	return 0.0;
+}
+
+/**
+ * up_backend_get_suspend_command:
+ **/
+const gchar *
+up_backend_get_suspend_command (UpBackend *backend)
+{
+	return "/bin/true";
+}
+
+/**
+ * up_backend_get_hibernate_command:
+ **/
+const gchar *
+up_backend_get_hibernate_command (UpBackend *backend)
+{
+	return "/bin/true";
+}
+
+/**
+ * up_backend_get_powersave_command:
+ **/
+const gchar *
+up_backend_get_powersave_command (UpBackend *backend, gboolean powersave)
+{
+	return "/bin/true";
+}
+
+gboolean
+up_backend_emits_resuming (UpBackend *backend)
+{
+	return FALSE;
+}
+#endif /* ENABLE_DEPRECATED */
diff -urN a/src/freebsd/up-backend.c b/src/freebsd/up-backend.c
--- a/src/freebsd/up-backend.c	2014-11-26 06:56:16.000000000 -0500
+++ b/src/freebsd/up-backend.c	2015-05-18 11:32:17.180249869 -0400
@@ -44,6 +44,10 @@
 #include "up-device.h"
 
 #define UP_BACKEND_REFRESH_TIMEOUT	30	/* seconds */
+#ifdef ENABLE_DEPRECATED
+#define UP_BACKEND_SUSPEND_COMMAND	"/usr/sbin/zzz"
+#define UP_BACKEND_HIBERNATE_COMMAND	"/usr/sbin/acpiconf -s 4"
+#endif /* ENABLE_DEPRECATED */
 
 static void	up_backend_class_init	(UpBackendClass	*klass);
 static void	up_backend_init	(UpBackend		*backend);
@@ -53,6 +57,9 @@
 static gboolean	up_backend_acpi_devd_notify (UpBackend *backend, const gchar *system, const gchar *subsystem, const gchar *type, const gchar *data);
 static gboolean	up_backend_create_new_device (UpBackend *backend, UpAcpiNative *native);
 static void	up_backend_lid_coldplug (UpBackend *backend);
+#ifdef ENABLE_DEPRECATED
+static gboolean	up_backend_supports_sleep_state (const gchar *state);
+#endif /* ENABLE_DEPRECATED */
 
 #define UP_BACKEND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UP_TYPE_BACKEND, UpBackendPrivate))
 
@@ -342,6 +349,67 @@
 	/* FIXME: Implement */
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_backend_get_powersave_command:
+ **/
+const gchar *
+up_backend_get_powersave_command (UpBackend *backend, gboolean powersave)
+{
+	/* XXX: Do we want to use powerd here? */
+	return NULL;
+}
+
+/**
+ * up_backend_get_suspend_command:
+ **/
+const gchar *
+up_backend_get_suspend_command (UpBackend *backend)
+{
+	return UP_BACKEND_SUSPEND_COMMAND;
+}
+
+/**
+ * up_backend_get_hibernate_command:
+ **/
+const gchar *
+up_backend_get_hibernate_command (UpBackend *backend)
+{
+	return UP_BACKEND_HIBERNATE_COMMAND;
+}
+
+gboolean
+up_backend_emits_resuming (UpBackend *backend)
+{
+	return FALSE;
+}
+
+/**
+ * up_backend_kernel_can_suspend:
+ **/
+gboolean
+up_backend_kernel_can_suspend (UpBackend *backend)
+{
+	return up_backend_supports_sleep_state ("S3");
+}
+
+/**
+ * up_backend_kernel_can_hibernate:
+ **/
+gboolean
+up_backend_kernel_can_hibernate (UpBackend *backend)
+{
+	return up_backend_supports_sleep_state ("S4");
+}
+
+gboolean
+up_backend_has_encrypted_swap (UpBackend *backend)
+{
+	/* XXX: Add support for GELI? */
+	return FALSE;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /* Return value: a percentage value */
 gfloat
 up_backend_get_used_swap (UpBackend *backend)
@@ -377,6 +445,28 @@
 	return percent;
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_backend_supports_sleep_state:
+ **/
+static gboolean
+up_backend_supports_sleep_state (const gchar *state)
+{
+	gchar *sleep_states;
+	gboolean ret = FALSE;
+
+	sleep_states = up_get_string_sysctl (NULL, "hw.acpi.supported_sleep_state");
+	if (sleep_states != NULL) {
+		if (strstr (sleep_states, state) != NULL)
+			ret = TRUE;
+	}
+
+	g_free (sleep_states);
+
+	return ret;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_backend_class_init:
  * @klass: The UpBackendClass
diff -urN a/src/linux/integration-test.py b/src/linux/integration-test.py
--- a/src/linux/integration-test.py	2014-09-03 03:36:11.000000000 -0400
+++ b/src/linux/integration-test.py	2015-05-18 11:32:17.180249869 -0400
@@ -811,7 +811,10 @@
 
         self.start_daemon()
         client = UPowerGlib.Client.new()
+        self.assertTrue(client.get_properties_sync(None))
         self.assertRegex(client.get_daemon_version(), '^[0-9.]+$')
+        self.assertIn(client.get_can_hibernate(), [False, True])
+        self.assertIn(client.get_can_suspend(), [False, True])
         self.assertIn(client.get_lid_is_present(), [False, True])
         self.assertIn(client.get_lid_is_closed(), [False, True])
         self.assertEqual(client.get_on_battery(), False)
diff -urN a/src/linux/up-backend.c b/src/linux/up-backend.c
--- a/src/linux/up-backend.c	2014-11-26 06:56:16.000000000 -0500
+++ b/src/linux/up-backend.c	2015-05-18 11:32:17.180249869 -0400
@@ -48,6 +48,15 @@
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
 
+#ifdef ENABLE_DEPRECATED
+
+#define LOGIND_AVAILABLE() (access("/run/systemd/seats/", F_OK) >= 0)
+
+#define SD_HIBERNATE_COMMAND	"gdbus call --system --dest org.freedesktop.login1 --object-path /org/freedesktop/login1 --method org.freedesktop.login1.Manager.Hibernate 'true'"
+#define SD_SUSPEND_COMMAND	"gdbus call --system --dest org.freedesktop.login1 --object-path /org/freedesktop/login1 --method org.freedesktop.login1.Manager.Suspend 'true'"
+
+#endif
+
 static void	up_backend_class_init	(UpBackendClass	*klass);
 static void	up_backend_init	(UpBackend		*backend);
 static void	up_backend_finalize	(GObject		*object);
@@ -72,6 +81,9 @@
 enum {
 	SIGNAL_DEVICE_ADDED,
 	SIGNAL_DEVICE_REMOVED,
+#ifdef ENABLE_DEPRECATED
+	SIGNAL_RESUMING,
+#endif
 	SIGNAL_LAST
 };
 
@@ -82,6 +94,13 @@
 static gboolean up_backend_device_add (UpBackend *backend, GUdevDevice *native);
 static void up_backend_device_remove (UpBackend *backend, GUdevDevice *native);
 
+#ifdef ENABLE_DEPRECATED
+#define UP_BACKEND_SUSPEND_COMMAND		"/usr/sbin/pm-suspend"
+#define UP_BACKEND_HIBERNATE_COMMAND		"/usr/sbin/pm-hibernate"
+#define UP_BACKEND_POWERSAVE_TRUE_COMMAND	"/usr/sbin/pm-powersave true"
+#define UP_BACKEND_POWERSAVE_FALSE_COMMAND	"/usr/sbin/pm-powersave false"
+#endif
+
 /**
  * up_backend_device_new:
  **/
@@ -464,6 +483,271 @@
 			   NULL);
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_backend_supports_sleep_state:
+ *
+ * use pm-is-supported to test for supported sleep states
+ **/
+static gboolean
+up_backend_supports_sleep_state (const gchar *state)
+{
+	gboolean ret = FALSE;
+	gchar *command;
+	GError *error = NULL;
+	gint exit_status;
+
+	/* run script from pm-utils */
+	command = g_strdup_printf ("/usr/bin/pm-is-supported --%s", state);
+	g_debug ("excuting command: %s", command);
+	ret = g_spawn_command_line_sync (command, NULL, NULL, &exit_status, &error);
+	if (!ret) {
+		g_warning ("failed to run script: %s", error->message);
+		g_error_free (error);
+		goto out;
+	}
+	ret = (WIFEXITED(exit_status) && (WEXITSTATUS(exit_status) == EXIT_SUCCESS));
+
+out:
+	g_free (command);
+	return ret;
+}
+
+/**
+ * up_backend_kernel_can_suspend:
+ **/
+gboolean
+up_backend_kernel_can_suspend (UpBackend *backend)
+{
+	return up_backend_supports_sleep_state ("suspend");
+}
+
+/**
+ * up_backend_kernel_can_hibernate:
+ **/
+gboolean
+up_backend_kernel_can_hibernate (UpBackend *backend)
+{
+	return up_backend_supports_sleep_state ("hibernate");
+}
+
+/**
+ * up_backend_has_encrypted_swap:
+ *
+ * user@local:~$ cat /proc/swaps
+ * Filename                                Type            Size    Used    Priority
+ * /dev/mapper/cryptswap1                  partition       4803392 35872   -1
+ *
+ * user@local:~$ cat /etc/crypttab
+ * # <target name> <source device>         <key file>      <options>
+ * cryptswap1 /dev/sda5 /dev/urandom swap,cipher=aes-cbc-essiv:sha256
+ *
+ * Loop over the swap partitions in /proc/swaps, looking for matches in /etc/crypttab
+ **/
+gboolean
+up_backend_has_encrypted_swap (UpBackend *backend)
+{
+	gchar *contents_swaps = NULL;
+	gchar *contents_crypttab = NULL;
+	gchar **lines_swaps = NULL;
+	gchar **lines_crypttab = NULL;
+	GError *error = NULL;
+	gboolean ret;
+	gboolean encrypted_swap = FALSE;
+	const gchar *filename_swaps = "/proc/swaps";
+	const gchar *filename_crypttab = "/etc/crypttab";
+	GPtrArray *devices = NULL;
+	gchar *device;
+	guint i, j;
+
+	/* get swaps data */
+	ret = g_file_get_contents (filename_swaps, &contents_swaps, NULL, &error);
+	if (!ret) {
+		g_warning ("failed to open %s: %s", filename_swaps, error->message);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* get crypttab data */
+	ret = g_file_get_contents (filename_crypttab, &contents_crypttab, NULL, &error);
+	if (!ret) {
+		if (error->code != G_FILE_ERROR_NOENT) {
+			g_warning ("failed to open %s: %s", filename_crypttab, error->message);
+		}
+		g_error_free (error);
+		goto out;
+	}
+
+	/* split both into lines */
+	lines_swaps = g_strsplit (contents_swaps, "\n", -1);
+	lines_crypttab = g_strsplit (contents_crypttab, "\n", -1);
+
+	/* get valid swap devices */
+	devices = g_ptr_array_new_with_free_func (g_free);
+	for (i=0; lines_swaps[i] != NULL; i++) {
+
+		/* is a device? */
+		if (lines_swaps[i][0] != '/')
+			continue;
+
+		/* only look at first parameter */
+		g_strdelimit (lines_swaps[i], "\t ", '\0');
+
+		/* add base device to list */
+		device = g_path_get_basename (lines_swaps[i]);
+		g_debug ("adding swap device: %s", device);
+		g_ptr_array_add (devices, device);
+	}
+
+	/* no swap devices? */
+	if (devices->len == 0) {
+		g_debug ("no swap devices");
+		goto out;
+	}
+
+	/* find matches in crypttab */
+	for (i=0; lines_crypttab[i] != NULL; i++) {
+
+		/* ignore invalid lines */
+		if (lines_crypttab[i][0] == '#' ||
+		    lines_crypttab[i][0] == '\n' ||
+		    lines_crypttab[i][0] == '\t' ||
+		    lines_crypttab[i][0] == '\0')
+			continue;
+
+		/* only look at first parameter */
+		g_strdelimit (lines_crypttab[i], "\t ", '\0');
+
+		/* is a swap device? */
+		for (j=0; j<devices->len; j++) {
+			device = g_ptr_array_index (devices, j);
+			if (g_strcmp0 (device, lines_crypttab[i]) == 0) {
+				g_debug ("swap device %s is encrypted (so cannot hibernate)", device);
+				encrypted_swap = TRUE;
+				goto out;
+			}
+			g_debug ("swap device %s is not encrypted (allows hibernate)", device);
+		}
+	}
+
+out:
+	if (devices != NULL)
+		g_ptr_array_unref (devices);
+	g_free (contents_swaps);
+	g_free (contents_crypttab);
+	g_strfreev (lines_swaps);
+	g_strfreev (lines_crypttab);
+	return encrypted_swap;
+}
+
+/**
+ * up_backend_get_used_swap:
+ *
+ * Return value: a percentage value how much of the available swap memory would
+ * be taken by currently active memory
+ **/
+gfloat
+up_backend_get_used_swap (UpBackend *backend)
+{
+	gchar *contents = NULL;
+	gchar **lines = NULL;
+	GError *error = NULL;
+	gchar **tokens;
+	gboolean ret;
+	guint active = 0;
+	guint swap_free = 0;
+	guint swap_total = 0;
+	guint len;
+	guint i;
+	gfloat percentage = 0.0f;
+	const gchar *filename = "/proc/meminfo";
+
+	/* get memory data */
+	ret = g_file_get_contents (filename, &contents, NULL, &error);
+	if (!ret) {
+		g_warning ("failed to open %s: %s", filename, error->message);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* process each line */
+	lines = g_strsplit (contents, "\n", -1);
+	for (i=1; lines[i] != NULL; i++) {
+		tokens = g_strsplit_set (lines[i], ": ", -1);
+		len = g_strv_length (tokens);
+		if (len > 3) {
+			if (g_strcmp0 (tokens[0], "SwapFree") == 0)
+				swap_free = atoi (tokens[len-2]);
+			if (g_strcmp0 (tokens[0], "SwapTotal") == 0)
+				swap_total = atoi (tokens[len-2]);
+			else if (g_strcmp0 (tokens[0], "Active(anon)") == 0)
+				active = atoi (tokens[len-2]);
+		}
+		g_strfreev (tokens);
+	}
+
+	/* first check if we even have swap, if not consider all swap space used */
+	if (swap_total == 0) {
+		g_debug ("no swap space found");
+		percentage = 100.0f;
+		goto out;
+	}
+
+	/* work out how close to the line we are */
+	if (swap_free > 0 && active > 0)
+		percentage = (active * 100) / swap_free;
+	g_debug ("total swap available %i kb, active memory %i kb (%.1f%%)", swap_free, active, percentage);
+out:
+	g_free (contents);
+	g_strfreev (lines);
+	return percentage;
+}
+
+/**
+ * up_backend_get_suspend_command:
+ **/
+const gchar *
+up_backend_get_suspend_command (UpBackend *backend)
+{
+	if (LOGIND_AVAILABLE())
+		return SD_SUSPEND_COMMAND;
+	else
+		return UP_BACKEND_SUSPEND_COMMAND;
+}
+
+/**
+ * up_backend_get_hibernate_command:
+ **/
+const gchar *
+up_backend_get_hibernate_command (UpBackend *backend)
+{
+	if (LOGIND_AVAILABLE())
+		return SD_HIBERNATE_COMMAND;
+	else
+		return UP_BACKEND_HIBERNATE_COMMAND;
+}
+
+gboolean
+up_backend_emits_resuming (UpBackend *backend)
+{
+	if (LOGIND_AVAILABLE())
+		return TRUE;
+	else
+		return FALSE;
+}
+
+/**
+ * up_backend_get_powersave_command:
+ **/
+const gchar *
+up_backend_get_powersave_command (UpBackend *backend, gboolean powersave)
+{
+	if (powersave)
+		return UP_BACKEND_POWERSAVE_TRUE_COMMAND;
+	return UP_BACKEND_POWERSAVE_FALSE_COMMAND;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_backend_class_init:
  * @klass: The UpBackendClass
@@ -486,10 +770,35 @@
 			      G_STRUCT_OFFSET (UpBackendClass, device_removed),
 			      NULL, NULL, up_marshal_VOID__POINTER_POINTER,
 			      G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_POINTER);
+#ifdef ENABLE_DEPRECATED
+	signals [SIGNAL_RESUMING] =
+		g_signal_new ("resuming",
+			      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (UpBackendClass, resuming),
+			      NULL, NULL, g_cclosure_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0);
+#endif /* ENABLE_DEPRECATED */
 
 	g_type_class_add_private (klass, sizeof (UpBackendPrivate));
 }
 
+#ifdef ENABLE_DEPRECATED
+static DBusHandlerResult
+message_filter (DBusConnection *connection,
+		DBusMessage *message,
+		void *user_data)
+{
+	UpBackend *backend = user_data;
+
+	if (dbus_message_is_signal (message, "org.freedesktop.UPower", "Resuming")) {
+		g_debug ("received Resuming signal");
+		g_signal_emit (backend, signals[SIGNAL_RESUMING], 0);
+		return DBUS_HANDLER_RESULT_HANDLED;
+	}
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_backend_init:
  **/
@@ -507,6 +816,15 @@
 								     LOGIND_DBUS_INTERFACE,
 								     NULL,
 								     NULL);
+
+#ifdef ENABLE_DEPRECATED
+	if (LOGIND_AVAILABLE()) {
+		DBusGConnection *bus;
+		bus = dbus_g_bus_get (DBUS_BUS_SYSTEM, NULL);
+		backend->priv->connection = dbus_g_connection_get_connection (bus);
+		dbus_connection_add_filter (backend->priv->connection, message_filter, backend, NULL);
+	}
+#endif /* ENABLE_DEPRECATED */
 }
 
 /**
@@ -532,6 +850,11 @@
 
 	g_object_unref (backend->priv->managed_devices);
 
+#ifdef ENABLE_DEPRECATED
+	if (backend->priv->connection)
+		dbus_connection_remove_filter (backend->priv->connection, message_filter, backend);
+#endif /* ENABLE_DEPRECATED */
+
 	G_OBJECT_CLASS (up_backend_parent_class)->finalize (object);
 }
 
diff -urN a/src/notify-upower.sh b/src/notify-upower.sh
--- a/src/notify-upower.sh	1969-12-31 19:00:00.000000000 -0500
+++ b/src/notify-upower.sh	2015-05-18 11:32:17.180249869 -0400
@@ -0,0 +1,7 @@
+#!/bin/bash
+[ "$1" = "post" ] && exec /usr/bin/dbus-send	\
+	--system --type=signal			\
+	--dest=org.freedesktop.UPower		\
+	/org/freedesktop/UPower			\
+	org.freedesktop.UPower.Resuming
+exit 0
diff -urN a/src/openbsd/up-backend.c b/src/openbsd/up-backend.c
--- a/src/openbsd/up-backend.c	2014-11-26 06:56:16.000000000 -0500
+++ b/src/openbsd/up-backend.c	2015-05-18 11:32:17.180249869 -0400
@@ -27,6 +27,12 @@
 #include "up-device.h"
 #include <string.h> /* strcmp() */
 
+#ifdef ENABLE_DEPRECATED
+#define UP_BACKEND_SUSPEND_COMMAND	"/usr/sbin/zzz"
+#define UP_BACKEND_POWERSAVE_TRUE_COMMAND	"/usr/sbin/apm -C"
+#define UP_BACKEND_POWERSAVE_FALSE_COMMAND	"/usr/sbin/apm -A"
+#endif /* ENABLE_DEPRECATED */
+
 static void	up_backend_class_init	(UpBackendClass	*klass);
 static void	up_backend_init	(UpBackend		*backend);
 static void	up_backend_finalize	(GObject		*object);
@@ -190,6 +196,74 @@
 	/* FIXME: Implement */
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_backend_get_powersave_command:
+ **/
+const gchar *
+up_backend_get_powersave_command (UpBackend *backend, gboolean powersave)
+{
+	if (powersave)
+		return UP_BACKEND_POWERSAVE_TRUE_COMMAND;
+	return UP_BACKEND_POWERSAVE_FALSE_COMMAND;
+}
+
+/**
+ * up_backend_get_suspend_command:
+ **/
+const gchar *
+up_backend_get_suspend_command (UpBackend *backend)
+{
+	return UP_BACKEND_SUSPEND_COMMAND;
+}
+
+/**
+ * up_backend_get_hibernate_command:
+ **/
+const gchar *
+up_backend_get_hibernate_command (UpBackend *backend)
+{
+	return NULL;
+}
+
+gboolean
+up_backend_emits_resuming (UpBackend *backend)
+{
+	return FALSE;
+}
+
+/**
+ * up_backend_kernel_can_suspend:
+ **/
+gboolean
+up_backend_kernel_can_suspend (UpBackend *backend)
+{
+	return TRUE;
+}
+
+/**
+ * up_backend_kernel_can_hibernate:
+ **/
+gboolean
+up_backend_kernel_can_hibernate (UpBackend *backend)
+{
+	return FALSE;
+}
+
+gboolean
+up_backend_has_encrypted_swap (UpBackend *backend)
+{
+	return FALSE;
+}
+
+/* Return value: a percentage value */
+gfloat
+up_backend_get_used_swap (UpBackend *backend)
+{
+	return 0;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * OpenBSD specific code
  **/
diff -urN a/src/org.freedesktop.UPower.xml b/src/org.freedesktop.UPower.xml
--- a/src/org.freedesktop.UPower.xml	2014-05-08 03:27:51.000000000 -0400
+++ b/src/org.freedesktop.UPower.xml	2015-05-18 11:32:17.180249869 -0400
@@ -166,12 +166,219 @@
 
     <!-- ************************************************************ -->
 
+    <signal name="Sleeping">
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            This signal is sent when the session is about to be suspended or
+            hibernated.
+          </doc:para>
+          <doc:para>
+            This signal is DEPRECATED. Use NotifySleep() instead.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </signal>
+
+    <!-- ************************************************************ -->
+
+    <signal name="NotifySleep">
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            This signal is sent when the session is about to be suspended or
+            hibernated.
+            Session and system programs have one second to do anything required
+            before the sleep action is taken (such as sending out Avahi or
+            Jabber messages).
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+      <arg name="action" direction="out" type="s">
+        <doc:doc>
+          <doc:summary>
+            The sleep action type, e.g. <doc:tt>suspend</doc:tt>,
+            <doc:tt>hibernate</doc:tt> or <doc:tt>hybrid</doc:tt>.
+          </doc:summary>
+        </doc:doc>
+      </arg>
+    </signal>
+
+    <!-- ************************************************************ -->
+
+    <signal name="Resuming">
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            This signal is sent when the session has just returned from
+            Suspend() or Hibernate().
+          </doc:para>
+          <doc:para>
+            This signal is DEPRECATED. Use NotifyResume() instead.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </signal>
+
+    <!-- ************************************************************ -->
+
+    <signal name="NotifyResume">
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            This signal is sent when the session has just returned from
+            Suspend() or Hibernate().
+            Session and system programs can then do anything required (such as
+            sending out Avahi or Jabber messages).
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+      <arg name="action" direction="out" type="s">
+        <doc:doc>
+          <doc:summary>
+            The sleep action type, e.g. <doc:tt>suspend</doc:tt>,
+            <doc:tt>hibernate</doc:tt> or <doc:tt>hybrid</doc:tt>.
+          </doc:summary>
+        </doc:doc>
+      </arg>
+    </signal>
+
+    <!-- ************************************************************ -->
+
+    <method name="AboutToSleep">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            This method tells UPower that the Suspend() or Hibernate() method
+            is about to be called.
+            This allows UPower to emit the Suspending signal whilst
+            session activities are happening that have to be done before the
+            suspend process is started.
+          </doc:para>
+          <doc:para>
+            This method would typically be called by the session power
+            management daemon, before it locks the screen and waits for the
+            screen to fade to black.
+            The session power management component would then call Suspend() or
+            Hibernate() when these syncronous tasks have completed.
+          </doc:para>
+          <doc:para>
+            If this method is not called than nothing bad will happen and
+            Suspend() or Hibernate() will block for the required second.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+      <arg name="action" direction="in" type="s">
+        <doc:doc>
+          <doc:summary>
+            The sleep action type, e.g. <doc:tt>suspend</doc:tt> or
+            <doc:tt>hibernate</doc:tt>.
+          </doc:summary>
+        </doc:doc>
+      </arg>
+    </method>
+
+    <!-- ************************************************************ -->
+
+    <method name="Suspend">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Suspends the computer into a low power state.
+            System state is not preserved if the power is lost.
+          </doc:para>
+          <doc:para>
+            If AboutToSleep() has not been called then UPower will send
+            the Sleeping() signal and block for one second.
+          </doc:para>
+          <doc:para>
+            If AboutToSleep() has been called less than one second
+            before this method is called then UPower will block for the
+            remaining time to complete one second of delay.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </method>
+
+    <!-- ************************************************************ -->
+
+    <method name="SuspendAllowed">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="allowed" direction="out" type="b">
+        <doc:doc><doc:summary>TRUE if allowed, otherwise FALSE</doc:summary></doc:doc>
+      </arg>
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Check if the caller has (or can get) the PolicyKit privilege to call
+            <doc:ref type="method" to="Power.Suspend">Suspend</doc:ref>.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </method>
+
+    <!-- ************************************************************ -->
+
+    <method name="Hibernate">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Hibernates the computer into a low power state.
+            System state is preserved if the power is lost.
+          </doc:para>
+          <doc:para>
+            If AboutToSleep() has not been called then UPower will send
+            the Sleeping() signal and block for one second.
+          </doc:para>
+          <doc:para>
+            If AboutToSleep() has been called less than one second
+            before this method is called then UPower will block for the
+            remaining time to complete one second of delay.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </method>
+
+    <!-- ************************************************************ -->
+
+    <method name="HibernateAllowed">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="allowed" direction="out" type="b">
+        <doc:doc><doc:summary>TRUE if allowed, otherwise FALSE</doc:summary></doc:doc>
+      </arg>
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            Check if the caller has (or can get) the PolicyKit privilege to call
+            <doc:ref type="method" to="Power.Hibernate">Hibernate</doc:ref>.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </method>
+
+    <!-- ************************************************************ -->
+
     <property name="DaemonVersion" type="s" access="read">
       <doc:doc><doc:description><doc:para>
             Version of the running daemon, e.g. <doc:tt>002</doc:tt>.
       </doc:para></doc:description></doc:doc>
     </property>
 
+    <property name="CanSuspend" type="b" access="read">
+      <doc:doc><doc:description><doc:para>
+            Whether the system is able to suspend.
+      </doc:para></doc:description></doc:doc>
+    </property>
+
+    <property name="CanHibernate" type="b" access="read">
+      <doc:doc><doc:description><doc:para>
+            Whether the system is able to hibernate.
+      </doc:para></doc:description></doc:doc>
+    </property>
+
     <property name="OnBattery" type="b" access="read">
       <doc:doc><doc:description><doc:para>
             Indicates whether the system is running on battery power.
@@ -197,6 +404,24 @@
           </doc:para>
         </doc:description>
       </doc:doc>
+    </property>
+
+    <property name="LidForceSleep" type="b" access="read">
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            If the system really has to sleep when the lid is closed.
+            Some laptops actually melt (!) if the lid is closed and the
+            computer keeps running. We blacklist those, and do something
+            sane for the other machines.
+          </doc:para>
+          <doc:para>
+            This allows us to set the default session policy to not
+            suspend on lid close if the laptop is docked, and be sure
+            the machine is not going to melt.
+          </doc:para>
+        </doc:description>
+      </doc:doc>
     </property>
 
   </interface>
diff -urN a/src/up-backend.h b/src/up-backend.h
--- a/src/up-backend.h	2014-11-26 06:56:16.000000000 -0500
+++ b/src/up-backend.h	2015-05-18 11:32:17.181249863 -0400
@@ -61,6 +61,9 @@
 	void		(* device_removed)	(UpBackend	*backend,
 						 GObject	*native,
 						 UpDevice	*device);
+#ifdef ENABLE_DEPRECATED
+	void		(* resuming)		(UpBackend	*backend);
+#endif /* ENABLE_DEPRECATED */
 } UpBackendClass;
 
 GType		 up_backend_get_type			(void);
@@ -72,6 +75,16 @@
 void		 up_backend_unplug			(UpBackend	*backend);
 void		 up_backend_take_action			(UpBackend	*backend);
 const char	*up_backend_get_critical_action		(UpBackend	*backend);
+#ifdef ENABLE_DEPRECATED
+gboolean	 up_backend_kernel_can_suspend		(UpBackend	*backend);
+gboolean	 up_backend_kernel_can_hibernate	(UpBackend	*backend);
+gboolean	 up_backend_has_encrypted_swap		(UpBackend	*backend);
+gfloat		 up_backend_get_used_swap			(UpBackend	*backend);
+const gchar	*up_backend_get_suspend_command		(UpBackend	*backend);
+const gchar	*up_backend_get_hibernate_command	(UpBackend	*backend);
+const gchar	*up_backend_get_powersave_command	(UpBackend	*backend, gboolean	 powersave);
+gboolean	 up_backend_emits_resuming			(UpBackend	*backend);
+#endif /* ENABLE_DEPRECATED */
 
 G_END_DECLS
 
diff -urN a/src/up-daemon.c b/src/up-daemon.c
--- a/src/up-daemon.c	2014-12-03 12:31:59.000000000 -0500
+++ b/src/up-daemon.c	2015-05-18 11:54:21.764431381 -0400
@@ -33,6 +33,7 @@
 #include <dbus/dbus-glib-lowlevel.h>
 
 #include "up-config.h"
+#include "up-polkit.h"
 #include "up-device-list.h"
 #include "up-device.h"
 #include "up-backend.h"
@@ -45,9 +46,16 @@
 {
 	PROP_0,
 	PROP_DAEMON_VERSION,
+#ifdef ENABLE_DEPRECATED
+	PROP_CAN_SUSPEND,
+	PROP_CAN_HIBERNATE,
+#endif /* ENABLE_DEPRECATED */
 	PROP_ON_BATTERY,
 	PROP_LID_IS_CLOSED,
 	PROP_LID_IS_PRESENT,
+#ifdef ENABLE_DEPRECATED
+	PROP_LID_FORCE_SLEEP,
+#endif /* ENABLE_DEPRECATED */
 	PROP_LAST
 };
 
@@ -55,6 +63,12 @@
 {
 	SIGNAL_DEVICE_ADDED,
 	SIGNAL_DEVICE_REMOVED,
+#ifdef ENABLE_DEPRECATED
+	SIGNAL_SLEEPING,
+	SIGNAL_RESUMING,
+	SIGNAL_NOTIFY_SLEEP,
+	SIGNAL_NOTIFY_RESUME,
+#endif /* ENABLE_DEPRECATED */
 	SIGNAL_LAST,
 };
 
@@ -65,6 +79,7 @@
 	DBusGConnection		*connection;
 	DBusGProxy		*proxy;
 	UpConfig		*config;
+	UpPolkit		*polkit;
 	UpBackend		*backend;
 	UpDeviceList		*power_devices;
 	guint			 action_timeout_id;
@@ -76,6 +91,19 @@
 	UpDeviceLevel		 warning_level;
 	gboolean		 lid_is_closed;
 	gboolean		 lid_is_present;
+#ifdef ENABLE_DEPRECATED
+	gboolean		 lid_force_sleep;
+	gboolean		 kernel_can_suspend;
+	gboolean		 kernel_can_hibernate;
+	gboolean		 hibernate_has_encrypted_swap;
+	gboolean		 sent_sleeping_signal;
+	GTimer			*about_to_sleep_timer;
+	guint			 about_to_sleep_id;
+	guint			 conf_sleep_timeout;
+	gboolean		 conf_allow_hibernate_encrypted_swap;
+	gboolean		 conf_run_powersave_command;
+	const gchar		*sleep_kind;
+#endif /* ENABLE_DEPRECATED */
 
 	/* PropertiesChanged to be emitted */
 	GHashTable		*changed_props;
@@ -113,6 +141,14 @@
 
 #define UP_DAEMON_ACTION_DELAY				20 /* seconds */
 
+#ifdef ENABLE_DEPRECATED
+/* if using more memory compared to usable swap, disable hibernate */
+/* Native Linux suspend-to-disk does not use compression, and needs 2 KB of
+ * page meta information for each MB of active memory. Add some error margin
+ * here, though. */
+#define UP_DAEMON_SWAP_WATERLINE 			98.f /* % */
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_daemon_get_on_battery_local:
  *
@@ -383,6 +419,35 @@
 	return result;
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_daemon_set_powersave:
+ **/
+static gboolean
+up_daemon_set_powersave (UpDaemon *daemon, gboolean powersave)
+{
+	gboolean ret = FALSE;
+	const gchar *command;
+	GError *error = NULL;
+
+	/* run script */
+	command = up_backend_get_powersave_command (daemon->priv->backend, powersave);
+	if (command == NULL) {
+		g_warning ("no powersave command set");
+		goto out;
+	}
+	g_debug ("excuting command: %s", command);
+	ret = g_spawn_command_line_async (command, &error);
+	if (!ret) {
+		g_warning ("failed to run script: %s", error->message);
+		g_error_free (error);
+		goto out;
+	}
+out:
+	return ret;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_daemon_refresh_battery_devices:
  **/
@@ -464,6 +529,387 @@
 	return TRUE;
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_daemon_about_to_sleep:
+ **/
+gboolean
+up_daemon_about_to_sleep (UpDaemon *daemon,
+			  const gchar *sleep_kind,
+			  DBusGMethodInvocation *context)
+{
+	GError *error;
+	PolkitSubject *subject = NULL;
+	UpDaemonPrivate *priv = daemon->priv;
+
+	/* already requested */
+	if (priv->about_to_sleep_id != 0) {
+		error = g_error_new (UP_DAEMON_ERROR,
+				     UP_DAEMON_ERROR_GENERAL,
+				     "Sleep has already been requested and is pending");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+		goto out;
+	}
+
+	subject = up_polkit_get_subject (priv->polkit, context);
+	if (subject == NULL)
+		goto out;
+
+	/* TODO: use another PolicyKit context? */
+	if (!up_polkit_check_auth (priv->polkit, subject, "org.freedesktop.upower.suspend", context))
+		goto out;
+
+	/* we've told the clients we're going down */
+	g_debug ("emitting sleeping");
+	g_signal_emit (daemon, signals[SIGNAL_SLEEPING], 0);
+	g_signal_emit (daemon, signals[SIGNAL_NOTIFY_SLEEP], 0,
+		       sleep_kind);
+	g_timer_start (priv->about_to_sleep_timer);
+	daemon->priv->sent_sleeping_signal = TRUE;
+
+	dbus_g_method_return (context, NULL);
+out:
+	if (subject != NULL)
+		g_object_unref (subject);
+	return TRUE;
+}
+
+/* temp object for deferred callback */
+typedef struct {
+	UpDaemon		*daemon;
+	DBusGMethodInvocation	*context;
+	gchar			*command;
+	gulong			 handler;
+} UpDaemonDeferredSleep;
+
+static void
+emit_resuming (UpDaemonDeferredSleep *sleep)
+{
+	UpDaemon *daemon = sleep->daemon;
+	UpDaemonPrivate *priv = daemon->priv;
+
+	/* emit signal for session components */
+	g_debug ("emitting resuming");
+	g_signal_emit (daemon, signals[SIGNAL_RESUMING], 0);
+	g_signal_emit (daemon, signals[SIGNAL_NOTIFY_RESUME], 0,
+		       priv->sleep_kind);
+
+	/* reset the about-to-sleep logic */
+	g_timer_reset (priv->about_to_sleep_timer);
+	g_timer_stop (priv->about_to_sleep_timer);
+
+	/* actually return from the DBus call now */
+	dbus_g_method_return (sleep->context, NULL);
+
+	/* clear timer */
+	priv->about_to_sleep_id = 0;
+	priv->sent_sleeping_signal = FALSE;
+
+	/* delete temp object */
+	if (sleep->handler)
+		g_signal_handler_disconnect (priv->backend, sleep->handler);
+	g_object_unref (sleep->daemon);
+	g_free (sleep->command);
+	g_free (sleep);
+}
+
+/**
+ * up_daemon_deferred_sleep_cb:
+ **/
+static gboolean
+up_daemon_deferred_sleep_cb (UpDaemonDeferredSleep *sleep)
+{
+	GError *error;
+	GError *error_local = NULL;
+	gchar *stdout = NULL;
+	gchar *stderr = NULL;
+	gboolean ret;
+	UpDaemon *daemon = sleep->daemon;
+	UpDaemonPrivate *priv = daemon->priv;
+
+	if (up_backend_emits_resuming (priv->backend)) {
+		sleep->handler = g_signal_connect_swapped (priv->backend, "resuming",
+							   G_CALLBACK (emit_resuming), sleep);
+	}
+
+	/* run the command */
+	g_debug ("Running %s", sleep->command);
+	ret = g_spawn_command_line_sync (sleep->command, &stdout, &stderr, NULL, &error_local);
+	if (!ret) {
+		error = g_error_new (UP_DAEMON_ERROR,
+				     UP_DAEMON_ERROR_GENERAL,
+				     "Failed to spawn: %s, stdout:%s, stderr:%s", error_local->message, stdout, stderr);
+		g_error_free (error_local);
+		dbus_g_method_return_error (sleep->context, error);
+		g_error_free (error);
+		goto out;
+	}
+
+	if (!up_backend_emits_resuming (priv->backend))
+		emit_resuming (sleep);
+
+out:
+	g_free (stdout);
+	g_free (stderr);
+
+	return FALSE;
+}
+
+/**
+ * up_daemon_deferred_sleep:
+ **/
+static void
+up_daemon_deferred_sleep (UpDaemon *daemon, const gchar *command, DBusGMethodInvocation *context)
+{
+	UpDaemonDeferredSleep *sleep;
+	UpDaemonPrivate *priv = daemon->priv;
+	gfloat elapsed;
+
+	/* create callback object */
+	sleep = g_new0 (UpDaemonDeferredSleep, 1);
+	sleep->daemon = g_object_ref (daemon);
+	sleep->context = context;
+	sleep->command = g_strdup (command);
+
+	/* we didn't use AboutToSleep() so send the signal for clients now */
+	if (!priv->sent_sleeping_signal) {
+		g_debug ("no AboutToSleep(), so emitting ::Sleeping()");
+		g_signal_emit (daemon, signals[SIGNAL_SLEEPING], 0);
+		g_signal_emit (daemon, signals[SIGNAL_NOTIFY_SLEEP], 0,
+			       priv->sleep_kind);
+		priv->about_to_sleep_id = g_timeout_add (priv->conf_sleep_timeout,
+							 (GSourceFunc) up_daemon_deferred_sleep_cb, sleep);
+#if GLIB_CHECK_VERSION(2,25,8)
+		g_source_set_name_by_id (priv->about_to_sleep_id, "[UpDaemon] about-to-sleep no signal");
+#endif
+		return;
+	}
+
+	/* about to sleep */
+	elapsed = 1000.0f * g_timer_elapsed (priv->about_to_sleep_timer, NULL);
+	g_debug ("between AboutToSleep() and %s was %fms", sleep->command, elapsed);
+	if (elapsed < priv->conf_sleep_timeout) {
+		/* we have to wait for the difference in time */
+		priv->about_to_sleep_id = g_timeout_add (priv->conf_sleep_timeout - elapsed,
+							 (GSourceFunc) up_daemon_deferred_sleep_cb, sleep);
+#if GLIB_CHECK_VERSION(2,25,8)
+		g_source_set_name_by_id (priv->about_to_sleep_id, "[UpDaemon] about-to-sleep less");
+#endif
+	} else {
+		/* we can do this straight away */
+		priv->about_to_sleep_id = g_idle_add ((GSourceFunc) up_daemon_deferred_sleep_cb, sleep);
+#if GLIB_CHECK_VERSION(2,25,8)
+		g_source_set_name_by_id (priv->about_to_sleep_id, "[UpDaemon] about-to-sleep more");
+#endif
+	}
+}
+
+/**
+ * up_daemon_suspend:
+ **/
+gboolean
+up_daemon_suspend (UpDaemon *daemon, DBusGMethodInvocation *context)
+{
+	GError *error;
+	PolkitSubject *subject = NULL;
+	const gchar *command;
+	UpDaemonPrivate *priv = daemon->priv;
+
+	/* no kernel support */
+	if (!priv->kernel_can_suspend) {
+		error = g_error_new (UP_DAEMON_ERROR,
+				     UP_DAEMON_ERROR_GENERAL,
+				     "No kernel support");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+		goto out;
+	}
+
+	subject = up_polkit_get_subject (priv->polkit, context);
+	if (subject == NULL)
+		goto out;
+
+	if (!up_polkit_check_auth (priv->polkit, subject, "org.freedesktop.upower.suspend", context))
+		goto out;
+
+	/* already requested */
+	if (priv->about_to_sleep_id != 0) {
+		error = g_error_new (UP_DAEMON_ERROR,
+				     UP_DAEMON_ERROR_GENERAL,
+				     "Sleep has already been requested and is pending");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* do this deferred action */
+	priv->sleep_kind = "suspend";
+	command = up_backend_get_suspend_command (priv->backend);
+	up_daemon_deferred_sleep (daemon, command, context);
+out:
+	if (subject != NULL)
+		g_object_unref (subject);
+	return TRUE;
+}
+
+/**
+ * up_daemon_suspend_allowed:
+ **/
+gboolean
+up_daemon_suspend_allowed (UpDaemon *daemon, DBusGMethodInvocation *context)
+{
+	GError *error;
+	gboolean ret;
+	PolkitSubject *subject = NULL;
+	UpDaemonPrivate *priv = daemon->priv;
+
+	subject = up_polkit_get_subject (priv->polkit, context);
+	if (subject == NULL)
+		goto out;
+
+	error = NULL;
+	ret = up_polkit_is_allowed (priv->polkit, subject, "org.freedesktop.upower.suspend", &error);
+	if (error) {
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+	}
+	else {
+		dbus_g_method_return (context, ret);
+	}
+
+out:
+	if (subject != NULL)
+		g_object_unref (subject);
+	return TRUE;
+}
+
+/**
+ * up_daemon_check_hibernate_swap:
+ *
+ * Check current memory usage whether we have enough swap space for
+ * hibernate.
+ **/
+static gboolean
+up_daemon_check_hibernate_swap (UpDaemon *daemon)
+{
+	gfloat waterline;
+
+	if (daemon->priv->kernel_can_hibernate) {
+		waterline = up_backend_get_used_swap (daemon->priv->backend);
+		if (waterline < UP_DAEMON_SWAP_WATERLINE) {
+			g_debug ("enough swap to for hibernate");
+			return TRUE;
+		} else {
+			g_debug ("not enough swap to hibernate");
+			return FALSE;
+		}
+	}
+
+	return FALSE;
+}
+
+/**
+ * up_daemon_hibernate:
+ **/
+gboolean
+up_daemon_hibernate (UpDaemon *daemon, DBusGMethodInvocation *context)
+{
+	GError *error;
+	PolkitSubject *subject = NULL;
+	const gchar *command;
+	UpDaemonPrivate *priv = daemon->priv;
+
+	/* no kernel support */
+	if (!priv->kernel_can_hibernate) {
+		error = g_error_new (UP_DAEMON_ERROR,
+				     UP_DAEMON_ERROR_GENERAL,
+				     "No kernel support");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* enough swap? */
+	if (!up_daemon_check_hibernate_swap (daemon)) {
+		error = g_error_new (UP_DAEMON_ERROR,
+				     UP_DAEMON_ERROR_GENERAL,
+				     "Not enough swap space");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* encrypted swap and no override? */
+	if (priv->hibernate_has_encrypted_swap &&
+	    !priv->conf_allow_hibernate_encrypted_swap) {
+		error = g_error_new (UP_DAEMON_ERROR,
+				     UP_DAEMON_ERROR_GENERAL,
+				     "Swap space is encrypted, use AllowHibernateEncryptedSwap to override");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+		goto out;
+	}
+
+	subject = up_polkit_get_subject (priv->polkit, context);
+	if (subject == NULL)
+		goto out;
+
+	if (!up_polkit_check_auth (priv->polkit, subject, "org.freedesktop.upower.hibernate", context))
+		goto out;
+
+	/* already requested */
+	if (priv->about_to_sleep_id != 0) {
+		error = g_error_new (UP_DAEMON_ERROR,
+				     UP_DAEMON_ERROR_GENERAL,
+				     "Sleep has already been requested and is pending");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* do this deferred action */
+	priv->sleep_kind = "hibernate";
+	command = up_backend_get_hibernate_command (priv->backend);
+	up_daemon_deferred_sleep (daemon, command, context);
+out:
+	if (subject != NULL)
+		g_object_unref (subject);
+	return TRUE;
+}
+
+/**
+ * up_daemon_hibernate_allowed:
+ **/
+gboolean
+up_daemon_hibernate_allowed (UpDaemon *daemon, DBusGMethodInvocation *context)
+{
+	GError *error;
+	gboolean ret;
+	PolkitSubject *subject = NULL;
+	UpDaemonPrivate *priv = daemon->priv;
+
+	subject = up_polkit_get_subject (priv->polkit, context);
+	if (subject == NULL)
+		goto out;
+
+	error = NULL;
+	ret = up_polkit_is_allowed (priv->polkit, subject, "org.freedesktop.upower.hibernate", &error);
+	if (error) {
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+	}
+	else {
+		dbus_g_method_return (context, ret);
+	}
+
+out:
+	if (subject != NULL)
+		g_object_unref (subject);
+	return TRUE;
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_daemon_register_power_daemon:
  **/
@@ -542,6 +988,11 @@
 		goto out;
 	}
 
+#ifdef ENABLE_DEPRECATED
+	/* set power policy */
+	if (priv->conf_run_powersave_command)
+		up_daemon_set_powersave (daemon, priv->on_battery);
+#endif /* ENABLE_DEPRECATED */
 out:
 	return ret;
 }
@@ -720,6 +1171,20 @@
 	up_daemon_queue_changed_property (daemon, "LidIsClosed", g_variant_new_boolean (lid_is_closed));
 }
 
+#ifdef ENABLE_DEPRECATED
+/**
+ * up_daemon_set_lid_force_sleep:
+ **/
+void
+up_daemon_set_lid_force_sleep (UpDaemon *daemon, gboolean lid_force_sleep)
+{
+	UpDaemonPrivate *priv = daemon->priv;
+	g_debug ("lid_force_sleep = %s", lid_force_sleep ? "yes" : "no");
+	priv->lid_force_sleep = lid_force_sleep;
+	g_object_notify (G_OBJECT (daemon), "lid-enforce-sleep");
+}
+#endif /* ENABLE_DEPRECATED */
+
 /**
  * up_daemon_set_lid_is_present:
  **/
@@ -864,6 +1329,12 @@
 	ret = (up_daemon_get_on_battery_local (daemon) && !up_daemon_get_on_ac_local (daemon));
 	if (ret != priv->on_battery) {
 		up_daemon_set_on_battery (daemon, ret);
+
+#ifdef ENABLE_DEPRECATED
+		/* set power policy */
+		if (priv->conf_run_powersave_command)
+			up_daemon_set_powersave (daemon, ret);
+#endif /* ENABLE_DEPRECATED */
 	}
 	warning_level = up_daemon_get_warning_level_local (daemon);
 	if (warning_level != priv->warning_level)
@@ -1158,9 +1629,14 @@
 up_daemon_init (UpDaemon *daemon)
 {
 	daemon->priv = UP_DAEMON_GET_PRIVATE (daemon);
+	daemon->priv->polkit = up_polkit_new ();
 	daemon->priv->config = up_config_new ();
 	daemon->priv->power_devices = up_device_list_new ();
 	daemon->priv->display_device = up_device_new ();
+#ifdef ENABLE_DEPRECATED
+	daemon->priv->conf_sleep_timeout = 1000;
+	daemon->priv->conf_run_powersave_command = TRUE;
+#endif /* ENABLE_DEPRECATED */
 
 	daemon->priv->use_percentage_for_policy = up_config_get_boolean (daemon->priv->config, "UsePercentageForPolicy");
 	load_percentage_policy (daemon, FALSE);
@@ -1173,9 +1649,25 @@
 	g_signal_connect (daemon->priv->backend, "device-removed",
 			  G_CALLBACK (up_daemon_device_removed_cb), daemon);
 
+#ifdef ENABLE_DEPRECATED
+	/* use a timer for the about-to-sleep logic */
+	daemon->priv->about_to_sleep_timer = g_timer_new ();
+	g_timer_stop (daemon->priv->about_to_sleep_timer);
+#endif /* ENABLE_DEPRECATED */
+
 	daemon->priv->poll_timeouts = g_hash_table_new_full (g_direct_hash, g_direct_equal,
 							     NULL, g_free);
 	daemon->priv->idle_signals = g_hash_table_new (g_direct_hash, g_direct_equal);
+
+#ifdef ENABLE_DEPRECATED
+	/* check if we have support */
+	daemon->priv->kernel_can_suspend = up_backend_kernel_can_suspend (daemon->priv->backend);
+	daemon->priv->kernel_can_hibernate = up_backend_kernel_can_hibernate (daemon->priv->backend);
+
+	/* is the swap usable? */
+	if (daemon->priv->kernel_can_hibernate)
+		daemon->priv->hibernate_has_encrypted_swap = up_backend_has_encrypted_swap (daemon->priv->backend);
+#endif /* ENABLE_DEPRECATED */
 }
 
 /**
@@ -1225,6 +1717,17 @@
 	case PROP_DAEMON_VERSION:
 		g_value_set_string (value, PACKAGE_VERSION);
 		break;
+#ifdef ENABLE_DEPRECATED
+	case PROP_CAN_SUSPEND:
+		g_value_set_boolean (value, priv->kernel_can_suspend);
+		break;
+	case PROP_CAN_HIBERNATE:
+		g_value_set_boolean (value, (priv->kernel_can_hibernate &&
+					     up_daemon_check_hibernate_swap (daemon) &&
+					     (!priv->hibernate_has_encrypted_swap ||
+					      priv->conf_allow_hibernate_encrypted_swap)));
+		break;
+#endif /* ENABLE_DEPRECATED */
 	case PROP_ON_BATTERY:
 		g_value_set_boolean (value, priv->on_battery);
 		break;
@@ -1234,6 +1737,11 @@
 	case PROP_LID_IS_PRESENT:
 		g_value_set_boolean (value, priv->lid_is_present);
 		break;
+#ifdef ENABLE_DEPRECATED
+	case PROP_LID_FORCE_SLEEP:
+		g_value_set_boolean (value, priv->lid_force_sleep);
+		break;
+#endif /* ENABLE_DEPRECATED */
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -1268,6 +1776,40 @@
 			      g_cclosure_marshal_generic,
 			      G_TYPE_NONE, 1, DBUS_TYPE_G_OBJECT_PATH);
 
+#ifdef ENABLE_DEPRECATED
+	signals[SIGNAL_SLEEPING] =
+		g_signal_new ("sleeping",
+			      G_OBJECT_CLASS_TYPE (klass),
+			      G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
+			      0, NULL, NULL,
+			      g_cclosure_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0);
+
+	signals[SIGNAL_NOTIFY_SLEEP] =
+		g_signal_new ("notify-sleep",
+			      G_OBJECT_CLASS_TYPE (klass),
+			      G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
+			      0, NULL, NULL,
+			      g_cclosure_marshal_VOID__STRING,
+			      G_TYPE_NONE, 1, G_TYPE_STRING);
+
+	signals[SIGNAL_RESUMING] =
+		g_signal_new ("resuming",
+			      G_OBJECT_CLASS_TYPE (klass),
+			      G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
+			      0, NULL, NULL,
+			      g_cclosure_marshal_VOID__VOID,
+			      G_TYPE_NONE, 0);
+
+	signals[SIGNAL_NOTIFY_RESUME] =
+		g_signal_new ("notify-resume",
+			      G_OBJECT_CLASS_TYPE (klass),
+			      G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
+			      0, NULL, NULL,
+			      g_cclosure_marshal_VOID__STRING,
+			      G_TYPE_NONE, 1, G_TYPE_STRING);
+#endif /* ENABLE_DEPRECATED */
+
 	g_object_class_install_property (object_class,
 					 PROP_DAEMON_VERSION,
 					 g_param_spec_string ("daemon-version",
@@ -1284,6 +1826,32 @@
 							       FALSE,
 							       G_PARAM_READABLE));
 
+#ifdef ENABLE_DEPRECATED
+	g_object_class_install_property (object_class,
+					 PROP_LID_FORCE_SLEEP,
+					 g_param_spec_boolean ("lid-force-sleep",
+							       "Enforce sleep on lid close",
+							       "If this computer has to sleep on lid close",
+							       FALSE,
+							       G_PARAM_READABLE));
+
+	g_object_class_install_property (object_class,
+					 PROP_CAN_SUSPEND,
+					 g_param_spec_boolean ("can-suspend",
+							       "Can Suspend",
+							       "Whether the system can suspend",
+							       FALSE,
+							       G_PARAM_READABLE));
+
+	g_object_class_install_property (object_class,
+					 PROP_CAN_HIBERNATE,
+					 g_param_spec_boolean ("can-hibernate",
+							       "Can Hibernate",
+							       "Whether the system can hibernate",
+							       FALSE,
+							       G_PARAM_READABLE));
+#endif /* ENABLE_DEPRECATED */
+
 	g_object_class_install_property (object_class,
 					 PROP_ON_BATTERY,
 					 g_param_spec_boolean ("on-battery",
@@ -1328,9 +1896,13 @@
 	if (priv->connection != NULL)
 		dbus_g_connection_unref (priv->connection);
 	g_object_unref (priv->power_devices);
+	g_object_unref (priv->polkit);
 	g_object_unref (priv->display_device);
 	g_object_unref (priv->config);
 	g_object_unref (priv->backend);
+#ifdef ENABLE_DEPRECATED
+	g_timer_destroy (priv->about_to_sleep_timer);
+#endif /* ENABLE_DEPRECATED */
 
 	G_OBJECT_CLASS (up_daemon_parent_class)->finalize (object);
 }
diff -urN a/src/up-daemon.h b/src/up-daemon.h
--- a/src/up-daemon.h	2014-11-26 06:56:16.000000000 -0500
+++ b/src/up-daemon.h	2015-05-18 11:32:17.181249863 -0400
@@ -22,6 +22,7 @@
 #define __UP_DAEMON_H__
 
 #include <glib-object.h>
+#include <polkit/polkit.h>
 #include <dbus/dbus-glib.h>
 
 #include "up-types.h"
@@ -77,6 +78,10 @@
 						 gboolean		 lid_is_closed);
 void		 up_daemon_set_lid_is_present	(UpDaemon		*daemon,
 						 gboolean		 lid_is_present);
+#ifdef ENABLE_DEPRECATED
+void		 up_daemon_set_lid_force_sleep	(UpDaemon		*daemon,
+						 gboolean		 lid_force_sleep);
+#endif /* ENABLE_DEPRECATED */
 void		 up_daemon_set_on_battery	(UpDaemon		*daemon,
 						 gboolean		 on_battery);
 void		 up_daemon_set_warning_level	(UpDaemon		*daemon,
@@ -103,6 +108,25 @@
 						 DBusGMethodInvocation	*context);
 gboolean	 up_daemon_get_critical_action	(UpDaemon		*daemon,
 						 DBusGMethodInvocation	*context);
+#ifdef ENABLE_DEPRECATED
+gboolean	 up_daemon_suspend		(UpDaemon		*daemon,
+						 DBusGMethodInvocation	*context);
+gboolean	 up_daemon_about_to_sleep	(UpDaemon		*daemon,
+						 const gchar		*sleep_kind,
+						 DBusGMethodInvocation	*context);
+gboolean	 up_daemon_suspend_allowed	(UpDaemon		*daemon,
+						 DBusGMethodInvocation	*context);
+gboolean	 up_daemon_hibernate		(UpDaemon		*daemon,
+						 DBusGMethodInvocation	*context);
+gboolean	 up_daemon_hibernate_allowed	(UpDaemon		*daemon,
+						 DBusGMethodInvocation	*context);
+gboolean	 up_daemon_can_suspend		(UpDaemon		*daemon,
+						 gboolean		 interactive,
+						 DBusGMethodInvocation	*context);
+gboolean	 up_daemon_can_hibernate	(UpDaemon		*daemon,
+						 gboolean		 interactive,
+						 DBusGMethodInvocation	*context);
+#endif /* ENABLE_DEPRECATED */
 
 G_END_DECLS
 
diff -urN a/src/up-device.h b/src/up-device.h
--- a/src/up-device.h	2014-11-26 06:56:16.000000000 -0500
+++ b/src/up-device.h	2015-05-18 11:32:17.181249863 -0400
@@ -23,6 +23,7 @@
 #define __UP_DEVICE_H__
 
 #include <glib-object.h>
+#include <polkit/polkit.h>
 #include <dbus/dbus-glib.h>
 
 #include "up-daemon.h"
diff -urN a/src/up-polkit.c b/src/up-polkit.c
--- a/src/up-polkit.c	1969-12-31 19:00:00.000000000 -0500
+++ b/src/up-polkit.c	2015-05-18 11:32:17.181249863 -0400
@@ -0,0 +1,278 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 David Zeuthen <davidz@redhat.com>
+ * Copyright (C) 2008 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <glib.h>
+#include <dbus/dbus-glib.h>
+#include <dbus/dbus-glib-lowlevel.h>
+
+#include <polkit/polkit.h>
+
+#include "up-polkit.h"
+#include "up-daemon.h"
+
+#define UP_POLKIT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UP_TYPE_POLKIT, UpPolkitPrivate))
+
+struct UpPolkitPrivate
+{
+	DBusGConnection		*connection;
+	PolkitAuthority         *authority;
+};
+
+G_DEFINE_TYPE (UpPolkit, up_polkit, G_TYPE_OBJECT)
+static gpointer up_polkit_object = NULL;
+
+/**
+ * up_polkit_get_subject:
+ **/
+PolkitSubject *
+up_polkit_get_subject (UpPolkit *polkit, DBusGMethodInvocation *context)
+{
+	GError *error;
+	gchar *sender;
+	PolkitSubject *subject;
+
+	sender = dbus_g_method_get_sender (context);
+	subject = polkit_system_bus_name_new (sender);
+	g_free (sender);
+
+	if (subject == NULL) {
+		error = g_error_new (UP_DAEMON_ERROR, UP_DAEMON_ERROR_GENERAL, "failed to get PolicyKit subject");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+	}
+
+	return subject;
+}
+
+/**
+ * up_polkit_check_auth:
+ **/
+gboolean
+up_polkit_check_auth (UpPolkit *polkit, PolkitSubject *subject, const gchar *action_id, DBusGMethodInvocation *context)
+{
+	gboolean ret = FALSE;
+	GError *error;
+	GError *error_local = NULL;
+	PolkitAuthorizationResult *result;
+
+	/* check auth */
+	result = polkit_authority_check_authorization_sync (polkit->priv->authority,
+							    subject, action_id, NULL,
+							    POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,
+							    NULL, &error_local);
+	if (result == NULL) {
+		error = g_error_new (UP_DAEMON_ERROR, UP_DAEMON_ERROR_GENERAL, "failed to check authorisation: %s", error_local->message);
+		dbus_g_method_return_error (context, error);
+		g_error_free (error_local);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* okay? */
+	if (polkit_authorization_result_get_is_authorized (result)) {
+		ret = TRUE;
+	} else {
+		error = g_error_new (UP_DAEMON_ERROR, UP_DAEMON_ERROR_GENERAL, "not authorized");
+		dbus_g_method_return_error (context, error);
+		g_error_free (error);
+	}
+out:
+	if (result != NULL)
+		g_object_unref (result);
+	return ret;
+}
+
+/**
+ * up_polkit_is_allowed:
+ **/
+gboolean
+up_polkit_is_allowed (UpPolkit *polkit, PolkitSubject *subject, const gchar *action_id, GError **error)
+{
+	gboolean ret = FALSE;
+	GError *error_local = NULL;
+	PolkitAuthorizationResult *result;
+
+	/* check auth */
+	result = polkit_authority_check_authorization_sync (polkit->priv->authority,
+							    subject, action_id, NULL,
+							    POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE,
+							    NULL, &error_local);
+	if (result == NULL) {
+		g_set_error (error, UP_DAEMON_ERROR, UP_DAEMON_ERROR_GENERAL, "failed to check authorisation: %s", error_local->message);
+		g_error_free (error_local);
+		goto out;
+	}
+
+	ret = polkit_authorization_result_get_is_authorized (result) ||
+	      polkit_authorization_result_get_is_challenge (result);
+out:
+	if (result != NULL)
+		g_object_unref (result);
+	return ret;
+}
+
+/**
+ * up_polkit_get_uid:
+ **/
+gboolean
+up_polkit_get_uid (UpPolkit *polkit, PolkitSubject *subject, uid_t *uid)
+{
+	DBusConnection *connection;
+	const gchar *name;
+
+	if (!POLKIT_IS_SYSTEM_BUS_NAME (subject)) {
+		g_debug ("not system bus name");
+		return FALSE;
+	}
+
+	connection = dbus_g_connection_get_connection (polkit->priv->connection);
+	name = polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (subject));
+	*uid = dbus_bus_get_unix_user (connection, name, NULL);
+	return TRUE;
+}
+
+/**
+ * up_polkit_get_pid:
+ **/
+gboolean
+up_polkit_get_pid (UpPolkit *polkit, PolkitSubject *subject, pid_t *pid)
+{
+	gboolean ret = FALSE;
+	GError *error = NULL;
+	const gchar *name;
+	DBusGProxy *proxy = NULL;
+
+	/* bus name? */
+	if (!POLKIT_IS_SYSTEM_BUS_NAME (subject)) {
+		g_debug ("not system bus name");
+		goto out;
+	}
+
+	name = polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (subject));
+	proxy = dbus_g_proxy_new_for_name_owner (polkit->priv->connection,
+						 "org.freedesktop.DBus",
+						 "/org/freedesktop/DBus/Bus",
+						 "org.freedesktop.DBus", &error);
+	if (proxy == NULL) {
+		g_warning ("DBUS error: %s", error->message);
+		g_error_free (error);
+		goto out;
+	}
+
+	/* get pid from DBus (quite slow) */
+	ret = dbus_g_proxy_call (proxy, "GetConnectionUnixProcessID", &error,
+				 G_TYPE_STRING, name,
+				 G_TYPE_INVALID,
+				 G_TYPE_UINT, pid,
+				 G_TYPE_INVALID);
+	if (!ret) {
+		g_warning ("failed to get pid: %s", error->message);
+		g_error_free (error);
+		goto out;
+        }
+out:
+	if (proxy != NULL)
+		g_object_unref (proxy);
+	return ret;
+}
+
+/**
+ * up_polkit_finalize:
+ **/
+static void
+up_polkit_finalize (GObject *object)
+{
+	UpPolkit *polkit;
+	g_return_if_fail (UP_IS_POLKIT (object));
+	polkit = UP_POLKIT (object);
+
+	if (polkit->priv->connection != NULL)
+		dbus_g_connection_unref (polkit->priv->connection);
+	g_object_unref (polkit->priv->authority);
+
+	G_OBJECT_CLASS (up_polkit_parent_class)->finalize (object);
+}
+
+/**
+ * up_polkit_class_init:
+ **/
+static void
+up_polkit_class_init (UpPolkitClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	object_class->finalize = up_polkit_finalize;
+	g_type_class_add_private (klass, sizeof (UpPolkitPrivate));
+}
+
+/**
+ * up_polkit_init:
+ *
+ * initializes the polkit class. NOTE: We expect polkit objects
+ * to *NOT* be removed or added during the session.
+ * We only control the first polkit object if there are more than one.
+ **/
+static void
+up_polkit_init (UpPolkit *polkit)
+{
+	GError *error = NULL;
+
+	polkit->priv = UP_POLKIT_GET_PRIVATE (polkit);
+
+	polkit->priv->connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+	if (polkit->priv->connection == NULL) {
+		if (error != NULL) {
+			g_critical ("error getting system bus: %s", error->message);
+			g_error_free (error);
+		}
+		goto out;
+	}
+
+	polkit->priv->authority = polkit_authority_get_sync (NULL, &error);
+	if (polkit->priv->authority == NULL) {
+		g_error ("failed to get pokit authority: %s", error->message);
+		g_error_free (error);
+		goto out;
+	}
+out:
+	return;
+}
+
+/**
+ * up_polkit_new:
+ * Return value: A new polkit class instance.
+ **/
+UpPolkit *
+up_polkit_new (void)
+{
+	if (up_polkit_object != NULL) {
+		g_object_ref (up_polkit_object);
+	} else {
+		up_polkit_object = g_object_new (UP_TYPE_POLKIT, NULL);
+		g_object_add_weak_pointer (up_polkit_object, &up_polkit_object);
+	}
+	return UP_POLKIT (up_polkit_object);
+}
+
diff -urN a/src/up-polkit.h b/src/up-polkit.h
--- a/src/up-polkit.h	1969-12-31 19:00:00.000000000 -0500
+++ b/src/up-polkit.h	2015-05-18 11:32:17.182249857 -0400
@@ -0,0 +1,74 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2008 Richard Hughes <richard@hughsie.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __UP_POLKIT_H
+#define __UP_POLKIT_H
+
+#include <glib-object.h>
+#include <polkit/polkit.h>
+
+G_BEGIN_DECLS
+
+#define UP_TYPE_POLKIT		(up_polkit_get_type ())
+#define UP_POLKIT(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), UP_TYPE_POLKIT, UpPolkit))
+#define UP_POLKIT_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), UP_TYPE_POLKIT, UpPolkitClass))
+#define UP_IS_POLKIT(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), UP_TYPE_POLKIT))
+#define UP_IS_POLKIT_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), UP_TYPE_POLKIT))
+#define UP_POLKIT_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), UP_TYPE_POLKIT, UpPolkitClass))
+
+typedef struct UpPolkitPrivate UpPolkitPrivate;
+
+typedef struct
+{
+	GObject parent;
+	UpPolkitPrivate	*priv;
+} UpPolkit;
+
+typedef struct
+{
+	GObjectClass parent_class;
+} UpPolkitClass;
+
+GType		 up_polkit_get_type		(void);
+UpPolkit	*up_polkit_new			(void);
+void		 up_polkit_test			(gpointer		 user_data);
+
+PolkitSubject	*up_polkit_get_subject		(UpPolkit		*polkit,
+						 DBusGMethodInvocation	*context);
+gboolean	 up_polkit_check_auth		(UpPolkit		*polkit,
+						 PolkitSubject		*subject,
+						 const gchar		*action_id,
+						 DBusGMethodInvocation	*context);
+gboolean	 up_polkit_is_allowed		(UpPolkit		*polkit,
+						 PolkitSubject		*subject,
+						 const gchar		*action_id,
+						 GError		 	**error);
+gboolean         up_polkit_get_uid		(UpPolkit              *polkit,
+                                                 PolkitSubject          *subject,
+                                                 uid_t                  *uid);
+gboolean         up_polkit_get_pid		(UpPolkit              *polkit,
+                                                 PolkitSubject          *subject,
+                                                 pid_t                  *pid);
+
+G_END_DECLS
+
+#endif /* __UP_POLKIT_H */
+
diff -urN a/src/up-self-test.c b/src/up-self-test.c
--- a/src/up-self-test.c	2014-07-17 03:46:15.000000000 -0400
+++ b/src/up-self-test.c	2015-05-18 11:32:17.182249857 -0400
@@ -33,6 +33,7 @@
 #include "up-device-list.h"
 #include "up-history.h"
 #include "up-native.h"
+#include "up-polkit.h"
 #include "up-wakeups.h"
 
 gchar *history_dir = NULL;
@@ -65,6 +66,12 @@
 {
 	UpDaemon *daemon;
 
+	/* needs polkit, which only listens to the system bus */
+	if (!g_file_test (DBUS_SYSTEM_SOCKET, G_FILE_TEST_EXISTS)) {
+		puts("No system D-BUS running, skipping test");
+		return;
+	}
+
 	daemon = up_daemon_new ();
 	g_assert (daemon != NULL);
 
@@ -276,6 +283,24 @@
 }
 
 static void
+up_test_polkit_func (void)
+{
+	UpPolkit *polkit;
+
+	/* polkit only listens to the system bus */
+	if (!g_file_test (DBUS_SYSTEM_SOCKET, G_FILE_TEST_EXISTS)) {
+		puts("No system D-BUS running, skipping test");
+		return;
+	}
+
+	polkit = up_polkit_new ();
+	g_assert (polkit != NULL);
+
+	/* unref */
+	g_object_unref (polkit);
+}
+
+static void
 up_test_wakeups_func (void)
 {
 	UpWakeups *wakeups;
@@ -307,6 +332,7 @@
 	g_test_add_func ("/power/device_list", up_test_device_list_func);
 	g_test_add_func ("/power/history", up_test_history_func);
 	g_test_add_func ("/power/native", up_test_native_func);
+	g_test_add_func ("/power/polkit", up_test_polkit_func);
 	g_test_add_func ("/power/wakeups", up_test_wakeups_func);
 	g_test_add_func ("/power/daemon", up_test_daemon_func);
 
diff -urN a/tools/up-tool.c b/tools/up-tool.c
--- a/tools/up-tool.c	2014-05-08 03:27:51.000000000 -0400
+++ b/tools/up-tool.c	2015-05-18 11:32:17.182249857 -0400
@@ -119,6 +119,10 @@
 up_client_print (UpClient *client)
 {
 	gchar *daemon_version;
+#ifdef ENABLE_DEPRECATED
+	gboolean can_suspend;
+	gboolean can_hibernate;
+#endif /* ENABLE_DEPRECATED */
 	gboolean on_battery;
 	UpDeviceLevel warning_level;
 	gboolean lid_is_closed;
@@ -127,12 +131,20 @@
 
 	g_object_get (client,
 		      "daemon-version", &daemon_version,
+#ifdef ENABLE_DEPRECATED
+		      "can-suspend", &can_suspend,
+		      "can-hibernate", &can_hibernate,
+#endif /* ENABLE_DEPRECATED */
 		      "on-battery", &on_battery,
 		      "lid-is-closed", &lid_is_closed,
 		      "lid-is-present", &lid_is_present,
 		      NULL);
 
 	g_print ("  daemon-version:  %s\n", daemon_version);
+#ifdef ENABLE_DEPRECATED
+	g_print ("  can-suspend:     %s\n", can_suspend ? "yes" : "no");
+	g_print ("  can-hibernate:   %s\n", can_hibernate ? "yes" : "no");
+#endif /* ENABLE_DEPRECATED */
 	g_print ("  on-battery:      %s\n", on_battery ? "yes" : "no");
 	g_print ("  lid-is-closed:   %s\n", lid_is_closed ? "yes" : "no");
 	g_print ("  lid-is-present:  %s\n", lid_is_present ? "yes" : "no");
diff -urN a/upower-glib.pc.in b/upower-glib.pc.in
--- a/upower-glib.pc.in	2013-10-29 06:37:01.000000000 -0400
+++ b/upower-glib.pc.in	2015-05-18 11:32:17.182249857 -0400
@@ -6,7 +6,7 @@
 Name: upower-glib
 Description: UPower is a system daemon for managing power devices
 Version: @VERSION@
-Requires.private: gthread-2.0, gio-2.0
+Requires.private: dbus-1, dbus-glib-1, gthread-2.0, gio-2.0
 Requires: glib-2.0, gobject-2.0
 Libs: -L${libdir} -lupower-glib
 Cflags: -I${includedir}/libupower-glib
